https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array	java - Why is it faster to process a sorted array than an unsorted array? - Stack Overflow	[votes:20972][favorites:9698]	Why is it faster to process a sorted array than an unsorted array? Here is a piece of C++ code that seems very peculiar. For some strange reason, sorting the data miraculously makes the code almost six times faster. #include <algorithm> #include <ctime> #include <iostream> int main() { // Generate data const unsigned arraySize = 32768; int data[arraySize]; for (unsigned c = 0; c < arraySize; ++c) data[c] = std::rand() % 256; // !!! With this, the next loop runs faster std::sort(data, data + arraySize); // Test clock_t start = clock(); long long sum = 0; for (unsigned i = 0; i < 100000; ++i) { // Primary loop for (unsigned c = 0; c < arraySize; ++c) { if (data[c] >= 128) sum += data[c]; } } double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC; std::cout << elapsedTime << std::endl; std::cout << "sum = " << sum << std::endl; } Without std::sort(data, data + arraySize);, the code runs in 11.54 seconds. With the sorted data, the code runs in 1.93 seconds. Initially, I thought this might be just a language or compiler anomaly. So I tried it in Java. import java.util.Arrays; import java.util.Random; public class Main { public static void main(String[] args) { // Generate data int arraySize = 32768; int data[] = new int[arraySize]; Random rnd = new Random(0); for (int c = 0; c < arraySize; ++c) data[c] = rnd.nextInt() % 256; // !!! With this, the next loop runs faster Arrays.sort(data); // Test long start = System.nanoTime(); long sum = 0; for (int i = 0; i < 100000; ++i) { // Primary loop for (int c = 0; c < arraySize; ++c) { if (data[c] >= 128) sum += data[c]; } } System.out.println((System.nanoTime() - start) / 1000000000.0); System.out.println("sum = " + sum); } } With a somewhat similar but less extreme result. My first thought was that sorting brings the data into the cache, but then I thought how silly that is because the array was just generated. What is going on? Why is it faster to process a sorted array than an unsorted array? The code is summing up some independent terms, and the order should not matter. java c++ performance optimization branch-prediction Branch prediction. With a sorted array, the condition data[c] >= 128 is first false for a streak of values, then becomes true for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost. The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in Mysticial's answer. Now, if we look at the code if (data[c] >= 128) sum += data[c]; we can find that the meaning of this particular if... else... branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a conditional move statement, which would be compiled into a conditional move instruction: cmovl, in an x86 system. The branch and thus the potential branch prediction penalty is removed. In C, thus C++, the statement, which would compile directly (without any optimization) into the conditional move instruction in x86, is the ternary operator ... ? ... : .... So we rewrite the above statement into an equivalent one: sum += data[c] >=128 ? data[c] : 0; While maintaining readability, we can check the speedup factor. On an Intel Core i7-2600K @ 3.4GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial): x86 // Branch - Random seconds = 8.885 // Branch - Sorted seconds = 1.528 // Branchless - Random seconds = 3.716 // Branchless - Sorted seconds = 3.71 x64 // Branch - Random seconds = 11.302 // Branch - Sorted seconds = 1.830 // Branchless - Random seconds = 2.736 // Branchless - Sorted seconds = 2.737 The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern. Now let's look more closely by investigating the x86 assembly they generate. For simplicity, we use two functions max1 and max2. max1 uses the conditional branch if... else ...: int max1(int a, int b) { if (a > b) return a; else return b; } max2 uses the ternary operator ... ? ... : ...: int max2(int a, int b) { return a > b ? a : b; } On a x86-64 machine, GCC -S generates the assembly below. :max1 movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -4(%rbp), %eax cmpl -8(%rbp), %eax jle .L2 movl -4(%rbp), %eax movl %eax, -12(%rbp) jmp .L4 .L2: movl -8(%rbp), %eax movl %eax, -12(%rbp) .L4: movl -12(%rbp), %eax leave ret :max2 movl %edi, -4(%rbp) movl %esi, -8(%rbp) movl -4(%rbp), %eax cmpl %eax, -8(%rbp) cmovge -8(%rbp), %eax leave ret max2 uses much less code due to the usage of instruction cmovge. But the real gain is that max2 does not involve branch jumps, jmp, which would have a significant performance penalty if the predicted result is not right. So why does a conditional move perform better? In a typical x86 processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called pipelining. In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict. In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like Fetch and Decode does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy. The book Computer Systems: A Programmer's Perspective, second edition explains this in detail. You can check Section 3.6.6 for Conditional Move Instructions, entire Chapter 4 for Processor Architecture, and Section 5.11.2 for a special treatment for Branch Prediction and Misprediction Penalties. Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically. If you are curious about even more optimizations that can be done to this code, consider this: Starting with the original loop: for (unsigned i = 0; i < 100000; ++i) { for (unsigned j = 0; j < arraySize; ++j) { if (data[j] >= 128) sum += data[j]; } } With loop interchange, we can safely change this loop to: for (unsigned j = 0; j < arraySize; ++j) { for (unsigned i = 0; i < 100000; ++i) { if (data[j] >= 128) sum += data[j]; } } Then, you can see that the if conditional is constant throughout the execution of the i loop, so you can hoist the if out: for (unsigned j = 0; j < arraySize; ++j) { if (data[j] >= 128) { for (unsigned i = 0; i < 100000; ++i) { sum += data[j]; } } } Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (/fp:fast is thrown, for example) for (unsigned j = 0; j < arraySize; ++j) { if (data[j] >= 128) { sum += data[j] * 100000; } } That one is 100,000x faster than before No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool cachegrind has a branch-predictor simulator, enabled by using the --branch-sim=yes flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with g++, gives these results: Sorted: ==32551== Branches: 656,645,130 ( 656,609,208 cond + 35,922 ind) ==32551== Mispredicts: 169,556 ( 169,095 cond + 461 ind) ==32551== Mispred rate: 0.0% ( 0.0% + 1.2% ) Unsorted: ==32555== Branches: 655,996,082 ( 655,960,160 cond + 35,922 ind) ==32555== Mispredicts: 164,073,152 ( 164,072,692 cond + 460 ind) ==32555== Mispred rate: 25.0% ( 25.0% + 1.2% ) Drilling down into the line-by-line output produced by cg_annotate we see for the loop in question: Sorted: Bc Bcm Bi Bim 10,001 4 0 0 for (unsigned i = 0; i < 10000; ++i) . . . . { . . . . // primary loop 327,690,000 10,016 0 0 for (unsigned c = 0; c < arraySize; ++c) . . . . { 327,680,000 10,006 0 0 if (data[c] >= 128) 0 0 0 0 sum += data[c]; . . . . } . . . . } Unsorted: Bc Bcm Bi Bim 10,001 4 0 0 for (unsigned i = 0; i < 10000; ++i) . . . . { . . . . // primary loop 327,690,000 10,038 0 0 for (unsigned c = 0; c < arraySize; ++c) . . . . { 327,680,000 164,050,007 0 0 if (data[c] >= 128) 0 0 0 0 sum += data[c]; . . . . } . . . . } This lets you easily identify the problematic line - in the unsorted version the if (data[c] >= 128) line is causing 164,050,007 mispredicted conditional branches (Bcm) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version. Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters. perf stat ./sumtest_sorted Sorted: Performance counter stats for './sumtest_sorted': 11808.095776 task-clock # 0.998 CPUs utilized 1,062 context-switches # 0.090 K/sec 14 CPU-migrations # 0.001 K/sec 337 page-faults # 0.029 K/sec 26,487,882,764 cycles # 2.243 GHz 41,025,654,322 instructions # 1.55 insns per cycle 6,558,871,379 branches # 555.455 M/sec 567,204 branch-misses # 0.01% of all branches 11.827228330 seconds time elapsed Unsorted: Performance counter stats for './sumtest_unsorted': 28877.954344 task-clock # 0.998 CPUs utilized 2,584 context-switches # 0.089 K/sec 18 CPU-migrations # 0.001 K/sec 335 page-faults # 0.012 K/sec 65,076,127,595 cycles # 2.253 GHz 41,032,528,741 instructions # 0.63 insns per cycle 6,560,579,013 branches # 227.183 M/sec 1,646,394,749 branch-misses # 25.10% of all branches 28.935500947 seconds time elapsed It can also do source code annotation with dissassembly. perf record -e branch-misses ./sumtest_unsorted perf annotate -d sumtest_unsorted Percent | Source code & Disassembly of sumtest_unsorted ------------------------------------------------ ... : sum += data[c]; 0.00 : 400a1a: mov -0x14(%rbp),%eax 39.97 : 400a1d: mov %eax,%eax 5.31 : 400a1f: mov -0x20040(%rbp,%rax,4),%eax 4.60 : 400a26: cltq 0.00 : 400a28: add %rax,-0x30(%rbp) ... See the performance tutorial for more details. I just read up on this question and its answers, and I feel an answer is missing. A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case). This approach works in general if: It's a small table and is likely to be cached in the processor You are running things in a quite tight loop and/or the processor can pre-load the data Background and why Pfew, so what the hell is that supposed to mean? From a processor perspective, your memory is slow. To compensate for the difference in speed, they build in a couple of caches in your processor (L1/L2 cache) that compensate for that. So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache - and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program. Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!). Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well. The first thing we need to know is what is small? While smaller is generally better, a rule of thumb is to stick to lookup tables that are <= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering. Constructing a table So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do. In this case: >= 128 means we can keep the value, < 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's. Managed languages You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up... Well, not exactly... :-) There has been quite some work on eliminating this branch for managed languages. For example: for (int i=0; i<array.Length; ++i) // Use array[i] In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW - that means no branch. Similarly, it will deal with other obvious cases. If you run into trouble with lookups on managed languages - the key is to add a & 0x[something]FFF to your lookup function to make the boundary check predictable - and watch it going faster. The result of this case // Generate data int arraySize = 32768; int[] data = new int[arraySize]; Random rnd = new Random(0); for (int c = 0; c < arraySize; ++c) data[c] = rnd.Next(256); //To keep the spirit of the code in-tact I'll make a separate lookup table // (I assume we cannot modify 'data' or the number of loops) int[] lookup = new int[256]; for (int c = 0; c < 256; ++c) lookup[c] = (c >= 128) ? c : 0; // Test DateTime startTime = System.DateTime.Now; long sum = 0; for (int i = 0; i < 100000; ++i) { // Primary loop for (int j = 0; j < arraySize; ++j) { // Here you basically want to use simple operations - so no // random branches, but things like &, |, *, -, +, etc. are fine. sum += lookup[data[j]]; } } DateTime endTime = System.DateTime.Now; Console.WriteLine(endTime - startTime); Console.WriteLine("sum = " + sum); Console.ReadLine(); As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the if-statement (the if statement is shared below). if (data[c] >= 128) sum += data[c]; The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the "branch predictor". A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an if-then-else structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance! Let's do some bench marking to understand it better The performance of an if-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the if-statement will be much more expensive. Let’s measure the performance of this loop with different conditions: for (int i = 0; i < max; i++) if (condition) sum++; Here are the timings of the loop with different true-false patterns: Condition Pattern Time (ms) (i & 080000000) == 0 T repeated 322 (i & 0xffffffff) == 0 F repeated 276 (i & 1) == 0 TF alternating 760 (i & 3) == 0 TFFFTFFF… 513 (i & 2) == 0 TTFFTTFF… 1675 (i & 4) == 0 TTTTFFFFTTTTFFFF… 1275 (i & 8) == 0 8T 8F 8T 8F … 752 (i & 16) == 0 16T 16F 16T 16F … 490 A “bad” true-false pattern can make an if-statement up to six times slower than a “good” pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor. So there is no doubt about the impact of branch prediction on performance! One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer. But in this case, we know values are in the range [0, 255] and we only care about values >= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the "decision bit". By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code: // Test clock_t start = clock(); long long a[] = {0, 0}; long long sum; for (unsigned i = 0; i < 100000; ++i) { // Primary loop for (unsigned c = 0; c < arraySize; ++c) { int j = (data[c] >> 7); a[j] += data[c]; } } double elapsedTime = static_cast<double>(clock() - start) / CLOCKS_PER_SEC; sum = a[1]; This code wastes half of the adds, but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement. But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for "LookUp Table" in the code). Here's the C++ code: // declare and then fill in the lookup table int lut[256]; for (unsigned c = 0; c < 256; ++c) lut[c] = (c >= 128) ? c : 0; // use the lookup table after it is built for (unsigned i = 0; i < 100000; ++i) { // Primary loop for (unsigned c = 0; c < arraySize; ++c) { sum += lut[data[c]]; } } In this case the lookup table was only 256 bytes, so it fit nicely in cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical. EDIT: One thing I forgot to put in. The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers, and used the "decision bit" technique to decide which one to follow. For example, instead of: if (x < node->value) node = node->pLeft; else node = node->pRight; this library would do something like: i = (x < node->value); node = node->link[i]; Here's a link to this code: Red Black Trees, Eternally Confuzzled In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch. Indeed, the array is partitioned in a contiguous zone with data < 128 and another with data >= 128. So you should find the partition point with a dichotomic search (using Lg(arraySize) = 15 comparisons), then do a straight accumulation from that point. Something like (unchecked) int i= 0, j, k= arraySize; while (i < k) { j= (i + k) >> 1; if (data[j] >= 128) k= j; else i= j; } sum= 0; for (; i < arraySize; i++) sum+= data[i]; or, slightly more obfuscated int i, k, j= (i + k) >> 1; for (i= 0, k= arraySize; i < k; (data[j] >= 128 ? k : i)= j) j= (i + k) >> 1; for (sum= 0; i < arraySize; i++) sum+= data[i]; A yet faster approach, that gives an approximate solution for both sorted or unsorted is: sum= 3137536; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) :-) The above behavior is happening because of Branch prediction. To understand branch prediction one must first understand Instruction Pipeline: Any instruction is broken into sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this example on Wikipedia. Generally modern processors have quite long pipelines, but for ease let's consider these 4 steps only. IF -- Fetch the instruction from memory ID -- Decode the instruction EX -- Execute the instruction WB -- Write back to CPU register 4-stage pipeline in general for 2 instructions. Moving back to the above question let's consider the following instructions: A) if (data[c] >= 128) /\ / \ / \ true / \ false / \ / \ / \ / \ B) sum += data[c]; C) for loop or print(). Without branch prediction the following would occur: To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this. when if condition returns true: When if condition returns false: As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7. So what is branch prediction? Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go onto that instruction (B or C in case of our example). In case of a correct guess, the pipeline looks something like this: If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good branch predictor. In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so first time it will randomly choose the next instruction. Later in the for loop it can base the prediction on the history. For an array sorted in ascending order, there are three possibilities: All the elements are less than 128 All the elements are greater than 128 Some starting new elements are less than 128 and later it become greater than 128 Let us assume that the predictor will always assume the true branch on the first run. So in the first case it will always take the true branch since historically all its predictions are correct. In the 2nd case, initially it will predict wrong, but after a few iterations it will predict correctly. In the 3rd case it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it see branch prediction failure in history. In all these cases the failure will be too less in number and as a result only few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in less CPU cycles. But in case of random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array. An official answer would be from Intel - Avoiding the Cost of Branch Misprediction Intel - Branch and Loop Reorganization to Prevent Mispredicts Scientific papers - branch prediction computer architecture Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions. You can also see from this lovely diagram why the branch predictor gets confused. Each element in the original code is a random value data[c] = std::rand() % 256; so the predictor will change sides as the std::rand() blow. On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken. In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters—like in the Linux kernel) you can find some if statements like the following: if (likely( everything_is_ok )) { /* Do something */ } or similarly: if (unlikely(very_improbable_condition)) { /* Do something */ } Both likely() and unlikely() are in fact macros that are defined by using something like the GCC's __builtin_expect to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See this documentation that goes through the available GCC's builtins. Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false. Frequently used Boolean operations in C++ produce many branches in compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value 0 for false and 1 for true. Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than 0 or 1, but operators that have Booleans as output can produce no other value than 0 or 1. This makes operations with Boolean variables as input less efficient than necessary. Consider example: bool a, b, c, d; c = a && b; d = a || b; This is typically implemented by the compiler in the following way: bool a, b, c, d; if (a != 0) { if (b != 0) { c = 1; } else { goto CFALSE; } } else { CFALSE: c = 0; } if (a == 0) { if (b == 0) { d = 0; } else { goto DTRUE; } } else { DTRUE: d = 1; } This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than 0 and 1. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if a and b have been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this: char a = 0, b = 1, c, d; c = a & b; d = a | b; char is used instead of bool in order to make it possible to use the bitwise operators (& and |) instead of the Boolean operators (&& and ||). The bitwise operators are single instructions that take only one clock cycle. The OR operator (|) works even if a and b have other values than 0 or 1. The AND operator (&) and the EXCLUSIVE OR operator (^) may give inconsistent results if the operands have other values than 0 and 1. ~ can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be 0 or 1 by XOR'ing it with 1: bool a, b; b = !a; can be optimized to: char a = 0, b; b = a ^ 1; a && b cannot be replaced with a & b if b is an expression that should not be evaluated if a is false ( && will not evaluate b, & will). Likewise, a || b can not be replaced with a | b if b is an expression that should not be evaluated if a is true. Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons: bool a; double x, y, z; a = x > y && z < 5.0; is optimal in most cases (unless you expect the && expression to generate many branch mispredictions). This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis. Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted & unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case. The link is here: http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm That's for sure!... Branch prediction makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!... If the array is sorted, your condition is false at the first step: data[c] >= 128, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure... Look at the image I created for you below. Which street is going to be finished faster? So programmatically, branch prediction causes the process to be slower... Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently: 1. Static 2. Dynamic Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code. In order to effectively write your code to take advantage of these rules, when writing if-else or switch statements, check the most common cases first and work progressively down to the least common. Loops do not necessarily require any special ordering of code for static branch prediction, as only the condition of the loop iterator is normally used. Branch-prediction gain! It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph). if (expression) { // Run 1 } else { // Run 2 } Whenever there's an if-else \ switch statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional branch instructions are inserted. A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the if block) depending on some condition, which is the expression evaluation in our case. That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the if block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run. Visualization: Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back. While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes. O Route 1 /------------------------------- /|\ / | ---------##/ / \ \ \ Route 2 \-------------------------------- As what has already been mentioned by others, what behind the mystery is Branch Predictor. I'm not trying to add something but explaining the concept in another way. There is concise introduction on the wiki which contains text and diagram. I do like the explanation below which uses diagram to elaborate the Branch Predictor intuitively. In computer architecture, a branch predictor is a digital circuit that tries to guess which way a branch (e.g. an if-then-else structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance in many modern pipelined microprocessor architectures such as x86. Two-way branching is usually implemented with a conditional jump instruction. A conditional jump can either be "not taken" and continue execution with the first branch of code which follows immediately after the conditional jump, or it can be "taken" and jump to a different place in program memory where the second branch of code is stored. It is not known for certain whether a conditional jump will be taken or not taken until the condition has been calculated and the conditional jump has passed the execution stage in the instruction pipeline (see fig. 1). Based on described scenario, I have written an animation demo to show how instructions are executed in pipeline in different situations. Without the Branch Predictor. Without branch prediction, the processor would have to wait until the conditional jump instruction has passed the execute stage before the next instruction can enter the fetch stage in the pipeline. The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed. It will take 9 clock cycles for 3 instructions to be completed. Use Branch Predictor and don't take conditional jump. Let's assume that the predict is not taking the conditional jump. It will take 7 clock cycles for 3 instructions to be completed. Use Branch Predictor and take conditional jump. Let's assume that the predict is not taking the conditional jump. It will take 9 clock cycles for 3 instructions to be completed. The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. As a result, making a pipeline longer increases the need for a more advanced branch predictor. As you can see, it seems we don't have reason not to use Branch Predictor. It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the demo from git It's about branch prediction. What is it? A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate. On the other hand, complex branch predictions –either neural based or variants of two-level branch prediction –provide better prediction accuracy, but they consume more power and complexity increases exponentially. In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high –ranging from 2 to 5 cycles –which is comparable to the execution time of actual branches. Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources. There really are three different kinds of branches: Forward conditional branches - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream. Backward conditional branches - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again. Unconditional branches - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply "jmp", and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as "jmpne" would redirect the instruction stream only if the result of a comparison of two values in a previous "compare" instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either "near" (within a segment) or "far" (outside the segment). Each type has different effects on branch prediction algorithms.) Static/dynamic Branch Prediction: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code. References: Branch predictor A Demonstration of Self-Profiling Branch Prediction Review Branch Prediction Besides the fact that the branch prediction may slow you down, a sorted array has another advantage: You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest. The branch prediction will miss only once. // sort backwards (higher values first) std::sort(data, data + arraySize, std::greater<int>()); for (unsigned c = 0; c < arraySize; ++c) { if (data[c] < 128) { break; } sum += data[c]; } On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which is tested at zero cost. This eliminates the need for short branches. The inner loop would look something like the following, and there would be no branch prediction hit. Therefore, the sorted version would run slower than the unsorted version on ARM, because of the extra overhead of sorting: MOV R0, #0 // R0 = sum = 0 MOV R1, #0 // R1 = c = 0 ADR R2, data // R2 = addr of data array (put this instruction outside outer loop) .inner_loop // Inner loop branch label LDRB R3, [R2, R1] // R3 = data[c] CMP R3, #128 // compare R3 to 128 ADDGE R0, R0, R3 // if R3 >= 128, then sum += data[c] -- no branch needed! ADD R1, R1, #1 // c++ CMP R1, #arraySize // compare c to arraySize BLT inner_loop // Branch to inner_loop if c < arraySize In simple words: Summary of everyone's wonderful answers for beginners... This happens due to something called the branch prediction. Basically the computer predicts the next step and executes it. If it's wrong, it comes one step back and executes with another prediction and if it's right, then it will just continue. The answer your question is very simple. If the array is unsorted, the computer has to make many predictions which may lead to an increased chance of errors. But if the data is sorted, the computer makes fewer predictions and there is less chance of error. Sorted Array: Straight Road ____________________________________________________________________________ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT Unsorted Array: Curved Road _____________ ||__| Branch prediction: Guessing/predicting which road is straight and following it without checking ___________________________________________ Straight road |_________________________________________|Longer road Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better. You are a victim of branch prediction fail. What is Branch Prediction? Consider a railroad junction: Image by Mecanismo, via Wikimedia Commons. Used under the CC-By-SA 3.0 license. Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication. You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately. Trains are heavy and have a lot of inertia. So they take forever to start up and slow down. Is there a better way? You guess which direction the train will go! If you guessed right, it continues on. If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path. If you guess right every time, the train will never have to stop. If you guess wrong too often, the train will spend a lot of time stopping, backing up, and restarting. Consider an if-statement: At the processor level, it is a branch instruction: You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path. Modern processors are complicated and have long pipelines. So they take forever to "warm up" and "slow down". Is there a better way? You guess which direction the branch will go! If you guessed right, you continue executing. If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path. If you guess right every time, the execution will never have to stop. If you guess wrong too often, you spend a lot of time stalling, rolling back, and restarting. This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment. So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every 3 times, you guess the same... In other words, you try to identify a pattern and follow it. This is more or less how branch predictors work. Most applications have well-behaved branches. So modern branch predictors will typically achieve >90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless. Further reading: "Branch predictor" article on Wikipedia. As hinted from above, the culprit is this if-statement: if (data[c] >= 128) sum += data[c]; Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement. This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction. Quick visualization: T = branch taken N = branch not taken data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ... branch = N N N N N ... N N T T T ... T T T ... = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT (easy to predict) However, when the data is completely random, the branch predictor is rendered useless because it can't predict random data. Thus there will probably be around 50% misprediction. (no better than random guessing) data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118, 14, 150, 177, 182, 133, ... branch = T, T, N, T, T, T, T, N, T, N, N, T, T, T, N ... = TTNTTTTNTNNTTTN ... (completely random - hard to predict) So what can be done? If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance. Replace: if (data[c] >= 128) sum += data[c]; with: int t = (data[c] - 128) >> 31; sum += ~t & data[c]; This eliminates the branch and replaces it with some bitwise operations. (Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of data[].) Benchmarks: Core i7 920 @ 3.5 GHz C++ - Visual Studio 2010 - x64 Release // Branch - Random seconds = 11.777 // Branch - Sorted seconds = 2.352 // Branchless - Random seconds = 2.564 // Branchless - Sorted seconds = 2.587 Java - Netbeans 7.1.1 JDK 7 - x64 // Branch - Random seconds = 10.93293813 // Branch - Sorted seconds = 5.643797077 // Branchless - Random seconds = 3.113581453 // Branchless - Sorted seconds = 3.186068823 Observations: With the Branch: There is a huge difference between the sorted and unsorted data. With the Hack: There is no difference between sorted and unsorted data. In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted. A general rule of thumb is to avoid data-dependent branching in critical loops. (such as in this example) Update: GCC 4.6.1 with -O3 or -ftree-vectorize on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast. VC++ 2010 is unable to generate conditional moves for this branch even under /Ox. Intel Compiler 11 does something miraculous. It interchanges the two loops, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark... If you give the Intel Compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange). This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...
https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-both-locally-and-remotely	How do I delete a Git branch both locally and remotely? - Stack Overflow	[votes:13017][favorites:4235]	How do I delete a Git branch both locally and remotely? I want to delete a branch both locally and on my remote project fork on GitHub. Failed Attempts to Delete Remote Branch $ git branch -d remotes/origin/bugfix error: branch 'remotes/origin/bugfix' not found. $ git branch -d origin/bugfix error: branch 'origin/bugfix' not found. $ git branch -rd origin/bugfix Deleted remote branch origin/bugfix (was 2a14ef7). $ git push Everything up-to-date $ git pull From github.com:gituser/gitproject * [new branch] bugfix -> origin/bugfix Already up-to-date. What do I need to do differently to successfully delete the remotes/origin/bugfix branch both locally and on GitHub? git git-branch git-remote Matthew's answer is great for removing remote branches and I also appreciate the explanation, but to make a simple distinction between the two commands: To remove a local branch from your machine: git branch -d {the_local_branch} (use -D instead to force deleting the branch without checking merged status) To remove a remote branch from the server: git push origin --delete {the_remote_branch} Reference: https://makandracards.com/makandra/621-git-delete-a-branch-local-or-remote The Short Answers If you want more detailed explanations of the following commands, then see the long answers in the next section. Deleting a remote branch: git push origin --delete <branch> # Git version 1.7.0 or newer git push origin :<branch> # Git versions older than 1.7.0 Deleting a local branch: git branch --delete <branch> git branch -d <branch> # Shorter version git branch -D <branch> # Force delete un-merged branches Deleting a local remote-tracking branch: git branch --delete --remotes <remote>/<branch> git branch -dr <remote>/<branch> # Shorter git fetch <remote> --prune # Delete multiple obsolete tracking branches git fetch <remote> -p # Shorter The Long Answer: there are 3 different branches to delete! When you're dealing with deleting branches both locally and remotely, keep in mind that there are 3 different branches involved: The local branch X. The remote origin branch X. The local remote-tracking branch origin/X that tracks the remote branch X. The original poster used git branch -rd origin/bugfix which only deleted his local remote-tracking branch origin/bugfix, and not the actual remote branch bugfix on origin. To delete that actual remote branch, you need git push origin --delete bugfix Additional Details The following sections describe additional details to consider when deleting your remote and remote-tracking branches. Pushing to delete remote branches also deletes remote-tracking branches Note that deleting the remote branch X from the command line using a git push will also delete the local remote-tracking branch origin/X, so it is not necessary to prune the obsolete remote-tracking branch with git fetch --prune or git fetch -p, though it wouldn't hurt if you did it anyway. You can verify that the remote-tracking branch origin/X was also deleted by running the following: # View just remote-tracking branches git branch --remotes git branch -r # View both strictly local as well as remote-tracking branches git branch --all git branch -a Pruning the obsolete local remote-tracking branch origin/X If you didn't delete your remote branch X from the command line (like above), then your local repo will still contain (a now obsolete) remote-tracking branch origin/X. This can happen if you deleted a remote branch directly through GitHub's web interface, for example. A typical way to remove these obsolete remote-tracking branches (since Git version 1.6.6) is to simply run git fetch with the --prune or shorter -p. Note that this removes all obsolete local remote-tracking branches for any remote branches that no longer exist on the remote: git fetch origin --prune git fetch origin -p # Shorter Here is the relevant quote from the 1.6.6 release notes (emphasis mine): "git fetch" learned --all and --multipleoptions, to run fetch from many repositories, and --prune option to remove remote tracking branches that went stale. These make "git remote update" and "git remote prune" less necessary (there is no plan to remove "remote update" nor "remote prune", though). Alternative to above automatic pruning for obsolete remote-tracking branches Alternatively, instead of pruning your obsolete local remote-tracking branches through git fetch -p, you can avoid making the extra network operation by just manually removing the branch(es) with the --remote or -r flags: git branch --delete --remotes origin/X git branch -dr origin/X # Shorter See Also git-branch(1) Manual Page. git-fetch(1) Manual Page. Pro Git 3.5 Git Branching - Remote Branches. Steps for deleting a branch: for deleting the remote branch: git push origin --delete <your_branch> for deleting the local branch: git branch -D <branch_name> Explain: OK, just explain what's going on here! Simply do git push origin --delete to delete your remote branch, add the name of the branch at the end and this will delete and push it to remote at the same time... Also, git branch -D, which simply delete the local branch Only!... -D stands for --delete --force which will delete the branch even it's not merged(force delete), but you can also use -d which stands for --delete which throw an error respective of the branch merge status... I also create the image below to show the steps: You can also use the following to delete the remote branch. git push --delete origin serverfix Which does the same thing as git push origin :serverfix but it may be easier to remember. If you want to delete a branch, first checkout to the branch other than the branch to be deleted. git checkout other_than_branch_to_be_deleted Deleting the local branch: git branch -D branch_to_be_deleted Deleting the remote branch: git push origin --delete branch_to_be_deleted Tip: When you delete branches using git branch -d <branchname> # deletes local branch or git push origin :<branchname> # deletes remote branch only the references are deleted. Even though the branch is actually removed on the remote the references to it still exists in the local repositories of your team members. This means that for other team members the deleted branches are still visible when they do a git branch -a. To solve this your team members can prune the deleted branches with git remote prune <repository> This is typically git remote prune origin. git branch -D <name-of-branch> git branch -D -r origin/<name-of-branch> git push origin :<name-of-branch> This is simple: Just run the following command: To delete a Git branch both locally and remotely, first delete the local branch using command: git branch -d example (here example is the branch name) And after that delete remote branch using command: git push origin :example Another approach is git push --prune origin WARNING: This will delete all remote branches that do not exist locally. Or more comprehensively, git push --mirror will effectively make the remote repository look like the local copy of the repository (local heads, remotes and tags are mirrored on remote). I use the following in my Bash settings: alias git-shoot="git push origin --delete" Then you can call: git-shoot branchname Since January 2013, GitHub included a Delete branch button next to each branch in your "Branches" page. Relevant blog post: Create and delete branches If you want to complete both these steps with a single command, you can make an alias for it by adding the below to your ~/.gitconfig: [alias] rmbranch = "!f(){ git branch -d ${1} && git push origin --delete ${1}; };f" Alternatively, you can add this to your global config from the command line using git config --global alias.rmbranch \ '!f(){ git branch -d ${1} && git push origin --delete ${1}; };f' NOTE: If using -d (lowercase d), the branch will only be deleted if it has been merged. To force the delete to happen, you will need to use -D (uppercase D). Delete locally: To delete a local branch, you can use: git branch -d branch_name To delete a branch forcibly, use -D instead of -d. git branch -D branch_name Delete remotely: There are two options: git push origin :branchname git push origin --delete branchname I would suggest you use the 2nd way as it is more intuitive. To delete your branch locally and remotely Checkout to master branch - git checkout master Delete your remote branch - git push origin --delete <branch-name> Delete your local branch - git branch --delete <branch-name> You can also do this using git remote prune origin: $ git remote prune origin Pruning origin URL: git@example.com/yourrepo.git * [pruned] origin/some-branchs It prunes and deletes remote-tracking branches from a git branch -r listing. In addition to the other answers, I often use the git_remote_branch tool. It's an extra install, but it gets you a convenient way to interact with remote branches. In this case, to delete: grb delete branch I find that I also use the publish and track commands quite often. Deleting Branches Let's assume our work on branch "contact-form" is done and we've already integrated it into "master". Since we don't need it anymore, we can delete it (locally): $ git branch -d contact-form And for deleting the remote branch: git push origin --delete contact-form Delete remote branch git push origin :<branchname> Delete local branch git branch -D <branchname> Delete local branch steps: checkout to another branch delete local branch One liner command delete both local, and remote: D=branch-name; git branch -D $D; git push origin :$D or add the alias below to your ~/.gitconfig; usage: git kill branch-name [alias] kill = "!f(){ git branch -D \"$1\"; git push origin --delete \"$1\"; };f" Simply say: git branch -d <branch-name> git push origin :<branch-name> Now you can do it with the GitHub Desktop app. After launching the app Click on the project containing the branch Switch to the branch you would like to delete From the "Branch" menu, select, "Unpublish...", to have the branch deleted from the GitHub servers. From the "Branch" menu, select, 'Delete "branch_name"...', to have the branch deleted off of your local machine (aka the machine you are currently working on) git push origin --delete branchName is easier to remember than git push origin :branchName To delete Locally - (Normal), git branch -d my_branch If your branch in rebasing/merging progress and that was not done properly means, you will get an error Rebase/Merge in progress so in that case, you won't be able to delete your branch. So either your need to solve rebasing/merging otherwise you can do force Delete by using, git branch -D my_branch To delete in Remote: git push --delete origin my_branch can do the same using , git push origin :my_branch # easy to remember both will do the same. Graphical Representation, This won't work if you have a tag with the same name as the branch on the remote: $ git push origin :branch-or-tag-name error: dst refspec branch-or-tag-name matches more than one. error: failed to push some refs to 'git@github.com:SomeName/some-repo.git' In that case you need to specify that you want to delete the branch, not the tag: git push origin :refs/heads/branch-or-tag-name Similarly, to delete the tag instead of the branch you would use: git push origin :refs/tags/branch-or-tag-name I got sick of googling for this answer, so I took a similar approach to the answer that crizCraig posted earlier. Added the following to my Bash profile: function gitdelete(){ git push origin --delete $1 git branch -D $1 } Then every time I'm done with a branch (merged into master, for example) I run the following in my terminal: gitdelete my-branch-name ...which then deletes my-branch-name from origin as as well as locally. Many of the other answers will lead to errors/warnings. This approach is relatively fool proof although you may still need git branch -D branch_to_delete if it's not fully merged into some_other_branch, for example. git checkout some_other_branch git push origin :branch_to_delete git branch -d branch_to_delete Remote pruning isn't needed if you deleted the remote branch. It's only used to get the most up to date remotes available on a repo you're tracking. I've observed git fetch will add remotes, not remove them. Here's an example of when git remote prune origin will actually do something: User A does the steps above. User B would run the following commands to see the most up to date remote branches git fetch git remote prune origin git branch -r git push origin :bugfix # Deletes remote branch git branch -d bugfix # Must delete local branch manually If you are sure you want to delete it, run git branch -D bugfix Now to clean up deleted remote branches run git remote prune origin Before executing git branch --delete <branch> make sure you determine first what the EXACT name of the remote branch is by executing: git ls-remote This will tell you what to enter EXACTLY for <branch> value. (branch is case sensitive!) Mashup of all the other answers. Requires Ruby 1.9.3+, tested only on OS X. Call this file git-remove, make it executable, and put it in your path. Then use, for example, git remove temp. #!/usr/bin/env ruby require 'io/console' if __FILE__ == $0 branch_name = ARGV[0] if (ARGV[0]) print "Press Y to force delete local and remote branch #{branch_name}..." response = STDIN.getch if ['Y', 'y', 'yes'].include?(response) puts "\nContinuing." `git branch -D #{branch_name}` `git branch -D -r origin/#{branch_name}` `git push origin --delete #{branch_name}` else puts "\nQuitting." end end Executive Summary $ git push -d <remote_name> <branch_name> $ git branch -d <branch_name> Note that in most cases the remote name is origin. Delete Local Branch To delete the local branch use one of the following: $ git branch -d branch_name $ git branch -D branch_name Note: The -d option is an alias for --delete, which only deletes the branch if it has already been fully merged in its upstream branch. You could also use -D, which is an alias for --delete --force, which deletes the branch "irrespective of its merged status." [Source: man git-branch] Delete Remote Branch [Updated on 8-Sep-2017] As of Git v1.7.0, you can delete a remote branch using $ git push <remote_name> --delete <branch_name> which might be easier to remember than $ git push <remote_name> :<branch_name> which was added in Git v1.5.0 "to delete a remote branch or a tag." Starting on Git v2.8.0 you can also use git push with the -d option as an alias for --delete. Therefore, the version of Git you have installed will dictate whether you need to use the easier or harder syntax. Delete Remote Branch [Original Answer from 5-Jan-2010] From Chapter 3 of Pro Git by Scott Chacon: Deleting Remote Branches Suppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s master branch (or whatever branch your stable codeline is in). You can delete a remote branch using the rather obtuse syntax git push [remotename] :[branch]. If you want to delete your serverfix branch from the server, you run the following: $ git push origin :serverfix To git@github.com:schacon/simplegit.git - [deleted] serverfix Boom. No more branch on your server. You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax. A way to remember this command is by recalling the git push [remotename] [localbranch]:[remotebranch] syntax that we went over a bit earlier. If you leave off the [localbranch] portion, then you’re basically saying, “Take nothing on my side and make it be [remotebranch].” I issued git push origin :bugfix and it worked beautifully. Scott Chacon was right—I will want to dog ear that page (or virtually dog ear by answering this on StackOverflow). Then you should execute this on other machines git fetch --all --prune to propagate changes.
https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch	What is the difference between 'git pull' and 'git fetch'? - Stack Overflow	[votes:9641][favorites:1881]	What is the difference between 'git pull' and 'git fetch'? What are the differences between git pull and git fetch? git git-pull git-fetch When you use pull, Git tries to automatically do your work for you. It is context sensitive, so Git will merge any pulled commits into the branch you are currently working in. pull automatically merges the commits without letting you review them first. If you don’t closely manage your branches, you may run into frequent conflicts. When you fetch, Git gathers any commits from the target branch that do not exist in your current branch and stores them in your local repository. However, it does not merge them with your current branch. This is particularly useful if you need to keep your repository up to date, but are working on something that might break if you update your files. To integrate the commits into your master branch, you use merge. It is important to contrast the design philosophy of git with the philosophy of a more traditional source control tool like SVN. Subversion was designed and built with a client/server model. There is a single repository that is the server, and several clients can fetch code from the server, work on it, then commit it back to the server. The assumption is that the client can always contact the server when it needs to perform an operation. Git was designed to support a more distributed model with no need for a central repository (though you can certainly use one if you like). Also git was designed so that the client and the "server" don't need to be online at the same time. Git was designed so that people on an unreliable link could exchange code via email, even. It is possible to work completely disconnected and burn a CD to exchange code via git. In order to support this model git maintains a local repository with your code and also an additional local repository that mirrors the state of the remote repository. By keeping a copy of the remote repository locally, git can figure out the changes needed even when the remote repository is not reachable. Later when you need to send the changes to someone else, git can transfer them as a set of changes from a point in time known to the remote repository. git fetch is the command that says "bring my local copy of the remote repository up to date." git pull says "bring the changes in the remote repository where I keep my own code." Normally git pull does this by doing a git fetch to bring the local copy of the remote repository up to date, and then merging the changes into your own code repository and possibly your working copy. The take away is to keep in mind that there are often at least three copies of a project on your workstation. One copy is your own repository with your own commit history. The second copy is your working copy where you are editing and building. The third copy is your local "cached" copy of a remote repository. Here is Oliver Steele's image of how all it all fits together: If there is sufficient interest, I suppose I could update the image to add git clone and git merge... One use case of git fetch is that the following will tell you any changes in the remote branch since your last pull... so you can check before doing an actual pull, which could change files in your current branch and working copy. git fetch git diff ...origin It cost me a little bit to understand what was the difference, but this is a simple explanation. master in your localhost is a branch. When you clone a repository you fetch the entire repository to you local host. This means that at that time you have an origin/master pointer to HEAD and master pointing to the same HEAD. when you start working and do commits you advance the master pointer to HEAD + your commits. But the origin/master pointer is still pointing to what it was when you cloned. So the difference will be: If you do a git fetch it will just fetch all the changes in the remote repository (GitHub) and move the origin/master pointer to HEAD. Meanwhile your local branch master will keep pointing to where it has. If you do a git pull, it will do basically fetch (as explained previously) and merge any new changes to your master branch and move the pointer to HEAD. Sometimes a visual representation helps. Briefly git fetch is similar to pull but doesn't merge. i.e. it fetches remote updates (refs and objects) but your local stays the same (i.e. origin/master gets updated but master stays the same) . git pull pulls down from a remote and instantly merges. More git clone clones a repo. git rebase saves stuff from your current branch that isn't in the upstream branch to a temporary area. Your branch is now the same as before you started your changes. So, git pull -rebase will pull down the remote changes, rewind your local branch, replay your changes over the top of your current branch one by one until you're up-to-date. Also, git branch -a will show you exactly what’s going on with all your branches - local and remote. This blog post was useful: The difference between git pull, git fetch and git clone (and git rebase) - Mike Pearce and covers git pull, git fetch, git clone and git rebase. ==== UPDATE I thought I'd update this to show how you'd actually use this in practice. Update your local repo from the remote (but don't merge): git fetch After downloading the updates, let's see the differences: git diff master origin/master If you're happy with those updates, then merge: git pull Notes: On step 2: For more on diffs between local and remotes, see: compare local git branch with remote branch? On step 3: It's probably more accurate (e.g. on a fast changing repo) to do a git rebase origin here. See @Justin Ohms comment in another answer. See also: http://longair.net/blog/2009/04/16/git-fetch-and-merge/ git-pull - Fetch from and merge with another repository or a local branch SYNOPSIS git pull … DESCRIPTION Runs git-fetch with the given parameters, and calls git-merge to merge the retrieved head(s) into the current branch. With --rebase, calls git-rebase instead of git-merge. Note that you can use . (current directory) as the <repository> to pull from the local repository — this is useful when merging local branches into the current branch. Also note that options meant for git-pull itself and underlying git-merge must be given before the options meant for git-fetch. You would pull if you want the histories merged, you'd fetch if you just 'want the codez' as some person has been tagging some articles around here. You can fetch from a remote repository, see the differences and then pull or merge. This is an example for a remote repository called origin and a branch called master tracking the remote branch origin/master: git checkout master git fetch git diff origin/master git rebase origin master The short and easy answer is that git pull is simply git fetch followed by git merge. It is very important to note that git pull will automatically merge whether you like it or not. This could, of course, result in merge conflicts. Let's say your remote is origin and your branch is master. If you git diff origin/master before pulling, you should have some idea of potential merge conflicts and could prepare your local branch accordingly. In addition to pulling and pushing, some workflows involve git rebase, such as this one, which I paraphrase from the linked article: git pull origin master git checkout foo-branch git rebase master git push origin foo-branch If you find yourself in such a situation, you may be tempted to git pull --rebase. Unless you really, really know what you are doing, I would advise against that. This warning is from the man page for git-pull, version 2.3.5: This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already. Do not use this option unless you have read git-rebase(1) carefully. Bonus: In speaking of pull & fetch in the above answers, I would like to share an interesting trick, git pull --rebase This above command is the most useful command in my git life which saved a lots of time. Before pushing your new commits to server, try this command and it will automatically sync latest server changes (with a fetch + merge) and will place your commit at the top in git log. No need to worry about manual pull/merge. Find details at: http://gitolite.com/git-pull--rebase This interactive graphical representation is very helpful in understanging git: http://ndpsoftware.com/git-cheatsheet.html git fetch just "downloads" the changes from the remote to your local repository. git pull downloads the changes and merges them into your current branch. "In its default mode, git pull is shorthand for git fetch followed by git merge FETCH_HEAD." I like to have some visual representation of the situation to grasp these things. Maybe other developers would like to see it too, so here's my addition. I'm not totally sure that it all is correct, so please comment if you find any mistakes. LOCAL SYSTEM . ===================================================== ================= . ================= =================== ============= REMOTE REPOSITORY . REMOTE REPOSITORY LOCAL REPOSITORY WORKING COPY (ORIGIN) . (CACHED) for example, . mirror of the a github repo. . remote repo Can also be . multiple repo's . . . FETCH *------------------>* Your local cache of the remote is updated with the origin (or multiple external sources, that is git's distributed nature) . PULL *-------------------------------------------------------->* changes are merged directly into your local copy. when conflicts occur, you are asked for decisions. . COMMIT . *<---------------* When coming from, for example, subversion, you might think that a commit will update the origin. In git, a commit is only done to your local repo. . PUSH *<---------------------------------------* Synchronizes your changes back into the origin. Some major advantages for having a fetched mirror of the remote are: Performance (scroll through all commits and messages without trying to squeeze it through the network) Feedback about the state of your local repo (for example, I use Atlassian's SourceTree, which will give me a bulb indicating if I'm commits ahead or behind compared to the origin. This information can be updated with a GIT FETCH). I have struggled with this as well. In fact I got here with a google search of exactly the same question. Reading all these answers finally painted a picture in my head and I decided to try to get this down looking at the state of the 2 repositories and 1 sandbox and actions performed over time while watching the version of them. So here is what I came up with. Please correct me if I messed up anywhere. The three repos with a fetch: --------------------- ----------------------- ----------------------- - Remote Repo - - Remote Repo - - Remote Repo - - - - gets pushed - - - - @ R01 - - @ R02 - - @ R02 - --------------------- ----------------------- ----------------------- --------------------- ----------------------- ----------------------- - Local Repo - - Local Repo - - Local Repo - - pull - - - - fetch - - @ R01 - - @ R01 - - @ R02 - --------------------- ----------------------- ----------------------- --------------------- ----------------------- ----------------------- - Local Sandbox - - Local Sandbox - - Local Sandbox - - Checkout - - new work done - - - - @ R01 - - @ R01+ - - @R01+ - --------------------- ----------------------- ----------------------- The three repos with a pull --------------------- ----------------------- ----------------------- - Remote Repo - - Remote Repo - - Remote Repo - - - - gets pushed - - - - @ R01 - - @ R02 - - @ R02 - --------------------- ----------------------- ----------------------- --------------------- ----------------------- ----------------------- - Local Repo - - Local Repo - - Local Repo - - pull - - - - pull - - @ R01 - - @ R01 - - @ R02 - --------------------- ----------------------- ----------------------- --------------------- ----------------------- ----------------------- - Local Sandbox - - Local Sandbox - - Local Sandbox - - Checkout - - new work done - - merged with R02 - - @ R01 - - @ R01+ - - @R02+ - --------------------- ----------------------- ----------------------- This helped me understand why a fetch is pretty important. We simply say: git pull == git fetch + git merge If you run git pull, you do not need to merge the data to local. If you run git fetch, it means you must run git merge for getting the latest code to your local machine. Otherwise, the local machine code would not be changed without merge. So in the Git Gui, when you do fetch, you have to merge the data. Fetch itself won't make the code changes at your local. You can check that when you update the code by fetching once fetch and see; the code it won't change. Then you merge... You will see the changed code. git fetch pulls down the code from the remote server to your tracking branches in your local repository. If your remote is named origin (the default) then these branches will be within origin/, for example origin/master, origin/mybranch-123, etc. These are not your current branches, they are local copies of those branches from the server. git pull does a git fetch but then also merges the code from the tracking branch into your current local version of that branch. If you're not ready for that changes yet, just git fetch first. git fetch will retrieve remote branches so that you can git diff or git merge them with the current branch. git pull will run fetch on the remote brach tracked by the current branch and then merge the result. You can use git fetch to see if there are any updates to the remote branch without necessary merging them with your local branch. The Difference between GIT Fetch and GIT Pull can be explained with the following scenario: (Keeping in mind that pictures speak louder than words!, I have provided pictorial representation) Let's take an example that you are working on a project with your team members. So their will be one main Branch of the project and all the contributors must fork it to their own local repository and then work on this local branch to modify/Add modules then push back to the main branch. So, Initial State of the two Branches when you forked the main project on your local repository will be like this- (A, B and C are Modules already completed of the project) Now, you have started working on the new module (suppose D) and when you have completed the D module you want to push it to the main branch, But meanwhile what happens is that one of your teammates has developed new Module E, F and modified C. So now what has happened is that your local repository is lacking behind the original progress of the project and thus pushing of your changes to main branch can lead to conflict and may cause your Module D to malfunction. To avoid such issues and to work parallel with the original progress of the project their are Two ways: 1. Git Fetch- This will Download all the changes that have been made to the origin/main branch project which are not present in your local branch. And will wait for the Git Merge command to apply the changes that have been fetched to your Repository or branch. So now You can carefully monitor the files before merging it to your repository. And you can also modify D if required because of Modified C. 2. Git Pull- This will update your local branch with the origin/main branch i.e. actually what it does is combination of Git Fetch and Git merge one after another. But this may Cause Conflicts to occur, so it’s recommended to use Git Pull with a clean copy. Git Fetch You download changes to your local branch from origin through fetch. Fetch asks the remote repo for all commits that others have made but you don't have on your local repo. Fetch downloads these commits and adds them to the local repository. Git Merge You can apply changes downloaded through fetch using the merge command. Merge will take the commits retrieved from fetch and try to add them to your local branch. The merge will keep the commit history of your local changes so that when you share your branch with push, Git will know how others can merge your changes. Git Pull Fetch and merge run together often enough that a command that combines the two, pull, was created. Pull does a fetch and then a merge to add the downloaded commits into your local branch. OK, here are some information about git pull and git fetch, so you can understand the actual differences... in few simple words, fetch gets the latest data, but not the code changes and not going to mess with your current code, but pull get the code changes and merge it your local branch, read on to get more details about each: git fetch It will download all refs and object and any new branches to local Repository... Fetch branches and/or tags (collectively, "refs") from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of below for ways to control this behavior). By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote..tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well. git fetch can fetch from either a single named repository or URL, or from several repositories at once if is given and there is a remotes. entry in the configuration file. (See git-config1). When no remote is specified, by default the origin remote will be used, unless there’s an upstream branch configured for the current branch. The names of refs that are fetched, together with the object names they point at, are written to .git/FETCH_HEAD. This information may be used by scripts or other git commands, such as git-pull. git pull It will apply the changes from remote to the current branch in local... Incorporates changes from a remote repository into the current branch. In its default mode, git pull is shorthand for git fetch followed by git merge FETCH_HEAD. More precisely, git pull runs git fetch with the given parameters and calls git merge to merge the retrieved branch heads into the current branch. With --rebase, it runs git rebase instead of git merge. should be the name of a remote repository as passed to git-fetch1. can name an arbitrary remote ref (for example, the name of a tag) or even a collection of refs with corresponding remote-tracking branches (e.g., refs/heads/:refs/remotes/origin/), but usually it is the name of a branch in the remote repository. Default values for and are read from the "remote" and "merge" configuration for the current branch as set by git-branch --track. I also create the visual below to show you how git fetch and git pull working together... The only difference between git pull and git fetch is that : git pull pulls from a remote branch and merges it. git fetch only fetches from the remote branch but it does not merge i.e. git pull = git fetch + git merge ... Git allows chronologically older commits to be applied after newer commits. Because of this, the act of transferring commits between repositories is split into two steps: Copying new commits from remote branch to copy of this remote branch inside local repo. (repo to repo operation) master@remote >> remote/origin/master@local Integrating new commits to local branch (inside-repo operation) remote/origin/master@local >> master@local There are two ways of doing step 2. You can: Fork local branch after last common ancestor and add new commits parallel to commits which are unique to local repository, finalized by merging commit, closing the fork. Insert new commits after last common ancestor and reapply commits unique to local repository. In git terminology, step 1 is git fetch, step 2 is git merge or git rebase git pull is git fetch and git merge What is the difference between git pull and git fetch? To understand this, you first need to understand that your local git maintains not only your local repository, but it also maintains a local copy of the remote repository. git fetch brings your local copy of the remote repository up to date. For example, if your remote repository is GitHub - you may want to fetch any changes made in the remote repository to your local copy of it the remote repository. This will allow you to perform operations such as compare or merge. git pull on the other hand will bring down the changes in the remote repository to where you keep your own code. Typically, git pull will do a git fetch first to bring the local copy of the remote repository up to date, and then it will merge the changes into your own code repository and possibly your working copy. Git obtains the branch of the latest version from the remote to the local using two commands: git fetch: Git is going to get the latest version from remote to local, but it do not automatically merge. git fetch origin master git log -p master..origin/master git merge origin/master The commands above mean that download latest version of the main branch from origin from the remote to origin master branch. And then compares the local master branch and origin master branch. Finally, merge. git pull: Git is going to get the latest version from the remote and merge into the local. git pull origin master The command above is the equivalent to git fetch and git merge. In practice, git fetch maybe more secure because before the merge we can see the changes and decide whether to merge. git pull == ( git fetch + git merge) git fetch does not changes to local branches. If you already have a local repository with a remote set up for the desired project, you can grab all branches and tags for the existing remote using git fetch . ... Fetch does not make any changes to local branches, so you will need to merge a remote branch with a paired local branch to incorporate newly fetch changes. from github Actually Git maintains a copy of your own code and the remote repository. The command git fetch makes your local copy up to date by getting data from remote repository. The reason we need this is because somebody else might have made some changes to the code and you want to keep yourself updated. The command git pull brings the changes in the remote repository to where you keep your own code. Normally, git pull does this by doing a ‘git fetch’ first to bring the local copy of the remote repository up to date, and then it merges the changes into your own code repository and possibly your working copy. Trying to be clear and simple. The git pull command is actually a shortcut for git fetch followed by the git merge or the git rebase command depending on your configuration. You can configure your Git repository so that git pull is a fetch followed by a rebase. git pull = git fetch + git merge From Pro Git 2.5 Git Basics - Working with Remotes: Fetching and Pulling from Your Remotes: It’s important to note that the fetch command pulls the data to your local repository — it doesn’t automatically merge it with any of your work or modify what you’re currently working on. You have to merge it manually into your work when you’re ready. If you have a branch set up to track a remote branch, you can use the git pull command to automatically fetch and then merge a remote branch into your current branch. This may be an easier or more comfortable workflow for you; and by default, the git clone command automatically sets up your local master branch to track the remote master branch on the server you cloned from (assuming the remote has a master branch). Running git pull generally fetches data from the server you originally cloned from and automatically tries to merge it into the code you’re currently working on. In the simplest terms, git pull does a git fetch followed by a git merge. You can do a git fetch at any time to update your remote-tracking branches under refs/remotes/<remote>/. This operation never changes any of your own local branches under refs/heads, and is safe to do without changing your working copy. I have even heard of people running git fetch periodically in a cron job in the background (although I wouldn't recommend doing this). A git pull is what you would do to bring a local branch up-to-date with its remote version, while also updating your other remote-tracking branches. Git documentation: git pull
https://stackoverflow.com/questions/477816/what-is-the-correct-json-content-type	What is the correct JSON content type? - Stack Overflow	[votes:8933][favorites:1326]	What is the correct JSON content type? I've been messing around with JSON for some time, just pushing it out as text and it hasn't hurt anybody (that I know of), but I'd like to start doing things properly. I have seen so many purported "standards" for the JSON content type: application/json application/x-javascript text/javascript text/x-javascript text/x-json But which is correct, or best? I gather that there are security and browser support issues varying between them. I know there's a similar question, What MIME type if JSON is being returned by a REST API?, but I'd like a slightly more targeted answer. json content-type IANA has registered the official MIME Type for JSON as application/json. When asked about why not text/json, Crockford seems to have said JSON is not really JavaScript nor text and also IANA was more likely to hand out application/* than text/*. More resources: Media Types Request for Comments 4627 bluesmoon: JSON has a type For JSON: Content-Type: application/json For JSON-P: Content-Type: application/javascript Of course, the correct MIME media type for JSON is application/json, but it's necessary to realize what type of data is expected in your application. For example, I use Ext GWT and the server response must go as text/html but contains JSON data. Client side, Ext GWT form listener uploadForm.getForm().addListener(new FormListenerAdapter() { @Override public void onActionFailed(Form form, int httpStatus, String responseText) { MessageBox.alert("Error"); } @Override public void onActionComplete(Form form, int httpStatus, String responseText) { MessageBox.alert("Success"); } }); In case of using application/json response type, the browser suggests me to save the file. Server side source code snippet using Spring MVC return new AbstractUrlBasedView() { @SuppressWarnings("unchecked") @Override protected void renderMergedOutputModel(Map model, HttpServletRequest request, HttpServletResponse response) throws Exception { response.setContentType("text/html"); response.getWriter().write(json); } }; JSON: Response is dynamically generated data, according to the query parameters passed in the URL. Example: { "Name": "Foo", "Id": 1234, "Rank": 7 } Content-Type: application/json JSON-P: JSON with padding. Response is JSON data, with a function call wrapped around it. Example: functionCall({"Name": "Foo", "Id": 1234, "Rank": 7}); Content-Type: application/javascript If you are using Ubuntu or Debian and you serve .json files through Apache, you might want to serve the files with the correct content type. I am doing this primarily because I want to use the Firefox extension JSONView The Apache module mod_mime will help to do this easily. However, with Ubuntu you need to edit the file /etc/mime.types and add the line application/json json Then restart Apache: sudo service apache2 restart If you're calling ASP.NET Web Services from the client-side you have to use application/json for it to work. I believe this is the same for the jQuery and Ext frameworks. The right content type for JSON is application/json UNLESS you're using JSONP, also known as JSON with Padding, which is actually JavaScript and so the right content type would be application/javascript. There is no doubt that application/json is the best MIME type for a JSON response. But I had some experience where I had to use application/x-javascript because of some compression issues. My hosting environment is shared hosting with GoDaddy. They do not allow me to change server configurations. I had added the following code to my web.config file for compressing responses. <httpCompression> <scheme name="gzip" dll="%Windir%\system32\inetsrv\gzip.dll"/> <dynamicTypes> <add mimeType="text/*" enabled="true"/> <add mimeType="message/*" enabled="true"/> <add mimeType="application/javascript" enabled="true"/> <add mimeType="*/*" enabled="false"/> </dynamicTypes> <staticTypes> <add mimeType="text/*" enabled="true"/> <add mimeType="message/*" enabled="true"/> <add mimeType="application/javascript" enabled="true"/> <add mimeType="*/*" enabled="false"/> </staticTypes> </httpCompression> <urlCompression doStaticCompression="true" doDynamicCompression="true"/> By using this, the .aspx pages was compressed with g-zip but JSON responses were not. I added <add mimeType="application/json" enabled="true"/> in the static and dynamic types sections. But this does not compress JSON responses at all. After that I removed this newly added type and added <add mimeType="application/x-javascript" enabled="true"/> in both the static and dynamic types sections, and changed the response type in .ashx (asynchronous handler) to application/x-javascript And now I found that my JSON responses were compressed with g-zip. So I personally recommend to use application/x-javascript only if you want to compress your JSON responses on a shared hosting environment. Because in shared hosting, they do not allow you to change IIS configurations. Only when using application/json as the MIME type I have the following (as of November 2011 with the most recent versions of Chrome, Firefox with Firebug): No more warnings from Chrome when the JSON is loaded from the server. Firebug will add a tab to the response showing you the JSON data formatted. If the MIME type is different, it will just show up as 'Response content'. Not everything works for content type application/json. If you are using ExtJS form submit to upload file, be aware that the server response is parsed by the browser to create the document for the <iframe>. If the server is using JSON to send the return object, then the Content-Type header must be set to text/html in order to tell the browser to insert the text unchanged into the document body. See the Ext JS 3.4.0 API documentation. JSON is a domain-specific language (DSL) and a data format independent of JavaScript, and as such has its own MIME type, application/json. Respect for MIME types is of course client driven, so text/plain may do for transfer of bytes, but then you would be pushing up interpretation to the vendor application domain unnecessarily - application/json. Would you transfer XML via text/plain? But honestly, your choice of MIME type is advice to the client as to how to interpret the data- text/plain or text/HTML (when it's not HTML) is like type erasure- it's as uninformative as making all your objects of type Object in a typed language. No browser runtime I know of will take a JSON document and automatically make it available to the runtime as a JavaScript accessible object without intervention, but if you are working with a crippled client, that's an entirely different matter. But that's not the whole story- RESTful JSON services often don't have JavaScript runtimes, but it doesn't stop them using JSON as a viable data interchange format. If clients are that crippled... then I would consider perhaps HTML injection via an Ajax templating service instead. Application/JSON! If you're in a client-side environment, investigating about the cross-browser support is mandatory for a well supported web application. The right HTTP Content-Type would be application/json, as others already highlighted too, but some clients do not handle it very well, that's why jQuery recommends the default text/html. The correct answer is: Content-Type: application/json As many others have mentioned, application/json is the correct answer. But what haven't been explained yet is what the other options you proposed mean. application/x-javascript: Experimental MIME type for JavaScript before application/javascript was made standard. text/javascript: Now obsolete. You should use application/javascript when using javascript. text/x-javascript: Experimental MIME type for the above situation. text/x-json: Experimental MIME type for JSON before application/json got officially registered. All in all, whenever you have any doubts about content types, you should check this link In JSP, you can use this in page directive: <%@ page language="java" contentType="application/json; charset=UTF-8" pageEncoding="UTF-8"%> The correct MIME media type for JSON is application/json. JSP will use it for sending a response to the client. “application/json” is the correct JSON content type. def ajaxFindSystems = { def result = Systems.list() render(contentType:'application/json') { results { result.each{sys-> system(id:sys.id, name:sys.name) } } resultset (rows:result.size()) } } The IANA registration for application/json says Applications that use this media type: JSON has been used to exchange data between applications written in all of these programming languages: ActionScript, C, C#, Clojure, ColdFusion, Common Lisp, E, Erlang, Go, Java, JavaScript, Lua, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, and Scheme. You'll notice that IANA.org doesn't list any of these other media types, in fact even application/javascript is now obsolete. So application/json is really the only possible correct answer. Browser support is another thing. The most widely supported non-standard media types text/json or text/javascript. But some big names even use text/plain. Even more strange is the Content-Type header sent by Flickr, who returns a JSON string with text/xml. Google example included as well, responding with text/html yet a JSON string. Examples: curl -I http://ajax.googleapis.com:80/ajax/services/search/web\?q\=json Output: Content-Type: text/html curl -I https://www.flickr.com/services/rest/?method=flickr.test.echo&format=json&api_key=f82254c1491d894f1204d8408f645a93 Output: Content-Type: text/xml The right MIME type is application/json BUT I experienced many situations where the browser type or the framework user needed: text/html application/javascript I use the below contentType: 'application/json', data: JSON.stringify(SendData), The Content-Type header should be set to 'application/json' when posting. Server listening for the request should include "Accept=application/json". In Spring MVC you can do it like this: @RequestMapping(value="location", method = RequestMethod.POST, headers = "Accept=application/json") Add headers to the response: HttpHeaders headers = new HttpHeaders(); headers.add("Content-Type", "application/json"); In Spring you have a defined type: MediaType.APPLICATION_JSON_VALUE which is equivalent to application/json. The application/json works great in PHP to store an array or object data. I use this code to put data in JSON on Google Cloud Storage (GCS) which is set publically viewable: $context = stream_context_create([ 'gs' => [ 'acl'=>'public-read', 'Content-Type' => 'application/json', ] ]); file_put_contents( "gs://BUCKETNAME/FILENAME.json", json_encode((object) $array), false, $context ); To get back the data is straight forward: $data = json_decode(file_get_contents("gs://BUCKETNAME/FILENAME.json")); If the JSON is with padding then it will be application/jsonp. If the JSON is without padding then it will be application/json. To deal with both, it is a good practice to use: 'application/javascript' without bothering whether it is with padding or without padding. For JSON, I am using: Content-Type: application/json This is described in the IETF's JSON Data Interchange Format 7158 proposal, Section 1.2: Specifications of JSON. If you get data from REST API in JSON so you have to use content-type For JSON data: Content-Type:application/json For HTML data: Content-Type:text/html, For XHTML data: Content-Type:application/xhtml+xml, For XML data: Content-Type:text/xml, application/xml PHP developers use this: <?php header("Content-type: application/json"); // Do something here... ?> Extending the accepted responses, when you are using JSON in a REST context... There is a strong argument about using application/x-resource+json and application/x-collection+json when you are representing REST resources and collections. And if you decide to follow the jsonapi specification, you should use of application/vnd.api+json, as it is documented. Altough there is not an universal standard, it is clear that the added semantic to the resources being transfered justify a more explicit Content-Type than just application/json. Following this reasoning, other contexts could justify a more specific Content-Type. JSON (JavaScript Object Notation) and JSONP ("JSON with padding") formats seems to be very similar and therefor it might be very confusing which MIME type they should be using. Even though the formats seems to be very similar, there are some subtle differences between them. So whenever in any doubts, I have very simple approach (which works perfectly find in most cases), namely, go and check corresponding RFC document. JSON RFC 4627 (The application/json Media Type for JavaScript Object Notation (JSON)) is a specifications of JSON format. It says in section 6, that the MIME media type for JSON text is application/json. JSONP JSONP ("JSON with padding") is handled different way than JSON, in a browser. JSONP is treated as a regular JavaScript script and therefor it should use application/javascript, the current official MIME type for JavaScript. In many cases, however, text/javascript MIME type will work fine too. Note that text/javascript has been marked as obsolete by RFC 4329 (Scripting Media Types) document and it is recommended to use application/javascript type instead. However, due to legacy reasons, text/javascript is still widely used and it has cross-browser support (which is not always a case with application/javascript MIME type, especially with older browsers). Content-type: application/json,json Content-Type: application/javascript, json-P Content-type: application/x-javascript, javascript Content-type: text/javascript, javascript BUT obsolete, older IE versions used to use as html attribute Content-type: text/x-javascript, JavaScript Media Types BUT obsolete Content-type: text/x-json, json before application/json got officially registered. For JSON text: The MIME media type for JSON text is application/json. The default encoding is UTF-8. (Source: RFC 4627). For JSONP with callback: application/javascript Here are some blog posts that were mentioned in the comments that are relevant. Why you shouldn't use text/html for JSON InternetExplorer sometimes has issues with application/json A rather complete list of Mimetypes and what to use them for
https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do	python - What does the "yield" keyword do? - Stack Overflow	[votes:7876][favorites:4725]	What does the “yield” keyword do? What is the use of the yield keyword in Python? What does it do? For example, I'm trying to understand this code1: def _get_child_candidates(self, distance, min_dist, max_dist): if self._leftchild and distance - max_dist < self._median: yield self._leftchild if self._rightchild and distance + max_dist >= self._median: yield self._rightchild And this is the caller: result, candidates = [], [self] while candidates: node = candidates.pop() distance = node._get_dist(obj) if distance <= max_dist and distance >= min_dist: result.extend(node._values) candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result What happens when the method _get_child_candidates is called? Is a list returned? A single element? Is it called again? When will subsequent calls stop? 1. The code comes from Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: Module mspace. python iterator generator yield coroutine Shortcut to Grokking yield When you see a function with yield statements, apply this easy trick to understand what will happen: Insert a line result = [] at the start of the function. Replace each yield expr with result.append(expr). Insert a line return result at the bottom of the function. Yay - no more yield statements! Read and figure out code. Compare function to original definition. This trick may give you an idea of the logic behind the function, but what actually happens with yield is significantly different that what happens in the list based approach. In many cases the yield approach will be a lot more memory efficient and faster too. In other cases this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more... Don't confuse your Iterables, Iterators and Generators First, the iterator protocol - when you write for x in mylist: ...loop body... Python performs the following two steps: Gets an iterator for mylist: Call iter(mylist) -> this returns an object with a next() method (or __next__() in Python 3). [This is the step most people forget to tell you about] Uses the iterator to loop over items: Keep calling the next() method on the iterator returned from step 1. The return value from next() is assigned to x and the loop body is executed. If an exception StopIteration is raised from within next(), it means there are no more values in the iterator and the loop is exited. The truth is Python performs the above two steps anytime it wants to loop over the contents of an object - so it could be a for loop, but it could also be code like otherlist.extend(mylist) (where otherlist is a Python list). Here mylist is an iterable because it implements the iterator protocol. In a user defined class, you can implement the __iter__() method to make instances of your class iterable. This method should return an iterator. An iterator is an object with a next() method. It is possible to implement both __iter__() and next() on the same class, and have __iter__() return self. This will work for simple cases, but not when you want two iterators looping over the same object at the same time. So that's the iterator protocol, many objects implement this protocol: Built-in lists, dictionaries, tuples, sets, files. User defined classes that implement __iter__(). Generators. Note that a for loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls next(). Built-in lists return their items one by one, dictionaries return the keys one by one, files return the lines one by one, etc. And generators return... well that's where yield comes in: def f123(): yield 1 yield 2 yield 3 for item in f123(): print item Instead of yield statements, if you had three return statements in f123() only the first would get executed, and the function would exit. But f123() is no ordinary function. When f123() is called, it does not return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the for loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the yield it previously returned from, executes the next line of code, in this case a yield statement, and returns that as the next item. This happens until the function exits, at which point the generator raises StopIteration, and the loop exits. So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing __iter__() and next() methods to keep the for loop happy. At the other end however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode. Why Use Generators? Usually you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps state in instance members and performs the next logical step in it's next() (or __next__() in Python 3) method. Depending on the logic, the code inside the next() method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution. Think of it this way: An iterator is just a fancy sounding term for an object that has a next() method. So a yield-ed function ends up being something like this: Original version: def some_function(): for i in xrange(4): yield i for i in some_function(): print i This is basically what the python interpreter does with the above code: class it: def __init__(self): #start at -1 so that we get 0 when we add 1 below. self.count = -1 #the __iter__ method will be called once by the for loop. #the rest of the magic happens on the object returned by this method. #in this case it is the object itself. def __iter__(self): return self #the next method will be called repeatedly by the for loop #until it raises StopIteration. def next(self): self.count += 1 if self.count < 4: return self.count else: #a StopIteration exception is raised #to signal that the iterator is done. #This is caught implicitly by the for loop. raise StopIteration def some_func(): return it() for i in some_func(): print i For more insight as to what's happening behind the scenes, the for loop can be rewritten to this: iterator = some_func() try: while 1: print iterator.next() except StopIteration: pass Does that make more sense or just confuse you more? :) EDIT: I should note that this IS an oversimplification for illustrative purposes. :) EDIT 2: Forgot to throw the StopIteration exception The yield keyword is reduced to two simple facts: If the compiler detects the yield keyword anywhere inside a function, that function no longer returns via the return statement. Instead, it immediately returns a lazy "pending list" object called a generator A generator is iterable. What is an iterable? It's anything like a list or set or range or dict-view, with a built-in protocol for visiting each element in a certain order. In a nutshell: a generator is a lazy, incrementally-pending list, and yield statements allow you to use function notation to program the list values the generator should incrementally spit out. generator = myYieldingFunction(...) x = list(generator) generator v [x[0], ..., ???] generator v [x[0], x[1], ..., ???] generator v [x[0], x[1], x[2], ..., ???] StopIteration exception [x[0], x[1], x[2]] done list==[x[0], x[1], x[2]] Example Let's define a function makeRange that's just like Python's range. Calling makeRange(n) RETURNS A GENERATOR: def makeRange(n): # return 0,1,2,...,n-1 i = 0 while i < n: yield i i += 1 >>> makeRange(5) <generator object makeRange at 0x19e4aa0> To force the generator to immediately return its pending values, you can pass it into list() (just like you could any iterable): >>> list(makeRange(5)) [0, 1, 2, 3, 4] Comparing example to "just returning a list" The above example can be thought of as merely creating a list which you append to and return: # list-version # # generator-version def makeRange(n): # def makeRange(n): """return [0,1,2,...,n-1]""" #~ """return 0,1,2,...,n-1""" TO_RETURN = [] #> i = 0 # i = 0 while i < n: # while i < n: TO_RETURN += [i] #~ yield i i += 1 # i += 1 ## indented return TO_RETURN #> >>> makeRange(5) [0, 1, 2, 3, 4] There is one major difference, though; see the last section. How you might use generators An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so: # _ITERABLE_ >>> [x+10 for x in makeRange(5)] [10, 11, 12, 13, 14] To get a better feel for generators, you can play around with the itertools module (be sure to use chain.from_iterable rather than chain when warranted). For example, you might even use generators to implement infinitely-long lazy lists like itertools.count(). You could implement your own def enumerate(iterable): zip(count(), iterable), or alternatively do so with the yield keyword in a while-loop. Please note: generators can actually be used for many more things, such as implementing coroutines or non-deterministic programming or other elegant things. However, the "lazy lists" viewpoint I present here is the most common use you will find. Behind the scenes This is how the "Python iteration protocol" works. That is, what is going on when you do list(makeRange(5)). This is what I describe earlier as a "lazy, incremental list". >>> x=iter(range(5)) >>> next(x) 0 >>> next(x) 1 >>> next(x) 2 >>> next(x) 3 >>> next(x) 4 >>> next(x) Traceback (most recent call last): File "<stdin>", line 1, in <module> StopIteration The built-in function next() just calls the objects .next() function, which is a part of the "iteration protocol" and is found on all iterators. You can manually use the next() function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that... Minutiae Normally, most people would not care about the following distinctions and probably want to stop reading here. In Python-speak, an iterable is any object which "understands the concept of a for-loop" like a list [1,2,3], and an iterator is a specific instance of the requested for-loop like [1,2,3].__iter__(). A generator is exactly the same as any iterator, except for the way it was written (with function syntax). When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself. Thus, in the unlikely event that you are failing to do something like this... > x = myRange(5) > list(x) [0, 1, 2, 3, 4] > list(x) [] ... then remember that a generator is an iterator; that is, it is one-time-use. If you want to reuse it, you should call myRange(...) again. If you need to use the result twice, convert the result to a list and store it in a variable x = list(myRange(5)). Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use itertools.tee if absolutely necessary, since the copyable iterator Python PEP standards proposal has been deferred. What does the yield keyword do in Python? Answer Outline/Summary A function with yield, when called, returns a Generator. Generators are iterators because they implement the iterator protocol, so you can iterate over them. A generator can also be sent information, making it conceptually a coroutine. In Python 3, you can delegate from one generator to another in both directions with yield from. (Appendix critiques a couple of answers, including the top one, and discusses the use of return in a generator.) Generators: yield is only legal inside of a function definition, and the inclusion of yield in a function definition makes it return a generator. The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is frozen at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield. yield provides an easy way of implementing the iterator protocol, defined by the following two methods: __iter__ and next (Python 2) or __next__ (Python 3). Both of those methods make an object an iterator that you could type-check with the Iterator Abstract Base Class from the collections module. >>> def func(): ... yield 'I am' ... yield 'a generator!' ... >>> type(func) # A function with yield is still a function <type 'function'> >>> gen = func() >>> type(gen) # but it returns a generator <type 'generator'> >>> hasattr(gen, '__iter__') # that's an iterable True >>> hasattr(gen, 'next') # and with .next (.__next__ in Python 3) True # implements the iterator protocol. The generator type is a sub-type of iterator: >>> import collections, types >>> issubclass(types.GeneratorType, collections.Iterator) True And if necessary, we can type-check like this: >>> isinstance(gen, types.GeneratorType) True >>> isinstance(gen, collections.Iterator) True A feature of an Iterator is that once exhausted, you can't reuse or reset it: >>> list(gen) ['I am', 'a generator!'] >>> list(gen) [] You'll have to make another if you want to use its functionality again (see footnote 2): >>> list(func()) ['I am', 'a generator!'] One can yield data programmatically, for example: def func(an_iterable): for item in an_iterable: yield item The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use yield from: def func(an_iterable): yield from an_iterable However, yield from also allows for delegation to subgenerators, which will be explained in the following section on cooperative delegation with sub-coroutines. Coroutines: yield forms an expression that allows data to be sent into the generator (see footnote 3) Here is an example, take note of the received variable, which will point to the data that is sent to the generator: def bank_account(deposited, interest_rate): while True: calculated_interest = interest_rate * deposited received = yield calculated_interest if received: deposited += received >>> my_account = bank_account(1000, .05) First, we must queue up the generator with the builtin function, next. It will call the appropriate next or __next__ method, depending on the version of Python you are using: >>> first_year_interest = next(my_account) >>> first_year_interest 50.0 And now we can send data into the generator. (Sending None is the same as calling next.) : >>> next_year_interest = my_account.send(first_year_interest + 1000) >>> next_year_interest 102.5 Cooperative Delegation to Sub-Coroutine with yield from Now, recall that yield from is available in Python 3. This allows us to delegate coroutines to a subcoroutine: def money_manager(expected_rate): under_management = yield # must receive deposited value while True: try: additional_investment = yield expected_rate * under_management if additional_investment: under_management += additional_investment except GeneratorExit: '''TODO: write function to send unclaimed funds to state''' finally: '''TODO: write function to mail tax info to client''' def investment_account(deposited, manager): '''very simple model of an investment account that delegates to a manager''' next(manager) # must queue up manager manager.send(deposited) while True: try: yield from manager except GeneratorExit: return manager.close() And now we can delegate functionality to a sub-generator and it can be used by a generator just as above: >>> my_manager = money_manager(.06) >>> my_account = investment_account(1000, my_manager) >>> first_year_return = next(my_account) >>> first_year_return 60.0 >>> next_year_return = my_account.send(first_year_return + 1000) >>> next_year_return 123.6 You can read more about the precise semantics of yield from in PEP 380. Other Methods: close and throw The close method raises GeneratorExit at the point the function execution was frozen. This will also be called by __del__ so you can put any cleanup code where you handle the GeneratorExit: >>> my_account.close() You can also throw an exception which can be handled in the generator or propagated back to the user: >>> import sys >>> try: ... raise ValueError ... except: ... my_manager.throw(*sys.exc_info()) ... Traceback (most recent call last): File "<stdin>", line 4, in <module> File "<stdin>", line 2, in <module> ValueError Conclusion I believe I have covered all aspects of the following question: What does the yield keyword do in Python? It turns out that yield does a lot. I'm sure I could add even more thorough examples to this. If you want more or have some constructive criticism, let me know by commenting below. Appendix: Critique of the Top/Accepted Answer** It is confused on what makes an iterable, just using a list as an example. See my references above, but in summary: an iterable has an __iter__ method returning an iterator. An iterator provides a .next (Python 2 or .__next__ (Python 3) method, which is implicitly called by for loops until it raises StopIteration, and once it does, it will continue to do so. It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an iterator, it only confuses the matter, and we still have not yet gotten to the yield part. In Controlling a generator exhaustion he calls the .next method, when instead he should use the builtin function, next. It would be an appropriate layer of indirection, because his code does not work in Python 3. Itertools? This was not relevant to what yield does at all. No discussion of the methods that yield provides along with the new functionality yield from in Python 3. The top/accepted answer is a very incomplete answer. Critique of answer suggesting yield in a generator expression or comprehension. The grammar currently allows any expression in a list comprehension. expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*) ... yield_expr: 'yield' [yield_arg] yield_arg: 'from' test | testlist Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case. The CPython core developers are discussing deprecating its allowance. Here's a relevant post from the mailing list: On 30 January 2017 at 19:05, Brett Cannon wrote: On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues wrote: I'm OK with either approach. Leaving things the way they are in Python 3 is no good, IMHO. My vote is it be a SyntaxError since you're not getting what you expect from the syntax. I'd agree that's a sensible place for us to end up, as any code relying on the current behaviour is really too clever to be maintainable. In terms of getting there, we'll likely want: SyntaxWarning or DeprecationWarning in 3.7 Py3k warning in 2.7.x SyntaxError in 3.8 Cheers, Nick. -- Nick Coghlan | ncoghlan at gmail.com | Brisbane, Australia Further, there is an outstanding issue (10544) which seems to be pointing in the direction of this never being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.) Bottom line, until the developers of CPython tell us otherwise: Don't put yield in a generator expression or comprehension. The return statement in a generator In Python 2: In a generator function, the return statement is not allowed to include an expression_list. In that context, a bare return indicates that the generator is done and will cause StopIteration to be raised. An expression_list is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with return, but you can't return a value. In Python 3: In a generator function, the return statement indicates that the generator is done and will cause StopIteration to be raised. The returned value (if any) is used as an argument to construct StopIteration and becomes the StopIteration.value attribute. Footnotes The languages CLU, Sather, and Icon were referenced in the proposal to introduce the concept of generators to Python. The general idea is that a function can maintain internal state and yield intermediate data points on demand by the user. This promised to be superior in performance to other approaches, including Python threading, which isn't even available on some systems. This means, for example, that xrange objects (range in Python 3) aren't Iterators, even though they are iterable, because they can be reused. Like lists, their __iter__ methods return iterator objects. yield was originally introduced as a statement, meaning that it could only appear at the beginning of a line in a code block. Now yield creates a yield expression. https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt This change was proposed to allow a user to send data into the generator just as one might receive it. To send data, one must be able to assign it to something, and for that, a statement just won't work. yield is just like return - it returns whatever you tell it to. The only difference is that the next time you call the function, execution starts from the last call to the yield statement. In the case of your code, the function get_child_candidates is acting like an iterator so that when you extend your list, it adds one element at a time to the new list. list.extend calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list. There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this: def fib(): last, cur = 0, 1 while True: yield cur last, cur = cur, last + cur Then I can use it in other code like this: for f in fib(): if some_condition: break coolfuncs(f); It really helps simplify some problems, and makes some things easier to work with. For those who prefer a minimal working example, meditate on this interactive Python session: >>> def f(): ... yield 1 ... yield 2 ... yield 3 ... >>> g = f() >>> for i in g: ... print i ... 1 2 3 >>> for i in g: ... print i ... >>> # Note that this time nothing was printed Yield gives you a generator. def get_odd_numbers(i): return range(1, i, 2) def yield_odd_numbers(i): for x in range(1, i, 2): yield x foo = get_odd_numbers(10) bar = yield_odd_numbers(10) foo [1, 3, 5, 7, 9] bar <generator object yield_odd_numbers at 0x1029c6f50> bar.next() 1 bar.next() 3 bar.next() 5 As you can see, in the first case foo holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called. In the second case, bar just gives you a generator. A generator is an iterable--which means you can use it in a for loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object "remembers" where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through. Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :) This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things. It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as C#'s iterator blocks if you're familiar with those. There's an IBM article which explains it reasonably well (for Python) as far as I can see. The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - as if the generator method was paused. Now obviously you can't really "pause" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself. There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the PL theory answer: The yield statement in python returns a generator. A generator in python is a function that returns continuations (and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on). Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state are saved the current values of variables and the operations that have yet to be performed, and so on. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out. Continuations, in this more general form, can be implemented in two ways. In the call/cc way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored. In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows: def save_file(filename): def write_file_continuation(): write_stuff_to_file(filename) check_if_file_exists_and_user_wants_to_overwrite( write_file_continuation ) In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger) The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read. Now let's talk about generators in python. Generators are a specific subtype of continuation. Whereas continuations are able in general to save the state of a computation (i.e., the program's call stack), generators are only able to save the state of iteration over an iterator. Although, this definition is slightly misleading for certain use cases of generators. For instance: def f(): while True: yield 4 This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., for x in collection: do_something(x)). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration. To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand this page about continuations and call/cc). But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style: Whenever yield is called, it tells the function to return a continuation. When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode but not code) the generator's next method is basically as follows: class Generator(): def __init__(self,iterable,generatorfun): self.next_continuation = lambda:generatorfun(iterable) def next(self): value, next_continuation = self.next_continuation() self.next_continuation = next_continuation return value where yield keyword is actually syntactic sugar for the real generator function, basically something like: def generatorfun(iterable): if len(iterable) == 0: raise StopIteration else: return (iterable[0], lambda:generatorfun(iterable[1:])) Remember that this is just pseudocode and the actual implementation of generators in python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the yield keyword. TL;DR Instead of building a list from scratch... def squares_list(n): the_list = [] # Replace for x in range(n): y = x * x the_list.append(y) # these return the_list # lines ...yield each piece def squares_the_yield_way(n): for x in range(n): y = x * x yield y # with this This was my first "aha" moment with yield. yield is a sugary way to say build a series of stuff Same behavior: >>> for square in squares_list(4): ... print(square) ... 0 1 4 9 >>> for square in squares_the_yield_way(4): ... print(square) ... 0 1 4 9 Different behavior: Yield is single-pass: you can only iterate through once. When a function has a yield in it we call it a generator function. And an iterator is what it returns. That's revealing. We lose the convenience of a container, but gain the power of an arbitrarily long series. Yield is lazy, it puts off computation. A function with a yield in it doesn't actually execute at all when you call it. The iterator object it returns uses magic to maintain the function's internal context. Each time you call next() on the iterator (this happens in a for-loop) execution inches forward to the next yield. (return raises StopIteration and ends the series.) Yield is versatile. It can do infinite loops: >>> def squares_all_of_them(): ... x = 0 ... while True: ... yield x * x ... x += 1 ... >>> squares = squares_all_of_them() >>> for _ in range(4): ... print(next(squares)) ... 0 1 4 9 If you need multiple passes and the series isn't too long, just call list() on it: >>> list(squares_the_yield_way(4)) [0, 1, 4, 9] Brilliant choice of the word yield because both meanings apply: yield — produce or provide (as in agriculture) ...provide the next data in the series. yield — give way or relinquish (as in political power) ...relinquish CPU execution until the iterator advances. An example in plain language. I will provide a correspondence between high-level human concepts to low-level python concepts. I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following: I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is. This step corresponds to defining the generator function, i.e. the function containing a yield. Sometime later, I tell you, "ok, get ready to tell me the sequence of numbers". This step corresponds to calling the generator function which returns a generator object. Note that you don't tell me any numbers yet, you just grab your paper and pencil. I ask you, "tell me the next number", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, what is the next number. I don't care about the details. This step corresponds to calling .next() on the generator object. … repeat previous step, until… eventually, you might come to an end. You don't tell me a number, you just shout, "hold your horses! I'm done! No more numbers!" This step corresponds to the generator object ending its job, and raising a StopIteration exception The generator function does not need to raise the exception, it's raised automatically when the function ends or issues a return. This is what a generator does (a function that contains a yield); it starts executing, pauses whenever it does a yield, and when asked for a .next() value it continues from the point it was last. It fits perfectly by design with the iterator protocol of python, which describes how to sequentially request for values. The most famous user of the iterator protocol is the for command in python. So, whenever you do a: for item in sequence: it doesn't matter if sequence is a list, a string, a dictionary or a generator object like described above; the result is the same: you read items off a sequence one by one. Note that defining a function which contains a yield keyword is not the only way to create a generator; it's just the easiest way to create one. For more accurate information, read about iterator types, the yield statement and generators in the Python documentation. While a lot of answers show why you'd use a yield to create a generator, there are more uses for yield. It's quite easy to make a coroutine, which enables the passing of information between two blocks of code. I won't repeat any of the fine examples that have already been given about using yield to create a generator. To help understand what a yield does in the following code, you can use your finger to trace the cycle through any code that has a yield. Every time your finger hits the yield, you have to wait for a next or a send to be entered. When a next is called, you trace through the code until you hit the yield… the code on the right of the yield is evaluated and returned to the caller… then you wait. When next is called again, you perform another loop through the code. However, you'll note that in a coroutine, yield can also be used with a send… which will send a value from the caller into the yielding function. If a send is given, then yield receives the value sent, and spits it out the left hand side… then the trace through the code progresses until you hit the yield again (returning the value at the end, as if next was called). For example: >>> def coroutine(): ... i = -1 ... while True: ... i += 1 ... val = (yield i) ... print("Received %s" % val) ... >>> sequence = coroutine() >>> sequence.next() 0 >>> sequence.next() Received None 1 >>> sequence.send('hello') Received hello 2 >>> sequence.close() There is another yield use and meaning (since python 3.3): yield from <expr> http://www.python.org/dev/peps/pep-0380/ A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator. The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another. moreover this will introduce (since python 3.5): async def new_coroutine(data): ... await blocking_action() to avoid coroutines confused with regular generator (today yield is used in both). I was going to post "read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators", but so many others have posted good descriptions already. Also, note that yield can be used in coroutines as the dual of their use in generator functions. Although it isn't the same use as your code snippet, (yield) can be used as an expression in a function. When a caller sends a value to the method using the send() method, then the coroutine will execute until the next (yield) statement is encountered. Generators and coroutines are a cool way to set up data-flow type applications. I thought it would be worthwhile knowing about the other use of the yield statement in functions. Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them: As a Python generator: from itertools import islice def fib_gen(): a, b = 1, 1 while True: yield a a, b = b, a + b assert [1, 1, 2, 3, 5] == list(islice(fib_gen(), 5)) Using lexical closures instead of generators def ftake(fnext, last): return [fnext() for _ in xrange(last)] def fib_gen2(): #funky scope due to python2.x workaround #for python 3.x use nonlocal def _(): _.a, _.b = _.b, _.a + _.b return _.a _.a, _.b = 0, 1 return _ assert [1,1,2,3,5] == ftake(fib_gen2(), 5) Using object closures instead of generators (because ClosuresAndObjectsAreEquivalent) class fib_gen3: def __init__(self): self.a, self.b = 1, 1 def __call__(self): r = self.a self.a, self.b = self.b, self.a + self.b return r assert [1,1,2,3,5] == ftake(fib_gen3(), 5) From a programming viewpoint, the iterators are implemented as thunks http://en.wikipedia.org/wiki/Thunk_(functional_programming) To implement iterators/generators/thread pools for concurrent execution/etc as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to "messages". http://en.wikipedia.org/wiki/Message_passing "next" is a message sent to a closure, created by "iter" call. There are lots of ways to implement this computation. I used mutation but it is easy to do it without mutation, by returning the current value and the next yielder. Here is a demonstration which uses the structure of R6RS but the semantics is absolutely identical as in python, it's the same model of computation, only a change in syntax is required to rewrite it in python. Welcome to Racket v6.5.0.3. -> (define gen (lambda (l) (define yield (lambda () (if (null? l) 'END (let ((v (car l))) (set! l (cdr l)) v)))) (lambda(m) (case m ('yield (yield)) ('init (lambda (data) (set! l data) 'OK)))))) -> (define stream (gen '(1 2 3))) -> (stream 'yield) 1 -> (stream 'yield) 2 -> (stream 'yield) 3 -> (stream 'yield) 'END -> ((stream 'init) '(a b)) 'OK -> (stream 'yield) 'a -> (stream 'yield) 'b -> (stream 'yield) 'END -> (stream 'yield) 'END -> Here is a simple example: def isPrimeNumber(n): print "isPrimeNumber({}) call".format(n) if n==1: return False for x in range(2,n): if n % x == 0: return False return True def primes (n=1): while(True): print "loop step ---------------- {}".format(n) if isPrimeNumber(n): yield n n += 1 for n in primes(): if n> 10:break print "wiriting result {}".format(n) output : loop step ---------------- 1 isPrimeNumber(1) call loop step ---------------- 2 isPrimeNumber(2) call loop step ---------------- 3 isPrimeNumber(3) call wiriting result 3 loop step ---------------- 4 isPrimeNumber(4) call loop step ---------------- 5 isPrimeNumber(5) call wiriting result 5 loop step ---------------- 6 isPrimeNumber(6) call loop step ---------------- 7 isPrimeNumber(7) call wiriting result 7 loop step ---------------- 8 isPrimeNumber(8) call loop step ---------------- 9 isPrimeNumber(9) call loop step ---------------- 10 isPrimeNumber(10) call loop step ---------------- 11 isPrimeNumber(11) call I am not a Python developer, but it looks to me yield holds the position of program flow and the next loop start from "yield" position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work. Seems to me an interesting and nice ability :D Here is a mental image of what yield does. I like to think of a thread as having a stack (even when it's not implemented that way). When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again. With a yield function, when its code begins to run (i.e. after the function is called, returning a generator object, whose next() method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the yield statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular yield statement). So it's a kind of a frozen function that the generator is hanging onto. When next() is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage. Compare the following examples: def normalFunction(): return if False: pass def yielderFunction(): return if False: yield 12 When we call the second function, it behaves very differently to the first. The yield statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with. >>> yielderFunction() <generator object yielderFunction at 0x07742D28> Calling yielderFunction() doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the yielder prefix for readability.) >>> gen = yielderFunction() >>> dir(gen) ['__class__', ... '__iter__', #Returns gen itself, to make it work uniformly with containers ... #when given to a for loop. (Containers return an iterator instead.) 'close', 'gi_code', 'gi_frame', 'gi_running', 'next', #The method that runs the function's body. 'send', 'throw'] The gi_code and gi_frame fields are where the frozen state is stored. Exploring them with dir(..), we can confirm that our mental model above is credible. Like every answer suggests, yield is used for creating a sequence generator. It's used for generating some sequence dynamically. Eg. While reading a file line by line on a network, you can use the yield function as follows: def getNextLines(): while con.isOpen(): yield con.read() You can use it in your code as follows : for line in getNextLines(): doSomeThing(line) Execution Control Transfer gotcha The execution control will be transferred from getNextLines() to the for loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time. Thus in short, a function with the following code def simpleYield(): yield "first time" yield "second time" yield "third time" yield "Now some useful value {}".format(12) for i in simpleYield(): print i will print "first time" "second time" "third time" "Now some useful value 12" I hope this helps you. Yield is an Object A return in a function will return a single value. If you want function to return huge set of values use yield. More importantly, yield is a barrier like Barrier in Cuda Language, it will not transfer control until it gets completed. i.e It will run the code in your function from the beginning until it hits yield. Then, it’ll return the first value of the loop. Then, every other call will run the loop you have written in the function one more time, returning the next value until there is no value to return. yield is like a return element for a function. The difference is, that the yield element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling list(generator()). (My below answer only speaks from the perspective of using Python generator, not the underlying implementation of generator mechanism, which involves some tricks of stack and heap manipulation.) When yield is used instead of a return in a python function, that function is turned into something special called generator function. That function will return an object of generator type. The yield keyword is a flag to notify the python compiler to treat such function specially. Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function can be thought of as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a StopIteration exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about generator but this one from the functional programming perspective is the most digestable. (Now I want to talk about the rationale behind generator, and the iterator based on my own understanding. I hope this can help you grasp the essential motivation of iterator and generator. Such concept shows up in other languages as well such as C#.) As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this intuitive approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. So instead of storing the data itself directly, why not store some kind of metadata indirectly, i.e. the logic how the data is computed. There are 2 approaches to wrap such metadata. The OO approach, we wrap the metadata as a class. This is the so-called iterator who implements the iterator protocol (i.e. the __next__(), and __iter__() methods). This is also the commonly seen iterator design pattern. The functional approach, we wrap the metadata as a function. This is the so-called generator function. But under the hood, the returned generator object still IS-A iterator because it also implements the iterator protocol. Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you. The yield keyword simply collects returning results. Think of yield like return += All great answers whereas a bit difficult for newbies. I assume you have learned return statement. As an analogy, return and yield are twins. return means 'Return and Stop' whereas 'yield` means 'Return but Continue' Try to get a num_list with return. def num_list(n): for i in range(n): return i Run it: In [5]: num_list(3) Out[5]: 0 See, you get only a single number instead of a list of them,. return never allow you happy to prevail. It implemented once and quit. There comes yield Replace return with yield In [10]: def num_list(n): ...: for i in range(n): ...: yield i ...: In [11]: num_list(3) Out[11]: <generator object num_list at 0x10327c990> In [12]: list(num_list(3)) Out[12]: [0, 1, 2] Now, you win to get all the numbers. Comparing to return which runs once and stops, yield runs times you planed. You can interpret return as return one of them, yield as return all of them. This is called iterable. One more step we can rewrite yield statement with return In [15]: def num_list(n): ...: result = [] ...: for i in range(n): ...: result.append(i) ...: return result In [16]: num_list(3) Out[16]: [0, 1, 2] It's the core about yield. The difference between a list return outputs and the object yield output is: You can get [0, 1, 2] from a list object always whereas can only retrieve them from 'the object yield output' once. So, it has a new name generator object as displayed in Out[11]: <generator object num_list at 0x10327c990>. In conclusion as a metaphor to grok it, return and yield are twins, list and generator are twins. Here's a simple yield based approach, to compute the fibonacci series, explained: def fib(limit=50): a, b = 0, 1 for i in range(limit): yield b a, b = b, a+b When you enter this into your REPL and then try and call it, you'll get a mystifying result: >>> fib() <generator object fib at 0x7fa38394e3b8> This is because the presence of yield signaled to Python that you want to create a generator, that is, an object that generates values on demand. So, how do you generate these values? This can either be done directly by using the built-in function next, or, indirectly by feeding it to a construct that consumes values. Using the built-in next() function, you directly invoke .next/__next__, forcing the generator to produce a value: >>> g = fib() >>> next(g) 1 >>> next(g) 1 >>> next(g) 2 >>> next(g) 3 >>> next(g) 5 Indirectly, if you provide fib to a for loop, a list initializer, a tuple initializer, or anything else that expects an object that generates/produces values, you'll "consume" the generator until no more values can be produced by it (and it returns): results = [] for i in fib(30): # consumes fib results.append(i) # can also be accomplished with results = list(fib(30)) # consumes fib Similarly, with a tuple initializer: >>> tuple(fib(5)) # consumes fib (1, 1, 2, 3, 5) A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to. When you first invoke fib by calling it: f = fib() Python compiles the function, encounters the yield keyword and simply returns a generator object back at you. Not very helpful it seems. When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a yield, it then yields back the value you supplied to yield and pauses. For an example that better demonstrates this, let's use some print calls (replace with print "text" if on Python 2): def yielder(value): """ This is an infinite generator. Only use next on it """ while 1: print("I'm going to generate the value for you") print("Then I'll pause for a while") yield value print("Let's go through it again.") Now, enter in the REPL: >>> gen = yielder("Hello, yield!") you have a generator object now waiting for a command for it to generate a value. Use next and see what get's printed: >>> next(gen) # runs until it finds a yield I'm going to generate the value for you Then I'll pause for a while 'Hello, yield!' The unquoted results are what's printed. The quoted result is what is returned from yield. Call next again now: >>> next(gen) # continues from yield and runs again Let's go through it again. I'm going to generate the value for you Then I'll pause for a while 'Hello, yield!' The generator remembers it was paused at yield value and resumes from there. The next message is printed and the search for the yield statement to pause at it performed again (due to the while loop). Many people use return rather than yield but in some cases yield can be more efficient and easier to work with. Here is an example which yield is definitely best for: return (in function) import random def return_dates(): dates = [] # with return you need to create a list then return it for i in range(5): date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"]) dates.append(date) return dates yield (in function) def yield_dates(): for i in range(5): date = random.choice(["1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th"]) yield date # yield makes a generator automatically which works in a similar way, this is much more efficient Calling functions dates_list = return_dates() print(dates_list) for i in dates_list: print(i) dates_generator = yield_dates() print(dates_generator) for i in dates_generator: print(i) Both functions do the same thing but yield uses 3 lines instead of 5 and has one less variable to worry about. This is the result from the code: As you can see both functions do the same thing, the only difference is return_dates() gives a list and yield_dates() gives a generator A real life example would be something like reading a file line by line or if you just want to make a generator In summary, the yield statement transforms your function into a factory that produces a special object called a generator which wraps around the body of your original function. When the generator is iterated, it executes your function until it reaches the next yield then suspends execution and evaluates to the value passed to yield. It repeats this process on each iteration until the path of execution exits the function. For instance; def simple_generator(): yield 'one' yield 'two' yield 'three' for i in simple_generator(): print i simply outputs ; one two three The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations Say you wanted to create a your own range function that produces an iterable range of numbers, you could do it like so, def myRangeNaive(i): n = 0 range = [] while n < i: range.append(n) n = n + 1 return range and use it like this; for i in myRangeNaive(10): print i but this is ineffecient because You create an array that you only use once (this wastes memory) This code actually loops over that array twice! :( Luckily Guido and his team were generous enough to develop generators so we could just do this; def myRangeSmart(i): n = 0 while n < i: yield n n = n + 1 return for i in myRangeSmart(10): print i Now upon each iteration a function on the generator called next() executes the function until it either reaches a 'yield' statement in which it stops and 'yields' the value or reaches the end of the function. In this case on the first call, next() executes up to the yield statement and yield 'n', on the next call it will execute the increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function. The yield keyword At a glance, the yield statement is used to define generators, replacing the return of a function to provide a result to its caller without destroying local variables. Unlike a function, where on each call it starts with new set of variables, a generator will resume the execution where it was left off. About Python Generators Since the yield keyword is only used with generators, it makes sense to recall the concept of generators first. The idea of generators is to calculate a series of results one-by-one on demand (on the fly). In the simplest case, a generator can be used as a list, where each element is calculated lazily. Let's compare a list and a generator that do the same thing - return powers of two: >>> # First, we define a list >>> the_list = [2**x for x in range(5)] >>> >>> # Type check: yes, it's a list >>> type(the_list) <class 'list'> >>> >>> # Iterate over items and print them >>> for element in the_list: ... print(element) ... 1 2 4 8 16 >>> >>> # How about the length? >>> len(the_list) 5 >>> >>> # Ok, now a generator. >>> # As easy as list comprehensions, but with '()' instead of '[]': >>> the_generator = (x+x for x in range(3)) >>> >>> # Type check: yes, it's a generator >>> type(the_generator) <class 'generator'> >>> >>> # Iterate over items and print them >>> for element in the_generator: ... print(element) ... 0 2 4 >>> >>> # Everything looks the same, but the length... >>> len(the_generator) Traceback (most recent call last): File "", line 1, in TypeError: object of type 'generator' has no len() Iterating over the list and the generator looks completely the same. However, although the generator is iterable, it is not a collection and thus has no length. Collections (lists, tuples, sets, etc) keep all values in memory and we can access them whenever needed. A generator calculates the values on the fly and forgets them, so it does not have any overview about the own result set. Generators are especially useful for memory-intensive tasks, where there is no need to keep all of the elements of a memory-heavy list accessible at the same time. Calculating a series of values one-by-one can also be useful in situations where the complete result is never needed, yielding intermediate results to the caller until some requirement is satisfied and further processing stops. Using the Python yield keyword A good example is a search task, where typically there is no need to wait for all results to be found. Performing a file-system search, a user would be happier to receive results on-the-fly, rather the wait for a search engine to go through every single file and only afterwards return results. Are there any people who really navigate through all Google search results until the last page? Since a search functionality cannot be created using list-comprehensions, we are going to define a generator using a function with the yield statement/keyword. The yield instruction should be put into a place where the generator returns an intermediate result to the caller and sleeps until the next invocation occurs. def search(keyword, filename): print('generator started') f = open(filename, 'r') # Looping through the file line by line for line in f: if keyword in line: # If keyword found, return it yield line f.close() So far the most practical aspects of Python generators have been described. For more detailed info and an interesting discussion take a look at the Python Enhancement Proposal 255, which discusses the feature of the language in detail. Happy Pythoning! For more info go to http://pythoncentral.io/python-generators-and-yield-keyword/ To understand what yield does, you must understand what generators are. And before generators come iterables. Iterables When you create a list, you can read its items one by one. Reading its items one by one is called iteration: >>> mylist = [1, 2, 3] >>> for i in mylist: ... print(i) 1 2 3 mylist is an iterable. When you use a list comprehension, you create a list, and so an iterable: >>> mylist = [x*x for x in range(3)] >>> for i in mylist: ... print(i) 0 1 4 Everything you can use "for... in..." on is an iterable; lists, strings, files... These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values. Generators Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly: >>> mygenerator = (x*x for x in range(3)) >>> for i in mygenerator: ... print(i) 0 1 4 It is just the same except you used () instead of []. BUT, you cannot perform for i in mygenerator a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one. Yield yield is a keyword that is used like return, except the function will return a generator. >>> def createGenerator(): ... mylist = range(3) ... for i in mylist: ... yield i*i ... >>> mygenerator = createGenerator() # create a generator >>> print(mygenerator) # mygenerator is an object! <generator object createGenerator at 0xb7555c34> >>> for i in mygenerator: ... print(i) 0 1 4 Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once. To master yield, you must understand that when you call the function, the code you have written in the function body does not run. The function only returns the generator object, this is a bit tricky :-) Then, your code will be run each time the for uses the generator. Now the hard part: The first time the for calls the generator object created from your function, it will run the code in your function from the beginning until it hits yield, then it'll return the first value of the loop. Then, each other call will run the loop you have written in the function one more time, and return the next value, until there is no value to return. The generator is considered empty once the function runs but does not hit yield anymore. It can be because the loop had come to an end, or because you do not satisfy an "if/else" anymore. Your code explained Generator: # Here you create the method of the node object that will return the generator def _get_child_candidates(self, distance, min_dist, max_dist): # Here is the code that will be called each time you use the generator object: # If there is still a child of the node object on its left # AND if distance is ok, return the next child if self._leftchild and distance - max_dist < self._median: yield self._leftchild # If there is still a child of the node object on its right # AND if distance is ok, return the next child if self._rightchild and distance + max_dist >= self._median: yield self._rightchild # If the function arrives here, the generator will be considered empty # there is no more than two values: the left and the right children Caller: # Create an empty list and a list with the current object reference result, candidates = list(), [self] # Loop on candidates (they contain only one element at the beginning) while candidates: # Get the last candidate and remove it from the list node = candidates.pop() # Get the distance between obj and the candidate distance = node._get_dist(obj) # If distance is ok, then you can fill the result if distance <= max_dist and distance >= min_dist: result.extend(node._values) # Add the children of the candidate in the candidates list # so the loop will keep running until it will have looked # at all the children of the children of the children, etc. of the candidate candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) return result This code contains several smart parts: The loop iterates on a list but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) exhausts all the values of the generator, but while keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node. The extend() method is a list object method that expects an iterable and adds its values to the list. Usually we pass a list to it: >>> a = [1, 2] >>> b = [3, 4] >>> a.extend(b) >>> print(a) [1, 2, 3, 4] But in your code it gets a generator, which is good because: You don't need to read the values twice. You may have a lot of children and you don't want them all stored in memory. And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples and generators! This is called duck typing and is one of the reason why Python is so cool. But this is another story, for another question... You can stop here, or read a little bit to see an advanced use of a generator: Controlling a generator exhaustion >>> class Bank(): # let's create a bank, building ATMs ... crisis = False ... def create_atm(self): ... while not self.crisis: ... yield "$100" >>> hsbc = Bank() # when everything's ok the ATM gives you as much as you want >>> corner_street_atm = hsbc.create_atm() >>> print(corner_street_atm.next()) $100 >>> print(corner_street_atm.next()) $100 >>> print([corner_street_atm.next() for cash in range(5)]) ['$100', '$100', '$100', '$100', '$100'] >>> hsbc.crisis = True # crisis is coming, no more money! >>> print(corner_street_atm.next()) <type 'exceptions.StopIteration'> >>> wall_street_atm = hsbc.create_atm() # it's even true for new ATMs >>> print(wall_street_atm.next()) <type 'exceptions.StopIteration'> >>> hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty >>> print(corner_street_atm.next()) <type 'exceptions.StopIteration'> >>> brand_new_atm = hsbc.create_atm() # build a new one to get back in business >>> for cash in brand_new_atm: ... print cash $100 $100 $100 $100 $100 $100 $100 $100 $100 ... Note: For Python3 useprint(corner_street_atm.__next__()) or print(next(corner_street_atm)) It can be useful for various things like controlling access to a resource. Itertools, your best friend The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator? Chain two generators? Group values in a nested list with a one liner? Map / Zip without creating another list? Then just import itertools. An example? Let's see the possible orders of arrival for a 4 horse race: >>> horses = [1, 2, 3, 4] >>> races = itertools.permutations(horses) >>> print(races) <itertools.permutations object at 0xb754f1dc> >>> print(list(itertools.permutations(horses))) [(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)] Understanding the inner mechanisms of iteration Iteration is a process implying iterables (implementing the __iter__() method) and iterators (implementing the __next__() method). Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables. More about it in this article about how for loops work.
https://stackoverflow.com/questions/503093/how-do-i-redirect-to-another-webpage	javascript - How do I redirect to another webpage? - Stack Overflow	[votes:7743][favorites:1952]	How do I redirect to another webpage? How can I redirect the user from one page to another using jQuery or pure JavaScript? javascript jquery redirect WARNING: This answer has merely been provided as a possible solution; it is obviously not the best solution, as it requires jQuery. Instead, prefer the pure JavaScript solution. $(location).attr('href', 'http://stackoverflow.com') Standard "vanilla" JavaScript way to redirect a page: window.location.href = 'newPage.html'; If you are here because you are losing HTTP_REFERER when redirecting, keep reading: The following section is for those using HTTP_REFERER as one of many secure measures (although it isn't a great protective measure). If you're using InternetExplorer8 or lower, these variables get lost when using any form of JavaScript page redirection (location.href, etc.). Below we are going to implement an alternative for IE8 & lower so that we don't lose HTTP_REFERER. Otherwise you can almost always simply use window.location.href. Testing against HTTP_REFERER (URL pasting, session, etc.) can be helpful in telling whether a request is legitimate. (Note: there are also ways to work-around / spoof these referrers, as noted by droop's link in the comments) Simple cross-browser testing solution (fallback to window.location.href for InternetExplorer9+ and all other browsers) Usage: redirect('anotherpage.aspx'); function redirect (url) { var ua = navigator.userAgent.toLowerCase(), isIE = ua.indexOf('msie') !== -1, version = parseInt(ua.substr(4, 2), 10); // Internet Explorer 8 and lower if (isIE && version < 9) { var link = document.createElement('a'); link.href = url; document.body.appendChild(link); link.click(); } // All other browsers can use the standard window.location.href (they don't lose HTTP_REFERER like Internet Explorer 8 & lower does) else { window.location.href = url; } } Use: // window.location window.location.replace('http://www.example.com') window.location.assign('http://www.example.com') window.location.href = 'http://www.example.com' document.location.href = '/path' // window.history window.history.back() window.history.go(-1) // window.navigate; ONLY for old versions of Internet Explorer window.navigate('top.jsp') // Probably no bueno self.location = 'http://www.example.com'; top.location = 'http://www.example.com'; // jQuery $(location).attr('href','http://www.example.com') $(window).attr('location','http://www.example.com') $(location).prop('href', 'http://www.example.com') This works for every browser: window.location.href = 'your_url'; It would help if you were a little more descriptive in what you are trying to do. If you are trying to generate paged data, there are some options in how you do this. You can generate separate links for each page that you want to be able to get directly to. <a href='/path-to-page?page=1' class='pager-link'>1</a> <a href='/path-to-page?page=2' class='pager-link'>2</a> <span class='pager-link current-page'>3</a> ... Note that the current page in the example is handled differently in the code and with CSS. If you want the paged data to be changed via AJAX, this is where jQuery would come in. What you would do is add a click handler to each of the anchor tags corresponding to a different page. This click handler would invoke some jQuery code that goes and fetches the next page via AJAX and updates the table with the new data. The example below assumes that you have a web service that returns the new page data. $(document).ready( function() { $('a.pager-link').click( function() { var page = $(this).attr('href').split(/\?/)[1]; $.ajax({ type: 'POST', url: '/path-to-service', data: page, success: function(content) { $('#myTable').html(content); // replace } }); return false; // to stop link }); }); I also think that location.replace(URL) is the best way, but if you want to notify the search engines about your redirection (they don't analyze JavaScript code to see the redirection) you should add the rel="canonical" meta tag to your website. Adding a noscript section with a HTML refresh meta tag in it, is also a good solution. I suggest you to use this JavaScript redirection tool to create redirections. It also has InternetExplorer support to pass the HTTP referrer. Sample code without delay looks like this: <!-- Place this snippet right after opening the head tag to make it work properly --> <!-- This code is licensed under GNU GPL v3 --> <!-- You are allowed to freely copy, distribute and use this code, but removing author credit is strictly prohibited --> <!-- Generated by http://insider.zone/tools/client-side-url-redirect-generator/ --> <!-- REDIRECTING STARTS --> <link rel="canonical" href="https://yourdomain.com/"/> <noscript> <meta http-equiv="refresh" content="0;URL=https://yourdomain.com/"> </noscript> <!--[if lt IE 9]><script type="text/javascript">var IE_fix=true;</script><![endif]--> <script type="text/javascript"> var url = "https://yourdomain.com/"; if(typeof IE_fix != "undefined") // IE8 and lower fix to pass the http referer { document.write("redirecting..."); // Don't remove this line or appendChild() will fail because it is called before document.onload to make the redirect as fast as possible. Nobody will see this text, it is only a tech fix. var referLink = document.createElement("a"); referLink.href = url; document.body.appendChild(referLink); referLink.click(); } else { window.location.replace(url); } // All other browsers </script> <!-- Credit goes to http://insider.zone/ --> <!-- REDIRECTING ENDS --> But if someone wants to redirect back to home page then he may use the following snippet. window.location = window.location.host It would be helpful if you have three different environments as development, staging, and production. You can explore this window or window.location object by just putting these words in Chrome Console or Firebug's Console. JavaScript provides you many methods to retrieve and change the current URL which is displayed in browser's address bar. All these methods uses the Location object, which is a property of the Window object. You can create a new Location object that has the current URL as follows.. var currentLocation = window.location; Basic Structure of a URL <protocol>//<hostname>:<port>/<pathname><search><hash> Protocol -- Specifies the protocol name be used to access the resource on the Internet. (HTTP (without SSL) or HTTPS (with SSL)) hostname -- Host name specifies the host that owns the resource. For example, www.stackoverflow.com. A server provides services using the name of the host. port -- A port number used to recognize a specific process to which an Internet or other network message is to be forwarded when it arrives at a server. pathname -- The path gives info about the specific resource within the host that the Web client wants to access. For example, stackoverflow.com/index.html. query -- A query string follows the path component, and provides a string of information that the resource can utilize for some purpose (for example, as parameters for a search or as data to be processed). hash -- The anchor portion of a URL, includes the hash sign (#). With these Location object properties you can access all of these URL components hash -Sets or returns the anchor portion of a URL. host -Sets or returns the hostname and port of a URL. hostname -Sets or returns the hostname of a URL. href -Sets or returns the entire URL. pathname -Sets or returns the path name of a URL. port -Sets or returns the port number the server uses for a URL. protocol -Sets or returns the protocol of a URL. search -Sets or returns the query portion of a URL Now If you want to change a page or redirect the user to some other page you can use the href property of the Location object like this You can use the href property of the Location object. window.location.href = "http://www.stackoverflow.com"; Location Object also have these three methods assign() -- Loads a new document. reload() -- Reloads the current document. replace() -- Replaces the current document with a new one You can use assign() and replace methods also to redirect to other pages like these location.assign("http://www.stackoverflow.com"); location.replace("http://www.stackoverflow.com"); How assign() and replace() differs -- The difference between replace() method and assign() method(), is that replace() removes the URL of the current document from the document history, means it is not possible to use the "back" button to navigate back to the original document. So Use the assign() method if you want to load a new document, andwant to give the option to navigate back to the original document. You can change the location object href property using jQuery also like this $(location).attr('href',url); And hence you can redirect the user to some other url. Should just be able to set using window.location. Example: window.location = "https://stackoverflow.com/"; Here is a past post on the subject: How do I redirect to another webpage? Before I start, jQuery is a JavaScript library used for DOM manipulation. So you should not be using jQuery for a page redirect. A quote from Jquery.com: While jQuery might run without major issues in older browser versions, we do not actively test jQuery in them and generally do not fix bugs that may appear in them. It was found here: https://jquery.com/browser-support/ So jQuery is not an end-all and be-all solution for backwards compatibility. The following solution using raw JavaScript works in all browsers and have been standard for a long time so you don't need any libraries for cross browser support. This page will redirect to Google after 3000 milliseconds <!DOCTYPE html> <html> <head> <title>example</title> </head> <body> <p>You will be redirected to google shortly.</p> <script> setTimeout(function(){ window.location.href="http://www.google.com"; // The URL that will be redirected too. }, 3000); // The bigger the number the longer the delay. </script> </body> </html> Different options are as follows: window.location.href="url"; // Simulates normal navigation to a new page window.location.replace("url"); // Removes current URL from history and replaces it with a new URL window.location.assign("url"); // Adds new URL to the history stack and redirects to the new URL window.history.back(); // Simulates a back button click window.history.go(-1); // Simulates a back button click window.history.back(-1); // Simulates a back button click window.navigate("page.html"); // Same as window.location="url" When using replace, the back button will not go back to the redirect page, as if it was never in the history. If you want the user to be able to go back to the redirect page then use window.location.href or window.location.assign. If you do use an option that lets the user go back to the redirect page, remember that when you enter the redirect page it will redirect you back. So put that into consideration when picking an option for your redirect. Under conditions where the page is only redirecting when an action is done by the user then having the page in the back button history will be okay. But if the page auto redirects then you should use replace so that the user can use the back button without getting forced back to the page the redirect sends. You can also use meta data to run a page redirect as followed. META Refresh <meta http-equiv="refresh" content="0;url=http://evil.com/" /> META Location <meta http-equiv="location" content="URL=http://evil.com" /> BASE Hijacking <base href="http://evil.com/" /> Many more methods to redirect your unsuspecting client to a page they may not wish to go can be found on this page (not one of them is reliant on jQuery): https://code.google.com/p/html5security/wiki/RedirectionMethods I would also like to point out, people don't like to be randomly redirected. Only redirect people when absolutely needed. If you start redirecting people randomly they will never go to your site again. The next part is hypothetical: You also may get reported as a malicious site. If that happens then when people click on a link to your site the users browser may warn them that your site is malicious. What may also happen is search engines may start dropping your rating if people are reporting a bad experience on your site. Please review Google Webmaster Guidelines about redirects: https://support.google.com/webmasters/answer/2721217?hl=en&ref_topic=6001971 Here is a fun little page that kicks you out of the page. <!DOCTYPE html> <html> <head> <title>Go Away</title> </head> <body> <h1>Go Away</h1> <script> setTimeout(function(){ window.history.back(); }, 3000); </script> </body> </html> If you combine the two page examples together you would have an infant loop of rerouting that will guarantee that your user will never want to use your site ever again. var url = 'asdf.html'; window.location.href = url; You can do that without jQuery as: window.location = "http://yourdomain.com"; And if you want only jQuery then you can do it like: $jq(window).attr("location","http://yourdomain.com"); This works with jQuery: $(window).attr("location", "http://google.fr"); Basically jQuery is just a JavaScript framework and for doing some of the things like redirection for example, you can just use pure JavaScript, so in that case you have 3 options using vanilla JavaScript: 1) Using location replace, this will replace the current history of the page, means that it is not possible to use the back button to go back to the original page. window.location.replace("http://stackoverflow.com"); 2) Using location assign, this will keep the history for you and with using back button, you can go back to the original page: window.location.assign("http://stackoverflow.com"); 3) I recommend using one of those previous ways, but this could be the third option using pure JavaScript: window.location.href="http://stackoverflow.com"; You can also write a function in jQuery to handle it, but not recommended as it's only one line pure JavaScript function, also you can use all of above functions without window if you are already in the window scope, for example window.location.replace("http://stackoverflow.com"); could be location.replace("http://stackoverflow.com"); Also I show them all on the image below: # HTML Page Redirect Using jQuery/JavaScript Try this example code: function YourJavaScriptFunction() { var i = $('#login').val(); if (i == 'login') window.location = "login.php"; else window.location = "Logout.php"; } If you want to give a complete URL as window.location = "www.google.co.in";. So, the question is how to make a redirect page, and not how to redirect to a website? You only need to use JavaScript for this. Here is some tiny code that will create a dynamic redirect page. <script> var url = window.location.search.split('url=')[1]; // Get the URL after ?url= if( url ) window.location.replace(url); </script> So say you just put this snippet into a redirect/index.html file on your website you can use it like so. http://www.mywebsite.com/redirect?url=http://stackoverflow.com And if you go to that link it will automatically redirect you to stackoverflow.com. Link to Documentation And that's how you make a Simple redirect page with JavaScript Edit: There is also one thing to note. I have added window.location.replace in my code because I think it suits a redirect page, but, you must know that when using window.location.replace and you get redirected, when you press the back button in your browser it will not got back to the redirect page, and it will go back to the page before it, take a look at this little demo thing. Example: The process: store home => redirect page to google => google When at google: google => back button in browser => store home So, if this suits your needs then everything should be fine. If you want to include the redirect page in the browser history replace this if( url ) window.location.replace(url); with if( url ) window.location.href = url; On your click function, just add: window.location.href = "The URL where you want to redirect"; $('#id').click(function(){ window.location.href = "http://www.google.com"; }); Try this: location.assign("http://www.google.com"); Code snippet of example. You need to put this line in your code: $(location).attr("href","http://stackoverflow.com"); If you don't have jQuery, go JavaScript with: window.location.replace("http://stackoverflow.com"); jQuery is not needed. You can do this: window.open("URL","_self","","") It is that easy! The best way to initiate an HTTP request is with document.loacation.href.replace('URL'). First write properly. You want to navigate within an application for another link from your application for another link. Here is the code: window.location.href = "http://www.google.com"; And if you want to navigate pages within your application then I also have code, if you want. You can redirect in jQuery like this: $(location).attr('href', 'http://yourPage.com/'); To just redirect to a page: window.location.href = "/destination.html"; Or if you need a delay: setTimeout(function () { window.location.href = "/destination.html"; }, 2000); // Time in milliseconds jQuery allows you to select elements from a web page with ease. You can find anything you want in a page and then use jQuery to add special effects, react to user actions, or show and hide content inside or outside the element you have selected. All these tasks start with knowing how to select an element. function redirect () { $('selection').animate({ marginLeft: 100px; //Put some CSS animation here }, 500, function () { // OK, finished jQuery staff, let's go redirect window.location.href = "/destination.html"; }) Imagine someone wrote a script/plugin that is 10000 lines of code?! Well, with jQuery you can connect to this code with just a line or two. In JavaScript and jQuery we can use the following code to redirect the one page to another page: window.location.href="http://google.com"; window.location.replace("page1.html"); ECMAScript 6 + jQuery, 85 bytes $({jQueryCode:(url)=>location.replace(url)}).attr("jQueryCode")("http://example.com") Please don't kill me, this is a joke. It's a joke. This is a joke. This did "provide an answer to the question", in the sense that it asked for a solution "using jQuery" which in this case entails forcing it into the equation somehow. Ferrybig apparently needs the joke explained (still joking, I'm sure there are limited options on the review form), so without further ado: Other answers are using jQuery's attr() on the location or window objects unnecessarily. This answer also abuses it, but in a more ridiculous way. Instead of using it to set the location, this uses attr() to retrieve a function that sets the location. The function is named jQueryCode even though there's nothing jQuery about it, and calling a function somethingCode is just horrible, especially when the something is not even a language. The "85 bytes" is a reference to Code Golf. Golfing is obviously not something you should do outside of code golf, and furthermore this answer is clearly not actually golfed. Basically, cringe. Javascript: window.location.href='www.your_url.com'; window.top.location.href='www.your_url.com'; window.location.replace('www.your_url.com'); Jquery: var url='www.your_url.com'; $(location).attr('href',url); $(location).prop('href',url);//instead of location you can use window Here is a time-delay redirection. You can set the delay time to whatever you want: <!doctype html> <html lang="en"> <head> <meta charset="UTF-8"> <title>Your Document Title</title> <script type="text/javascript"> function delayer(delay) { onLoad = setTimeout('window.location.href = "http://www.google.com/"', delay); } </script> </head> <body> <script> delayer(8000) </script> <div>You will be redirected in 8 seconds!</div> </body> </html> I just had to update this ridiculousness with yet another newer jQuery method: var url = 'http://www.fiftywaystoleaveyourlocation.com'; $(location).prop('href', url); There are three main ways to do this, window.location.href='blaah.com'; window.location.assign('blaah.com'); and... window.location.replace('blaah.com'); The last one is best, for a traditional redirect, because it will not save the page you went to before being redirected in your search history. However, if you just want to open a tab with JavaScript, you can use any of the above.1 EDIT: The window prefix is optional. One does not simply redirect using jQuery jQuery is not necessary, and window.location.replace(...) will best simulate an HTTP redirect. window.location.replace(...) is better than using window.location.href, because replace() does not keep the originating page in the session history, meaning the user won't get stuck in a never-ending back-button fiasco. If you want to simulate someone clicking on a link, use location.href If you want to simulate an HTTP redirect, use location.replace For example: // similar behavior as an HTTP redirect window.location.replace("http://stackoverflow.com"); // similar behavior as clicking on a link window.location.href = "http://stackoverflow.com";
https://stackoverflow.com/questions/111102/how-do-javascript-closures-work	function - How do JavaScript closures work? - Stack Overflow	[votes:7655][favorites:5046]	How do JavaScript closures work? How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves? I have seen the Scheme example given on Wikipedia, but unfortunately it did not help. javascript function variables scope closures Whenever you see the function keyword within another function, the inner function has access to variables in the outer function. function foo(x) { var tmp = 3; function bar(y) { console.log(x + y + (++tmp)); // will log 16 } bar(10); } foo(2); This will always log 16, because bar can access the x which was defined as an argument to foo, and it can also access tmp from foo. That is a closure. A function doesn't have to return in order to be called a closure. Simply accessing variables outside of your immediate lexical scope creates a closure. function foo(x) { var tmp = 3; return function (y) { console.log(x + y + (++tmp)); // will also log 16 } } var bar = foo(2); // bar is now a closure. bar(10); The above function will also log 16, because bar can still refer to x and tmp, even though it is no longer directly inside the scope. However, since tmp is still hanging around inside bar's closure, it is also being incremented. It will be incremented each time you call bar. The simplest example of a closure is this: var a = 10; function test() { console.log(a); // will output 10 console.log(b); // will output 6 } var b = 6; test(); When a JavaScript function is invoked, a new execution context is created. Together with the function arguments and the parent object, this execution context also receives all the variables declared outside of it (in the above example, both 'a' and 'b'). It is possible to create more than one closure function, either by returning a list of them or by setting them to global variables. All of these will refer to the same x and the same tmp, they don't make their own copies. Here the number x is a literal number. As with other literals in JavaScript, when foo is called, the number x is copied into foo as its argument x. On the other hand, JavaScript always uses references when dealing with objects. If say, you called foo with an object, the closure it returns will reference that original object! function foo(x) { var tmp = 3; return function (y) { console.log(x + y + tmp); x.memb = x.memb ? x.memb + 1 : 1; console.log(x.memb); } } var age = new Number(2); var bar = foo(age); // bar is now a closure referencing age. bar(10); As expected, each call to bar(10) will increment x.memb. What might not be expected, is that x is simply referring to the same object as the age variable! After a couple of calls to bar, age.memb will be 2! This referencing is the basis for memory leaks with HTML objects. FOREWORD: this answer was written when the question was: Like the old Albert said : "If you can't explain it to a six-year old, you really don't understand it yourself.”. Well I tried to explain JS closures to a 27 years old friend and completely failed. Can anybody consider that I am 6 and strangely interested in that subject ? I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly & out of place. Hopefully the general idea of the story remains fun for some. I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story. Once upon a time: There was a princess... function princess() { She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things. var adventures = []; function princeCharming() { /* ... */ } var unicorn = { /* ... */ }, dragons = [ /* ... */ ], squirrel = "Hello!"; /* ... */ But she would always have to return back to her dull world of chores and grown-ups. return { And she would often tell them of her latest amazing adventure as a princess. story: function() { return adventures[adventures.length - 1]; } }; } But all they would see is a little girl... var littleGirl = princess(); ...telling stories about magic and fantasy. littleGirl.story(); And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination. But we know the real truth; that the little girl with the princess inside... ...is really a princess with a little girl inside. Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical. On Childhood Development: 5 to 7 Years it says: Your child will be able to follow two-step directions. For example, if you say to your child, "Go to the kitchen and get me a trash bag" they will be able to remember that direction. We can use this example to explain closures, as follows: The kitchen is a closure that has a local variable, called trashBags. There is a function inside the kitchen called getTrashBag that gets one trash bag and returns it. We can code this in JavaScript like this: function makeKitchen () { var trashBags = ['A', 'B', 'C']; // only 3 at first return { getTrashBag: function() { return trashBags.pop(); } }; } var kitchen = makeKitchen(); kitchen.getTrashBag(); // returns trash bag C kitchen.getTrashBag(); // returns trash bag B kitchen.getTrashBag(); // returns trash bag A Further points that explain why closures are interesting: Each time makeKitchen() is called, a new closure is created with its own separate trashBags. The trashBags variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the getTrashBag property does have access to it. Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure. Returning the object with the getTrashBag function does that here. The Straw Man I need to know how many times a button has been clicked and do something on every third click... Fairly Obvious Solution // Declare counter outside event handler's scope var counter = 0; var element = document.getElementById('button'); element.addEventListener("click", function() { // Increment outside counter counter++; if (counter === 3) { // Do something every third time console.log("Third time's the charm!"); // Reset counter counter = 0; } }); <button id="button">Click Me!</button> Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to enclose this functionality inside the event handler. Consider this option var element = document.getElementById('button'); element.addEventListener("click", (function() { // init the count to 0 var count = 0; return function(e) { // <- This function becomes the click handler count++; // and will retain access to the above `count` if (count === 3) { // Do something every third time console.log("Third time's the charm!"); //Reset counter count = 0; } }; })()); <button id="button">Click Me!</button> Notice a few things here. In the above example, I am using the closure behavior of JavaScript. This behavior allows any function to have access to the scope in which it was created, indefinitely. To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down... A simple one-line closure // _______________________Immediately invoked______________________ // | | // | Scope retained for use ___Returned as the____ | // | only by returned function | value of func | | // | | | | | | // v v v v v v var func = (function() { var a = 'val'; return function() { alert(a); }; })(); All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object... func(); // Alerts "val" func.a; // Undefined Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click. Also, this private variable state is fully accessible, for both readings and assigning to its private scoped variables. There you go; you're now fully encapsulating this behavior. Full Blog Post (including jQuery considerations) Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that I learned what they do) is to imagine the situation without them: var bind = function(x) { return function(y) { return x + y; }; } var plus5 = bind(5); console.log(plus5(3)); What would happen here if JavaScript didn't know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get: console.log(x + 3); Now, where's the definition of x? We didn't define it in the current scope. The only solution is to let plus5 carry its scope (or rather, its parent's scope) around. This way, x is well-defined and it is bound to the value 5. This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers. A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created as soon as the enclosing function is called since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns. A closure does not reference a copy of the old values of variables in its scope. The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called. The "variables" in a closure include any named functions declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope. Closures use memory, but they don't cause memory leaks since JavaScript by itself cleans up its own circular structures that are not referenced. InternetExplorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures. OK, 6-year-old closures fan. Do you want to hear the simplest example of closure? Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the more detailed explanation or at the example below. Here is how I can convert my plane story into the code. var plane = function (defaultAirport) { var lastAirportLeft = defaultAirport; var car = { driver: { startAccessPlaneInfo: function () { setInterval(function () { console.log("Last airport was " + lastAirportLeft); }, 2000); } } }; car.driver.startAccessPlaneInfo(); return { leaveTheAirport: function (airPortName) { lastAirportLeft = airPortName; } } }("Boryspil International Airport"); plane.leaveTheAirport("John F. Kennedy"); A closure is much like an object. It gets instantiated whenever you call a function. The scope of a closure in JavaScript is lexical, which means that everything that is contained within the function the closure belongs to, has access to any variable that is in it. A variable is contained in the closure if you assign it with var foo=1; or just write var foo; If an inner function (a function contained inside another function) accesses such a variable without defining it in its own scope with var, it modifies the content of the variable in the outer closure. A closure outlives the runtime of the function that spawned it. If other functions make it out of the closure/scope in which they are defined (for instance as return values), those will continue to reference that closure. Example function example(closure) { // define somevariable to live in the closure of example var somevariable = 'unchanged'; return { change_to: function(value) { somevariable = value; }, log: function(value) { console.log('somevariable of closure %s is: %s', closure, somevariable); } } } closure_one = example('one'); closure_two = example('two'); closure_one.log(); closure_two.log(); closure_one.change_to('some new value'); closure_one.log(); closure_two.log(); Output somevariable of closure one is: unchanged somevariable of closure two is: unchanged somevariable of closure one is: some new value somevariable of closure two is: unchanged I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of why you'd want one. Closures are a way to let a function have persistent, private variables - that is, variables that only one function knows about, where it can keep track of info from previous times that it was run. In that sense, they let a function act a bit like an object with private attributes. Full post: So what are these closure thingys? Closures are simple: The following simple example covers all the main points of JavaScript closures.* Here is a factory that produces calculators that can add and multiply: function make_calculator() { var n = 0; // this calculator stores a single number n return { add: function(a) { n += a; return n; }, multiply: function(a) { n *= a; return n; } }; } first_calculator = make_calculator(); second_calculator = make_calculator(); first_calculator.add(3); // returns 3 second_calculator.add(400); // returns 400 first_calculator.multiply(11); // returns 33 second_calculator.multiply(10); // returns 4000 The key point: Each call to make_calculator creates a new local variable n, which continues to be usable by that calculator's add and multiply functions long after make_calculator returns. If you are familiar with stack frames, these calculators seem strange: How can they keep accessing n after make_calculator returns? The answer is to imagine that JavaScript doesn't use "stack frames", but instead uses "heap frames", which can persist after the function call that made them returns. Inner functions like add and multiply, which access variables declared in an outer function**, are called closures. That is pretty much all there is to closures. * For example, it covers all the points in the "Closures for Dummies" article given in another answer, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in the accepted answer, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in this answer but a bit shorter and less abstract. It does not cover the point of this answer or this comment, which is that JavaScript makes it difficult to plug the current value of a loop variable into your inner function: The "plugging in" step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the "plugging in" way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. ** Any outer function, if several are nested, or even in the global context, as this answer points out clearly. How I'd explain it to a six-year-old: You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child "Where's your home?", he/she can answer "that house!", and point to the house of its parents. A "Closure" is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house. Can you explain closures to a 5-year-old?* I still think Google's explanation works very well and is concise: /* * When a function is defined in another function and it * has access to the outer function's context even after * the outer function returns. * * An important concept to learn in JavaScript. */ function outerFunction(someNum) { var someString = 'Hey!'; var content = document.getElementById('content'); function innerFunction() { content.innerHTML = someNum + ': ' + someString; content = null; // Internet Explorer memory leak for DOM reference } innerFunction(); } outerFunction(1);​ *A C# question I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together a jsFiddle that does a comparison and tries to boil down the differences to the simplest explanations I could come up with. Closures done right: console.log('CLOSURES DONE RIGHT'); var arr = []; function createClosure(n) { return function () { return 'n = ' + n; } } for (var index = 0; index < 10; index++) { arr[index] = createClosure(index); } for (var index in arr) { console.log(arr[index]()); } In the above code createClosure(n) is invoked in every iteration of the loop. Note that I named the variable n to highlight that it is a new variable created in a new function scope and is not the same variable as index which is bound to the outer scope. This creates a new scope and n is bound to that scope; this means we have 10 separate scopes, one for each iteration. createClosure(n) returns a function that returns the n within that scope. Within each scope n is bound to whatever value it had when createClosure(n) was invoked so the nested function that gets returned will always return the value of n that it had when createClosure(n) was invoked. Closures done wrong: console.log('CLOSURES DONE WRONG'); function createClosureArray() { var badArr = []; for (var index = 0; index < 10; index++) { badArr[index] = function () { return 'n = ' + index; }; } return badArr; } var badArr = createClosureArray(); for (var index in badArr) { console.log(badArr[index]()); } In the above code the loop was moved within the createClosureArray() function and the function now just returns the completed array, which at first glance seems more intuitive. What might not be obvious is that since createClosureArray() is only invoked once only one scope is created for this function instead of one for every iteration of the loop. Within this function a variable named index is defined. The loop runs and adds functions to the array that return index. Note that index is defined within the createClosureArray function which only ever gets invoked one time. Because there was only one scope within the createClosureArray() function, index is only bound to a value within that scope. In other words, each time the loop changes the value of index, it changes it for everything that references it within that scope. All of the functions added to the array return the SAME index variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope. After the loop finished and index was done being modified the end value was 10, therefore every function added to the array returns the value of the single index variable which is now set to 10. Result CLOSURES DONE RIGHT n = 0 n = 1 n = 2 n = 3 n = 4 n = 5 n = 6 n = 7 n = 8 n = 9 CLOSURES DONE WRONG n = 10 n = 10 n = 10 n = 10 n = 10 n = 10 n = 10 n = 10 n = 10 n = 10 Wikipedia on closures: In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function. Technically, in JavaScript, every function is a closure. It always has an access to variables defined in the surrounding scope. Since scope-defining construction in JavaScript is a function, not a code block like in many other languages, what we usually mean by closure in JavaScript is a function working with nonlocal variables defined in already executed surrounding function. Closures are often used for creating functions with some hidden private data (but it's not always the case). var db = (function() { // Create a hidden object, which will hold the data // it's inaccessible from the outside. var data = {}; // Make a function, which will provide some access to the data. return function(key, val) { if (val === undefined) { return data[key] } // Get else { return data[key] = val } // Set } // We are calling the anonymous surrounding function, // returning the above inner function, which is a closure. })(); db('x') // -> undefined db('x', 1) // Set x to 1 db('x') // -> 1 // It's impossible to access the data object itself. // We are able to get or set individual it. ems The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. mkdb) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data. I put together an interactive JavaScript tutorial to explain how closures work. What's a Closure? Here's one of the examples: var create = function (x) { var f = function () { return x; // We can refer to x here! }; return f; }; // 'create' takes one argument, creates a function var g = create(42); // g is a function that takes no arguments now var y = g(); // y is 42 here The children will always remember the secrets they have shared with their parents, even after their parents are gone. This is what closures are for functions. The secrets for JavaScript functions are the private variables var parent = function() { var name = "Mary"; // secret } Every time you call it, local variable "name" is created and given name "Mary". And every time the function exits the variable is lost and the name is forgotten. As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called Chamber of Secrets or stack or local scope but it doesn't really matter. We know they are there, somewhere, hidden in the memory. But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live. var parent = function() { var name = "Mary"; var child = function(childName) { // I can also see that "name" is "Mary" } } So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place. But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them. So to live, the child has to leave before it's too late var parent = function() { var name = "Mary"; var child = function(childName) { return "My name is " + childName +", child of " + name; } return child; // child leaves the parent -> } var child = parent(); // < - and here it is outside And now, even though Mary is "no longer running", the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together. So, if you call the child "Alice", she will respond child("Alice") => "My name is Alice, child of Mary" That's all there is to tell. I do not understand why the answers are so complex here. Here is a closure: var a = 42; function b() { return a; } Yes. You probably use that many times a day. There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope from the perspective of where the function was declared (not run). Now what it allows you to do can be more spectacular, see other answers. Example for the first point by dlaliberte: A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called. var i; function foo(x) { var tmp = 3; i = function (y) { console.log(x + y + (++tmp)); } } foo(2); i(3); A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures. I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept: // makeSequencer will return a "sequencer" function var makeSequencer = function() { var _count = 0; // not accessible outside this function var sequencer = function () { return _count++; } return sequencer; } var fnext = makeSequencer(); var v0 = fnext(); // v0 = 0; var v1 = fnext(); // v1 = 1; var vz = fnext._count // vz = undefined You're having a sleep over and you invite Dan. You tell Dan to bring one XBox controller. Dan invites Paul. Dan asks Paul to bring one controller. How many controllers were brought to the party? function sleepOver(howManyControllersToBring) { var numberOfDansControllers = howManyControllersToBring; return function danInvitedPaul(numberOfPaulsControllers) { var totalControllers = numberOfDansControllers + numberOfPaulsControllers; return totalControllers; } } var howManyControllersToBring = 1; var inviteDan = sleepOver(howManyControllersToBring); // The only reason Paul was invited is because Dan was invited. // So we set Paul's invitation = Dan's invitation. var danInvitedPaul = inviteDan(howManyControllersToBring); alert("There were " + danInvitedPaul + " controllers brought to the party."); JavaScript functions can access their: Arguments Locals (that is, their local variables and local functions) Environment, which includes: globals, including the DOM anything in outer functions If a function accesses its environment, then the function is a closure. Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive. Example of a closure that uses the global environment: Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.) When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment. var isVotedUp = false; var isVotedDown = false; function voteUp_click() { if (isVotedUp) return; else if (isVotedDown) SetDownVote(false); else SetUpVote(true); } function voteDown_click() { if (isVotedDown) return; else if (isVotedUp) SetUpVote(false); else SetDownVote(true); } function SetUpVote(status) { isVotedUp = status; // Do some CSS stuff to Vote-Up button } function SetDownVote(status) { isVotedDown = status; // Do some CSS stuff to Vote-Down button } All four of these functions are closures as they all access their environment. As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old. function sing(person) { var firstPart = "There was " + person + " who swallowed "; var fly = function() { var creature = "a fly"; var result = "Perhaps she'll die"; alert(firstPart + creature + "\n" + result); }; var spider = function() { var creature = "a spider"; var result = "that wiggled and jiggled and tickled inside her"; alert(firstPart + creature + "\n" + result); }; var bird = function() { var creature = "a bird"; var result = "How absurd!"; alert(firstPart + creature + "\n" + result); }; var cat = function() { var creature = "a cat"; var result = "Imagine That!"; alert(firstPart + creature + "\n" + result); }; fly(); spider(); bird(); cat(); } var person="an old lady"; sing(person); INSTRUCTIONS DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to create touch smell and taste using a computer. It can be made useful by a computer using code. CODE: All the writing above is called code. It is written in JavaScript. JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says "все садятся", the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means "everybody sit down" - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser. BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions. FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out. All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat. I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot. A function normally has a name, parentheses and braces. Like this: function cookMeal() { /* STUFF INSIDE THE FUNCTION */ } Note that /*...*/ and // stop code being read by the browser. NAME: You can call a function just about whatever word you want. The example "cookMeal" is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own. PARENTHESES: "Parentheses" or () are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked for example cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime), in which case you know what data you have to give it. BRACES: "Braces" which look like this {} are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in. THE LONG CODE EXAMPLE ABOVE Our code begins with the word function, so we know that it is one! Then the name of the function sing - that's my own description of what the function is about. Then parentheses (). The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: (person). After this there is a brace like this { . This marks the start of the function sing(). It has a partner which marks the end of sing() like this } function sing(person) { /* STUFF INSIDE THE FUNCTION */ } So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data. Now, after the function sing(), near the end of the code is the line var person="an old lady"; VARIABLE: The letters var stand for "variable". A variable is like an envelope. On the outside this envelope is marked "person". On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading "an old lady". Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called arrays). Because this variable is written outside of all the braces {}, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'. GLOBAL VARIABLE: person is a global variable, meaning that if you change its value from "an old lady" to "a young man", the person will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the F12 button or look at the Options settings to open the developer console of a browser and type "person" to see what this value is. Type person="a young man" to change it and then type "person" again to see that it has changed. After this we have the line sing(person); This line is calling the function, as if it were calling a dog "Come on sing, Come and get person!" When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it. Functions define actions - the main function is about singing. It contains a variable called firstPart which applies to the singing about the person that applies to each of the verses of the song: "There was " + person + " who swallowed". If you type firstPart into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces. CLOSURES: The closures are the smaller functions that are inside the big sing() function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (creature and result) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows. The closures all know what the sing() function's variable called firstPart is, because they can see out from their tinted windows. After the closures come the lines fly(); spider(); bird(); cat(); The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done. The author of Closures has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures. Here is the summary: What if a variable is accessed, but it isn’t local? Like here: In this case, the interpreter finds the variable in the outer LexicalEnvironment object. The process consists of two steps: First, when a function f is created, it is not created in an empty space. There is a current LexicalEnvironment object. In the case above, it’s window (a is undefined at the time of function creation). When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment. If a variable is read, but can not be found anywhere, an error is generated. Nested functions Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain. So, function g has access to g, a and f. Closures A nested function may continue to live after the outer function has finished: Marking up LexicalEnvironments: As we see, this.say is a property in the user object, so it continues to live after User completed. And if you remember, when this.say is created, it (as every function) gets an internal reference this.say.[[Scope]] to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually. The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so. To summarize: The inner function keeps a reference to the outer LexicalEnvironment. The inner function may access variables from it any time even if the outer function is finished. The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it. This is called a closure. (You may also want to read What is a practical use for a closure in JavaScript?) Okay, talking with a 6-year old child, I would possibly use following associations. Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's closure; your brother made it up for you, and he is now into outer scope. Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance. For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is: function playingInBrothersRoom (withToys) { // We closure toys which we played in the brother's room. When he come back and lock the door // your brother is supposed to be into the outer [[scope]] object now. Thanks god you could communicate with him. var closureToys = withToys || [], returnToy, countIt, toy; // Just another closure helpers, for brother's inner use. var brotherGivesToyBack = function (toy) { // New request. There is not yet closureToys on brother's hand yet. Give him a time. returnToy = null; if (toy && closureToys.length > 0) { // If we ask for a specific toy, the brother is going to search for it. for ( countIt = closureToys.length; countIt; countIt--) { if (closureToys[countIt - 1] == toy) { returnToy = 'Take your ' + closureToys.splice(countIt - 1, 1) + ', little boy!'; break; } } returnToy = returnToy || 'Hey, I could not find any ' + toy + ' here. Look for it in another room.'; } else if (closureToys.length > 0) { // Otherwise, just give back everything he has in the room. returnToy = 'Behold! ' + closureToys.join(', ') + '.'; closureToys = []; } else { returnToy = 'Hey, lil shrimp, I gave you everything!'; } console.log(returnToy); } return brotherGivesToyBack; } // You are playing in the house, including the brother's room. var toys = ['teddybear', 'car', 'jumpingrope'], askBrotherForClosuredToy = playingInBrothersRoom(toys); // The door is locked, and the brother came from the school. You could not cheat and take it out directly. console.log(askBrotherForClosuredToy.closureToys); // Undefined // But you could ask your brother politely, to give it back. askBrotherForClosuredToy('teddybear'); // Hooray, here it is, teddybear askBrotherForClosuredToy('ball'); // The brother would not be able to find it. askBrotherForClosuredToy(); // The brother gives you all the rest askBrotherForClosuredToy(); // Nothing left in there As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is a jsbin to play around with it. An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is): Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function "closes." In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it. function the_closure() { var x = 4; return function () { return x; // Here, we look back inside the_closure for the value of x } } var myFn = the_closure(); myFn(); //=> 4 Another really simple way to explain it is in terms of scope: Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope. Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me. A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function’s scope. function outerFunction() { var outerVar = "monkey"; function innerFunction() { alert(outerVar); } innerFunction(); } outerFunction(); ALERT: monkey In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar. Now consider the following: function outerFunction() { var outerVar = "monkey"; function innerFunction() { return outerVar; } return innerFunction; } var referenceToInnerFunction = outerFunction(); alert(referenceToInnerFunction()); ALERT: monkey referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing. And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case. function outerFunction() { var outerVar = "monkey"; function innerFunction() { return outerVar; } return innerFunction; } var referenceToInnerFunction = outerFunction(); alert(referenceToInnerFunction()); outerFunction = null; alert(referenceToInnerFunction()); ALERT: monkey ALERT: monkey But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null? The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction’s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction’s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction’s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well. ////////// Two other things about closures to note. First, the closure will always have access to the last values of its containing function. function outerFunction() { var outerVar = "monkey"; function innerFunction() { alert(outerVar); } outerVar = "gorilla"; innerFunction(); } outerFunction(); ALERT: gorilla Second, when a closure is created, it retains a reference to all of its enclosing function’s variables and functions; it doesn’t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing. A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure. Closures are functions with a state. It is somewhat similar to "this" in the sense that "this" also provides state for a function but function and "this" are separate objects ("this" is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While "this" and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables. Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context). Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code). An example: function foo (initValue) { //This variable is not destroyed when the foo function exits. //It is 'captured' by the two nested functions returned below. var value = initValue; //Note that the two returned functions are created right now. //If the foo function is called again, it will return //new functions referencing a different 'value' variable. return { getValue: function () { return value; }, setValue: function (newValue) { value = newValue; } } } function bar () { //foo sets its local variable 'value' to 5 and returns an object with //two functions still referencing that local variable var obj = foo(5); //Extracting functions just to show that no 'this' is involved here var getValue = obj.getValue; var setValue = obj.setValue; alert(getValue()); //Displays 5 setValue(10); alert(getValue()); //Displays 10 //At this point getValue and setValue functions are destroyed //(in reality they are destroyed at the next iteration of the garbage collector). //The local variable 'value' in the foo is no longer referenced by //anything and is destroyed too. } bar(); I'd simply point them to the Mozilla Closures page. It's the best, most concise and simple explanation of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript. And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the concise and simple explanation provided in the article. JavaScript closures for beginners Submitted by Morris on Tue, 2006-02-21 10:19. Community-edited since. Closures are not magic This page explains closures so that a programmer can understand them — using working JavaScript code. It is not for gurus or functional programmers. Closures are not hard to understand once the core concept is grokked. However, they are impossible to understand by reading any academic papers or academically oriented information about them! This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function: function sayHello(name) { var text = 'Hello ' + name; var say = function() { console.log(text); } say(); } sayHello('Joe'); An example of a closure Two one sentence summaries: A closure is one way of supporting first-class functions; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result. Or, a closure is a stack frame which is allocated when a function starts its execution, and not freed after the function returns (as if a 'stack frame' were allocated on the heap rather than the stack!). The following code returns a reference to a function: function sayHello2(name) { var text = 'Hello ' + name; // Local variable var say = function() { console.log(text); } return say; } var say2 = sayHello2('Bob'); say2(); // logs "Hello Bob" Most JavaScript programmers will understand how a reference to a function is returned to a variable (say2) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables say and say2 were each a pointer to a function. There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function as well as a hidden pointer to a closure. The above code has a closure because the anonymous function function() { console.log(text); } is declared inside another function, sayHello2() in this example. In JavaScript, if you use the function keyword inside another function, you are creating a closure. In C and most other common languages, after a function returns, all the local variables are no longer accessible because the stack-frame is destroyed. In JavaScript, if you declare a function within another function, then the local variables can remain accessible after returning from the function you called. This is demonstrated above, because we call the function say2() after we have returned from sayHello2(). Notice that the code that we call references the variable text, which was a local variable of the function sayHello2(). function() { console.log(text); } // Output of say2.toString(); Looking at the output of say2.toString(), we can see that the code refers to the variable text. The anonymous function can reference text which holds the value 'Hello Bob' because the local variables of sayHello2() are kept in a closure. The magic is that in JavaScript a function reference also has a secret reference to the closure it was created in — similar to how delegates are a method pointer plus a secret reference to an object. More examples For some reason, closures seem really hard to understand when you read about them, but when you see some examples it becomes clear how they work (it took me a while). I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs! Example 3 This example shows that the local variables are not copied — they are kept by reference. It is kind of like keeping a stack-frame in memory when the outer function exits! function say667() { // Local variable that ends up within closure var num = 42; var say = function() { console.log(num); } num++; return say; } var sayNumber = say667(); sayNumber(); // logs 43 Example 4 All three global functions have a common reference to the same closure because they are all declared within a single call to setupSomeGlobals(). var gLogNumber, gIncreaseNumber, gSetNumber; function setupSomeGlobals() { // Local variable that ends up within closure var num = 42; // Store some references to functions as global variables gLogNumber = function() { console.log(num); } gIncreaseNumber = function() { num++; } gSetNumber = function(x) { num = x; } } setupSomeGlobals(); gIncreaseNumber(); gLogNumber(); // 43 gSetNumber(5); gLogNumber(); // 5 var oldLog = gLogNumber; setupSomeGlobals(); gLogNumber(); // 42 oldLog() // 5 The three functions have shared access to the same closure — the local variables of setupSomeGlobals() when the three functions were defined. Note that in the above example, if you call setupSomeGlobals() again, then a new closure (stack-frame!) is created. The old gLogNumber, gIncreaseNumber, gSetNumber variables are overwritten with new functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again each time the outside function is called.) Example 5 This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure do not act as you might first think. function buildList(list) { var result = []; for (var i = 0; i < list.length; i++) { var item = 'item' + i; result.push( function() {console.log(item + ' ' + list[i])} ); } return result; } function testList() { var fnlist = buildList([1,2,3]); // Using j only to help prevent confusion -- could use i. for (var j = 0; j < fnlist.length; j++) { fnlist[j](); } } testList() //logs "item2 undefined" 3 times The line result.push( function() {console.log(item + ' ' + list[i])} adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like: pointer = function() {console.log(item + ' ' + list[i])}; result.push(pointer); Note that when you run the example, "item2 undefined" is alerted three times! This is because just like previous examples, there is only one closure for the local variables for buildList. When the anonymous functions are called on the line fnlist[j](); they all use the same single closure, and they use the current value for i and item within that one closure (where i has a value of 3 because the loop had completed, and item has a value of 'item2'). Note we are indexing from 0 hence item has a value of item2. And the i++ will increment i to the value 3. Example 6 This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable alice is actually declared after the anonymous function. The anonymous function is declared first; and when that function is called it can access the alice variable because alice is in the same scope (JavaScript does variable hoisting). Also sayAlice()() just directly calls the function reference returned from sayAlice() — it is exactly the same as what was done previously but without the temporary variable. function sayAlice() { var say = function() { console.log(alice); } // Local variable that ends up within closure var alice = 'Hello Alice'; return say; } sayAlice()();// logs "Hello Alice" Tricky: note also that the say variable is also inside the closure, and could be accessed by any other function that might be declared within sayAlice(), or it could be accessed recursively within the inside function. Example 7 This final example shows that each call creates a separate closure for the local variables. There is not a single closure per function declaration. There is a closure for each call to a function. function newClosure(someNum, someRef) { // Local variables that end up within closure var num = someNum; var anArray = [1,2,3]; var ref = someRef; return function(x) { num += x; anArray.push(num); console.log('num: ' + num + '; anArray: ' + anArray.toString() + '; ref.someVar: ' + ref.someVar + ';'); } } obj = {someVar: 4}; fn1 = newClosure(4, obj); fn2 = newClosure(5, obj); fn1(1); // num: 5; anArray: 1,2,3,5; ref.someVar: 4; fn2(1); // num: 6; anArray: 1,2,3,6; ref.someVar: 4; obj.someVar++; fn1(2); // num: 7; anArray: 1,2,3,5,7; ref.someVar: 5; fn2(2); // num: 8; anArray: 1,2,3,6,8; ref.someVar: 5; Summary If everything seems completely unclear then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples. My explanations of closures and stack-frames, etc. are not technically correct — they are gross simplifications intended to help understanding. Once the basic idea is grokked, you can pick up the details later. Final points: Whenever you use function inside another function, a closure is used. Whenever you use eval() inside a function, a closure is used. The text you eval can reference local variables of the function, and within eval you can even create new local variables by using eval('var foo = …') When you use new Function(…) (the Function constructor) inside a function, it does not create a closure. (The new function cannot reference the local variables of the outer function.) A closure in JavaScript is like keeping a copy of all the local variables, just as they were when a function exited. It is probably best to think that a closure is always created just an entry to a function, and the local variables are added to that closure. A new set of local variables is kept every time a function with a closure is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way). Two functions might look like they have the same source text, but have completely different behaviour because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not. If you are trying to do any dynamic source code modifications (for example: myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));), it won't work if myFunction is a closure (of course, you would never even think of doing source code string substitution at runtime, but...). It is possible to get function declarations within function declarations within functions — and you can get closures at more than one level. I think normally a closure is the term for both the function along with the variables that are captured. Note that I do not use that definition in this article! I suspect that closures in JavaScript differ from those normally found in functional languages. Links Douglas Crockford's simulated private attributes and private methods for an object, using closures. A great explanation of how closures can cause memory leaks in IE if you are not careful. Thanks If you have just learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript — nor on closures. Original post by Morris can be found in the Internet Archive.
https://stackoverflow.com/questions/1642028/what-is-the-operator-in-c	What is the "-->" operator in C++? - Stack Overflow	[votes:7498][favorites:1734]	What is the “-->” operator in C++? After reading Hidden Features and Dark Corners of C++/STL on comp.lang.c++.moderated, I was completely surprised that the following snippet compiled and worked in both Visual Studio 2008 and G++ 4.4. Here's the code: #include <stdio.h> int main() { int x = 10; while (x --> 0) // x goes to 0 { printf("%d ", x); } } I'd assume this is C, since it works in GCC as well. Where is this defined in the standard, and where has it come from? c++ operators code-formatting standards-compliance That's a very complicated operator, so even ISO/IEC JTC1 (Joint Technical Committee 1) placed its description in two different parts of the C++ Standard. Joking aside, they are two different operators: -- and > described respectively in 5.2.6/2 and 5.9 of the C++03 Standard. Or for something completely different... x slides to 0 while (x --\ \ \ \ > 0) printf("%d ", x); Not so mathematical, but... every picture paints a thousand words. ... It's equivalent to while (x-- > 0) x can go to zero even faster in the opposite direction: int x = 10; while( 0 <---- x ) { printf("%d ", x); } 8 6 4 2 You can control speed with an arrow! int x = 100; while( 0 <-------------------- x ) { printf("%d ", x); } 90 80 70 60 50 40 30 20 10 ;) It's #include <stdio.h> int main(void){ int x = 10; while( x-- > 0 ){ // x goes to 0 printf("%d ", x); } return 0; } Just the space make the things look funny, -- decrements and > compares. The usage of --> has historical relevance. Decrementing was (and still is in some cases), faster than incrementing on the x86 architecture. Using --> suggests that x is going to 0, and appeals to those with mathematical backgrounds. while( x-- > 0 ) is how that's parsed. One book I read (I don't remember correctly which book) stated: Compilers try to parse expressions to the biggest token by using the left right rule. In this case, the expression: x-->0 Parses to biggest tokens: token 1: x token 2: -- token 3: > token 4: 0 conclude: x-- > 0 The same rule applies to this expression: a-----b After parse: token 1: a token 2: -- token 3: -- token 4: - token 5: b conclude: (a--)-- - b I hope this helps to understand the complicated expression ^^ Utterly geek, but I will be using this: #define as ;while int main(int argc, char* argv[]) { int n = atoi(argv[1]); do printf("n is %d\n", n) as ( n --> 0); return 0; } This is exactly the same as while (x--) { printf("%d ", x); } for non-negative numbers Anyway, we have a "goes to" operator now. "-->" is easy to be remembered as a direction, and "while x goes to zero" is meaning-straight. Furthermore, it is a little more efficient than "for (x = 10; x > 0; x --)" on some platforms. This code first compares x and 0 and then decrements x. (Also said in the first answer: You're post-decrementing x and then comparing x and 0 with the > operator.) See the output of this code: 9 8 7 6 5 4 3 2 1 0 We now first compare and then decrement by seeing 0 in the output. If we want to first decrement and then compare, use this code: #include <stdio.h> int main(void) { int x = 10; while( --x> 0 ) // x goes to 0 { printf("%d ", x); } return 0; } That output is: 9 8 7 6 5 4 3 2 1 My compiler will print out 9876543210 when I run this code. #include <iostream> int main() { int x = 10; while( x --> 0 ) // x goes to 0 { std::cout << x; } } As expected. The while( x-- > 0 ) actually means while( x > 0). The x-- post decrements x. while( x > 0 ) { x--; std::cout << x; } is a different way of writing the same thing. It is nice that the original looks like "while x goes to 0" though. There is a space missing between -- and >. x is post decremented, that is, decremented after checking the condition x>0 ?. -- is the decrement operator and > is the greater-than operator. The two operators are applied as a single one like -->. It's a combination of two operators. First -- is for decrementing the value, and > is for checking whether the value is greater than the right-hand operand. #include<stdio.h> int main() { int x = 10; while (x-- > 0) printf("%d ",x); return 0; } The output will be: 9 8 7 6 5 4 3 2 1 0 Actually, x is post-decrementing and with that condition is being checked. It's not -->, it's (x--) > 0 Note: value of x is changed after the condition is checked, because it post-decrementing. Some similar cases can also occur, for example: --> x-->0 ++> x++>0 -->= x-->=0 ++>= x++>=0 C and C++ obey the "maximum munch" rule. The same way a---b is translated to (a--) - b, in your case x-->0 translates to (x--)>0. What the rule says essentially is that going left to right, expressions are formed by taking the maximum of characters which will form an valid expression. Why all the complication? The simple answer to the original question is just: #include <stdio.h> int main() { int x = 10; while (x > 0) { printf("%d ", x); x = x-1; } } Does the same thing. Not saying you should do it like this, but it does the same thing and would have answered the question in one post. The x-- is just shorthand for the above, and > is just a normal greater-than operator. No big mystery! There's too much people making simple things complicated nowadays ;) Conventional way we define condition in while loop parenthesis"()" and terminating condition inside the braces"{}", but this -- & > is a way one defines all at once. For e.g: int abc(){ int a = 5 while((a--) > 0){ // Decrement and comparison both at once // Code } } It says, decrement a and run the loop till the time a is greater than 0 Other way it should have been like: int abc(){ int a = 5 while(a > 0){ // Code a = a -1 // Decrement inside loop } } both ways, we do the same thing and achieve the same goals. --> is not an operator. It is in fact two separate operators, -- and >. The conditional's code decrements x, while returning x's original (not decremented) value, and then compares the original value with 0 using the > operator. To better understand, the statement could be written as follows: while( (x--) > 0 )
https://stackoverflow.com/questions/1789945/how-to-check-whether-a-string-contains-a-substring-in-javascript	How to check whether a string contains a substring in JavaScript? - Stack Overflow	[votes:7442][favorites:1196]	How to check whether a string contains a substring in JavaScript? Usually I would expect a String.contains() method, but there doesn't seem to be one. What is a reasonable way to check for this? javascript string substring contains string-matching You can easily add a contains method to String with this statement: String.prototype.contains = function(it) { return this.indexOf(it) != -1; }; Note: see the comments below for a valid argument for not using this. My advice: use your own judgement. Alternatively: if (typeof String.prototype.contains === 'undefined') { String.prototype.contains = function(it) { return this.indexOf(it) != -1; }; } The problem with your code is that JavaScript is case sensitive. Your method call indexof() should actually be indexOf() Try fixing it and see if that helps: if (test.indexOf("title") !=-1) { alert(elm); foundLinks++; } var index = haystack.indexOf(needle); Update for 2015: string.includes has been added to JavaScript's next version, ES6: "potato".includes("to"); > true Note you may need to load es6-shim or similar to get this working on older browsers. require('es6-shim') You could use the JavaScript search() method. Syntax is: string.search(regexp) It returns the position of the match, or -1 if no match is found. See examples there: jsref_search You don't need a complicated regular expression syntax. If you are not familiar with them a simple st.search("title") will do. If you want your test to be case insensitive, then you should do st.search(/title/i). String.prototype.includes() was introduced in ES6. Determines whether one string may be found within another string, returning true or false as appropriate. Syntax var contained = str.includes(searchString [, position]); Parameters searchString A string to be searched for within this string. position The position in this string at which to begin searching for searchString defaults to 0. Example var str = "To be, or not to be, that is the question."; console.log(str.includes("To be")); // true console.log(str.includes("question")); // true console.log(str.includes("To be", 1)); // false Note This may require ES6 shim in older browsers. If you were looking for an alternative to write the ugly -1 check, you prepend a ~ tilde instead. if (~haystack.indexOf('needle')) alert('found'); Joe Zimmerman - you'll see that using ~ on -1 converts it to 0. The number 0 is a falsey value, meaning that it will evaluate to false when converted to a Boolean. That might not seem like a big insight at first, but remember functions like indexOf will return -1 when the query is not found. This means that instead of writing something similar to this: if (someStr.indexOf("a") >= 0) { // Found it } else { // Not Found } You can now have fewer characters in your code so you can write it like this: if (~someStr.indexOf("a")) { // Found it } else { // Not Found } More details here This piece of code should work well: var str="This is testing for javascript search !!!"; if(str.search("for") != -1) { //logic } In ES5 var s = "foo"; alert(s.indexOf("oo") > -1); In ES6 there are three new methods: includes(), startsWith(), endsWith(). var msg = "Hello world!"; console.log(msg.startsWith("Hello")); // true console.log(msg.endsWith("!")); // true console.log(msg.includes("o")); // true console.log(msg.startsWith("o", 4)); // true console.log(msg.endsWith("o", 8)); // true console.log(msg.includes("o", 8)); // false A common way to write a contains method in JavaScript is: if (!String.prototype.contains) { String.prototype.contains = function (arg) { return !!~this.indexOf(arg); }; } The bitwise negation operator (~) is used to turn -1 into 0 (falsey), and all other values will be non-zero (truthy). The double boolean negation operators are used to cast the number into a boolean. You can use jQuery's :contains selector. $("div:contains('John')") Check it here: contains-selector Instead of using code snippets found here and there on the web, you can also use a well-tested and documented library. Two Options I would recommend: 1st option: Use Lodash: It has an includes method: _.includes('foobar', 'ob'); // → true Lodash is the most popular javascript library dependency for npm and has loads of handy javascript utility methods. So for many projects you would want this anyway ;-) 2nd option: Or use Underscore.string: It has an include method: _.str.include('foobar', 'ob'); // → true Here is the description of Underscore.string, it just adds 9kb but gives you all the advantages a well-tested and documented library has over copy'n'paste code snippets: Underscore.string is JavaScript library for comfortable manipulation with strings, extension for Underscore.js inspired by Prototype.js, Right.js, Underscore and beautiful Ruby language. Underscore.string provides you several useful functions: capitalize, clean, includes, count, escapeHTML, unescapeHTML, insert, splice, startsWith, endsWith, titleize, trim, truncate and so on. Note well, Underscore.string is influenced by Underscore.js but can be used without it. Last not Least: With JavaScript version ES6 comes an built-in includes method: 'foobar'.includes('ob'); // → true Most modern browsers already support it, have an eye on the ES6 compatibility table. Use a regular expression: RegExp.test(string) This just worked for me. It selects for strings that do not contain the term "Deleted:" if (eventString.indexOf("Deleted:") == -1) You were looking for .indexOfMDN. indexOf is going to return an index to the matched substring. The index will correlate to where the substring starts. If there is no match, a -1 is returned. Here is a simple demo of that concept: var str = "Hello World"; // For example, lets search this string, var term = "World"; // for the term "World", var index = str.indexOf(term); // and get its index. if (index != -1) { // If the index is not -1 then the term was matched in the string, alert(index); // and we can do some work based on that logic. (6 is alerted) } You need to call indexOf with a capital "O" as mentioned. It should also be noted, that in JavaScript class is a reserved word, you need to use className to get this data attribute. The reason it's probably failing is because it's returning a null value. You can do the following to get your class value... var test = elm.getAttribute("className"); //or var test = elm.className Another option of doing this is: You can use the match function, that is, something like: x = "teststring"; if (x.match("test")) { // Code } match() can also work with regular expression : x = "teststring"; if (x.match(/test/i)) { // Code } Since the question is pretty popular, I thought I could add a little modern flavor to the code. // const : creates an immutable constant const allLinks = document.getElementsByTagName("a"); // [].reduce.call : gives access to the reduce method on a HTMLCollection // () => {} : ES6 arrow function const foundLinks = [].reduce.call(allLinks, (sum, link) => { // bitwise OR : converts the boolean value to a number return sum + (link.classList.contains("title") | 0); }, 0); // template literal console.log(`Found ${foundLinks || "no"} title class`); BTW, the correct answer is misspelling indexOf or the non-standard String.contains. Loading an external library (especially if the code is written in pure JavaScript) or messing with String.prototype or using a regular expression is a little overkill. There is a sleek and better way to do this and it is using the (BitWise NOT) operator. if(~"John".indexOf("J")) { alert("Found") } else { alert("Not Found"); } The Bitwise Not converts "x" into -(x + 1) so, if the x turns out -1 from indexOf method.then it will be converted into -( -1 + 1) = -0 which is a falsy value . String.prototype.indexOf() or String.prototype.search()?! As others have already mentioned, JavaScript strings have both an indexOf and search method. The key difference between both, is that indexOf is for plain substrings only, whereas search also supports regular expressions. Of course, an upside of using indexOf is that it's faster. See also In JavaScript, what is the difference between indexOf() and search()?. Implementing your own String.prototype.contains() method If you want to add your own contains method to every string, the best way to do it would be @zzzzBov's approach: if (!String.prototype.contains) { String.prototype.contains = function (arg) { return !!~this.indexOf(arg); }; } You would use it like this: 'Hello World'.contains('orl'); Implementing a custom utility library It is generally frowned upon to add your own custom methods to standard objects in JavaScript, for example, because it might break forward compatibility. If you really want your own contains method and/or other custom string methods, it's better to create your own utility library and add your custom string methods to that library: var helper = {}; helper.string = { contains : function (haystack, needle) { return !!~haystack.indexOf(needle); }, ... }; You would use it like this: helper.string.contains('Hello World', 'orl'); Using a third-party utility library If you don't want to create your own custom helper library, there is - of course - always the option of using a third-party utility library. As mentioned by @nachtigall, the most popular ones are Lodash and Underscore.js. In Lodash, you could use _.includes(), which you use like this: _.includes('Hello World', 'orl'); In Underscore.js, you could use _.str.include(), which you use like this : _.str.include('Hello World', 'orl'); Simple workaround if (!String.prototype.contains) { String.prototype.contains= function() { return String.prototype.indexOf.apply(this, arguments) !== -1; }; } you can use in the following way "hello".contains("he") // true "hello world".contains("lo w")//true "hello world".contains("lo wa")//false "hello world".contains(" ")//true "hello world".contains(" ")//false MDN reference Example var a = "Test String"; if(a.search("ring")!=-1){ //exist } else { //not found } JavaScript code to use the contains method in an array: <html> <head> <h2>Use of contains() method</h2> <script> Array.prototype.contains = function (element) { for (var i = 0; i < this.length; i++) { if (this[i] == element) { return true; } } return false; } arr1 = ["Rose", "India", "Technologies"]; document.write("The condition is "+arr1.contains("India")+"<br>"); </script> </head> <b>[If the specified element is present in the array, it returns true otherwise returns false.]</b> </html> In the given code the contains method determines whether the specified element is present in the array or not. If the specified element is present in the array, it returns true, otherwise it returns false. ES6 contains String.prototype.includes. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes To collect some kind of valid solutions: var stringVariable = "some text"; var findString = "text"; //using `indexOf()` var containResult1 = stringVariable.indexOf(findString) != -1; document.write(containResult1+', '); //using `lastIndexOf()` var containResult2 = stringVariable.lastIndexOf(findString) != -1; document.write(containResult2+', '); //using `search()` var containResult3 = stringVariable.search(findString) != -1; document.write(containResult3+', '); //using `split()` var containResult4 = stringVariable.split(findString)[0] != stringVariable; document.write(containResult4+''); Since there is a complaint about using the prototype, and since using indexOf makes your code less readable, and since regexp is overkill: function stringContains(inputString, stringToFind) { return (inputString.indexOf(stringToFind) != -1); } That is the compromise I ended up going for. JavaScript var str = "My big string contain apples and oranges"; var n = str.indexOf("apples"); alert(n); //will alert 22, -1 if not found jQuery <p>My big string contain apples and oranges</p> alert($("p:contains(apples)")[0] != undefined); //will alert true if found Use the inbuilt and simplest one i.e match() on the string. To achieve what you are looking forward do this: var stringData ="anyString Data"; var subStringToSearch = "any"; // This will give back the substring if matches and if not returns null var doesContains = stringData.match(subStringToSearch); if(doesContains !=null) { alert("Contains Substring"); } The easyest way is indeed using indexOf. To just check a string string for a substring substr you can use this method: string = "asdf"; substr = "as"; alert(string.indexOf(substr) == -1 ? false : true); As you wanted the function string.contains(), you can implement it yourself like this: String.prototype.contains = function(test) { return this.indexOf(test) == -1 ? false : true; }; Now you can use this ecen shorter method to check if a string contains a special substring: string = "asdf"; alert(string.contains("as")); Here is a JSFiddle as well. Here is a list of current possibilities: 1. (ES6) includes—go to answer var string = "foo", substring = "oo"; string.includes(substring); 2. ES5 and older indexOf var string = "foo", substring = "oo"; string.indexOf(substring) !== -1; String.prototype.indexOf returns the position of the string in the other string. If not found, it will return -1. 3. search—go to answer var string = "foo", expr = /oo/; string.search(expr); 4. lodash includes—go to answer var string = "foo", substring = "oo"; _.includes(string, substring); 5. RegExp—go to answer var string = "foo", expr = /oo/; // no quotes here expr.test(string); 6. Match—go to answer var string = "foo", expr = /oo/; string.match(expr); Performance tests are showing that indexOf might be the best choice, if it comes to a point where speed matters.
https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap	memory management - What and where are the stack and heap? - Stack Overflow	[votes:6868][favorites:4052]	What and where are the stack and heap? Programming language books explain that value types are created on the stack, and reference types are created on the heap, without explaining what these two things are. I haven't read a clear explanation of this. I understand what a stack is, but where and what are they (physically in a real computer's memory)? To what extent are they controlled by the OS or language runtime? What is their scope? What determines the size of each of them? What makes one faster? memory-management language-agnostic stack heap Stack: Stored in computer RAM just like the heap. Variables created on the stack will go out of scope and are automatically deallocated. Much faster to allocate in comparison to variables on the heap. Implemented with an actual stack data structure. Stores local data, return addresses, used for parameter passing. Can have a stack overflow when too much of the stack is used (mostly from infinite or too deep recursion, very large allocations). Data created on the stack can be used without pointers. You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big. Usually has a maximum size already determined when your program starts. Heap: Stored in computer RAM just like the stack. In C++, variables on the heap must be destroyed manually and never fall out of scope. The data is freed with delete, delete[], or free. Slower to allocate in comparison to variables on the stack. Used on demand to allocate a block of data for use by the program. Can have fragmentation when there are a lot of allocations and deallocations. In C++ or C, data created on the heap will be pointed to by pointers and allocated with new or malloc respectively. Can have allocation failures if too big of a buffer is requested to be allocated. You would use the heap if you don't know exactly how much data you will need at run time or if you need to allocate a lot of data. Responsible for memory leaks. Example: int foo() { char *pBuffer; //<--nothing allocated yet (excluding the pointer itself, which is allocated here on the stack). bool b = true; // Allocated on the stack. if(b) { //Create 500 bytes on the stack char buffer[500]; //Create 500 bytes on the heap pBuffer = new char[500]; }//<-- buffer is deallocated here, pBuffer is not }//<--- oops there's a memory leak, I should have called delete[] pBuffer; The most important point is that heap and stack are generic terms for ways in which memory can be allocated. They can be implemented in many different ways, and the terms apply to the basic concepts. In a stack of items, items sit one on top of the other in the order they were placed there, and you can only remove the top one (without toppling the whole thing over). The simplicity of a stack is that you do not need to maintain a table containing a record of each section of allocated memory; the only state information you need is a single pointer to the end of the stack. To allocate and de-allocate, you just increment and decrement that single pointer. Note: a stack can sometimes be implemented to start at the top of a section of memory and extend downwards rather than growing upwards. In a heap, there is no particular order to the way items are placed. You can reach in and remove items in any order because there is no clear 'top' item. Heap allocation requires maintaining a full record of what memory is allocated and what isn't, as well as some overhead maintenance to reduce fragmentation, find contiguous memory segments big enough to fit the requested size, and so on. Memory can be deallocated at any time leaving free space. Sometimes a memory allocator will perform maintenance tasks such as defragmenting memory by moving allocated memory around, or garbage collecting - identifying at runtime when memory is no longer in scope and deallocating it. These images should do a fairly good job of describing the two ways of allocating and freeing memory in a stack and a heap. Yum! To what extent are they controlled by the OS or language runtime? As mentioned, heap and stack are general terms, and can be implemented in many ways. Computer programs typically have a stack called a call stack which stores information relevant to the current function such as a pointer to whichever function it was called from, and any local variables. Because functions call other functions and then return, the stack grows and shrinks to hold information from the functions further down the call stack. A program doesn't really have runtime control over it; it's determined by the programming language, OS and even the system architecture. A heap is a general term used for any memory that is allocated dynamically and randomly; i.e. out of order. The memory is typically allocated by the OS, with the application calling API functions to do this allocation. There is a fair bit of overhead required in managing dynamically allocated memory, which is usually handled by the OS. What is their scope? The call stack is such a low level concept that it doesn't relate to 'scope' in the sense of programming. If you disassemble some code you'll see relative pointer style references to portions of the stack, but as far as a higher level language is concerned, the language imposes its own rules of scope. One important aspect of a stack, however, is that once a function returns, anything local to that function is immediately freed from the stack. That works the way you'd expect it to work given how your programming languages work. In a heap, it's also difficult to define. The scope is whatever is exposed by the OS, but your programming language probably adds its rules about what a "scope" is in your application. The processor architecture and the OS use virtual addressing, which the processor translates to physical addresses and there are page faults, etc. They keep track of what pages belong to which applications. You never really need to worry about this, though, because you just use whatever method your programming language uses to allocate and free memory, and check for errors (if the allocation/freeing fails for any reason). What determines the size of each of them? Again, it depends on the language, compiler, operating system and architecture. A stack is usually pre-allocated, because by definition it must be contiguous memory (more on that in the last paragraph). The language compiler or the OS determine its size. You don't store huge chunks of data on the stack, so it'll be big enough that it should never be fully used, except in cases of unwanted endless recursion (hence, "stack overflow") or other unusual programming decisions. A heap is a general term for anything that can be dynamically allocated. Depending on which way you look at it, it is constantly changing size. In modern processors and operating systems the exact way it works is very abstracted anyway, so you don't normally need to worry much about how it works deep down, except that (in languages where it lets you) you mustn't use memory that you haven't allocated yet or memory that you have freed. What makes one faster? The stack is faster because all free memory is always contiguous. No list needs to be maintained of all the segments of free memory, just a single pointer to the current top of the stack. Compilers usually store this pointer in a special, fast register for this purpose. What's more, subsequent operations on a stack are usually concentrated within very nearby areas of memory, which at a very low level is good for optimization by the processor on-die caches. (I have moved this answer from another question that was more or less a dupe of this one.) The answer to your question is implementation specific and may vary across compilers and processor architectures. However, here is a simplified explanation. Both the stack and the heap are memory areas allocated from the underlying operating system (often virtual memory that is mapped to physical memory on demand). In a multi-threaded environment each thread will have its own completely independent stack but they will share the heap. Concurrent access has to be controlled on the heap and is not possible on the stack. The heap The heap contains a linked list of used and free blocks. New allocations on the heap (by new or malloc) are satisfied by creating a suitable block from one of the free blocks. This requires updating list of blocks on the heap. This meta information about the blocks on the heap is also stored on the heap often in a small area just in front of every block. As the heap grows new blocks are often allocated from lower addresses towards higher addresses. Thus you can think of the heap as a heap of memory blocks that grows in size as memory is allocated. If the heap is too small for an allocation the size can often be increased by acquiring more memory from the underlying operating system. Allocating and deallocating many small blocks may leave the heap in a state where there are a lot of small free blocks interspersed between the used blocks. A request to allocate a large block may fail because none of the free blocks are large enough to satisfy the allocation request even though the combined size of the free blocks may be large enough. This is called heap fragmentation. When a used block that is adjacent to a free block is deallocated the new free block may be merged with the adjacent free block to create a larger free block effectively reducing the fragmentation of the heap. The stack The stack often works in close tandem with a special register on the CPU named the stack pointer. Initially the stack pointer points to the top of the stack (the highest address on the stack). The CPU has special instructions for pushing values onto the stack and popping them back from the stack. Each push stores the value at the current location of the stack pointer and decreases the stack pointer. A pop retrieves the value pointed to by the stack pointer and then increases the stack pointer (don't be confused by the fact that adding a value to the stack decreases the stack pointer and removing a value increases it. Remember that the stack grows to the bottom). The values stored and retrieved are the values of the CPU registers. When a function is called the CPU uses special instructions that push the current instruction pointer, i.e. the address of the code executing on the stack. The CPU then jumps to the function by setting the instruction pointer to the address of the function called. Later, when the function returns, the old instruction pointer is popped from the stack and execution resumes at the code just after the call to the function. When a function is entered, the stack pointer is decreased to allocate more space on the stack for local (automatic) variables. If the function has one local 32 bit variable four bytes are set aside on the stack. When the function returns, the stack pointer is moved back to free the allocated area. If a function has parameters, these are pushed onto the stack before the call to the function. The code in the function is then able to navigate up the stack from the current stack pointer to locate these values. Nesting function calls work like a charm. Each new call will allocate function parameters, the return address and space for local variables and these activation records can be stacked for nested calls and will unwind in the correct way when the functions return. As the stack is a limited block of memory, you can cause a stack overflow by calling too many nested functions and/or allocating too much space for local variables. Often the memory area used for the stack is set up in such a way that writing below the bottom (the lowest address) of the stack will trigger a trap or exception in the CPU. This exceptional condition can then be caught by the runtime and converted into some kind of stack overflow exception. Can a function be allocated on the heap instead of a stack? No, activation records for functions (i.e. local or automatic variables) are allocated on the stack that is used not only to store these variables, but also to keep track of nested function calls. How the heap is managed is really up to the runtime environment. C uses malloc and C++ uses new, but many other languages have garbage collection. However, the stack is a more low-level feature closely tied to the processor architecture. Growing the heap when there is not enough space isn't too hard since it can be implemented in the library call that handles the heap. However, growing the stack is often impossible as the stack overflow only is discovered when it is too late; and shutting down the thread of execution is the only viable option. In the following C# code public void Method1() { int i = 4; int y = 2; class1 cls1 = new class1(); } Here's how the memory is managed Local Variables that only need to last as long as the function invocation go in the stack. The heap is used for variables whose lifetime we don't really know up front but we expect them to last a while. In most languages it's critical that we know at compile time how large a variable is if we want to store it on the stack. Objects (which vary in size as we update them) go on the heap because we don't know at creation time how long they are going to last. In many languages the heap is garbage collected to find objects (such as the cls1 object) that no longer have any references. In Java, most objects go directly into the heap. In languages like C / C++, structs and classes can often remain on the stack when you're not dealing with pointers. More information can be found here: The difference between stack and heap memory allocation timmurphy.org and here: Creating Objects on the Stack and Heap This article is the source of picture above: Six important .NET concepts: Stack, heap, value types, reference types, boxing, and unboxing - CodeProject but be aware it may contain some inaccuracies. The Stack When you call a function the arguments to that function plus some other overhead is put on the stack. Some info (such as where to go on return) is also stored there. When you declare a variable inside your function, that variable is also allocated on the stack. Deallocating the stack is pretty simple because you always deallocate in the reverse order in which you allocate. Stack stuff is added as you enter functions, the corresponding data is removed as you exit them. This means that you tend to stay within a small region of the stack unless you call lots of functions that call lots of other functions (or create a recursive solution). The Heap The heap is a generic name for where you put the data that you create on the fly. If you don't know how many spaceships your program is going to create, you are likely to use the new (or malloc or equivalent) operator to create each spaceship. This allocation is going to stick around for a while, so it is likely we will free things in a different order than we created them. Thus, the heap is far more complex, because there end up being regions of memory that are unused interleaved with chunks that are - memory gets fragmented. Finding free memory of the size you need is a difficult problem. This is why the heap should be avoided (though it is still often used). Implementation Implementation of both the stack and heap is usually down to the runtime / OS. Often games and other applications that are performance critical create their own memory solutions that grab a large chunk of memory from the heap and then dish it out internally to avoid relying on the OS for memory. This is only practical if your memory usage is quite different from the norm - i.e for games where you load a level in one huge operation and can chuck the whole lot away in another huge operation. Physical location in memory This is less relevant than you think because of a technology called Virtual Memory which makes your program think that you have access to a certain address where the physical data is somewhere else (even on the hard disc!). The addresses you get for the stack are in increasing order as your call tree gets deeper. The addresses for the heap are un-predictable (i.e implimentation specific) and frankly not important. To clarify, this answer has incorrect information (thomas fixed his answer after comments, cool :) ). Other answers just avoid explaining what static allocation means. So I will explain the three main forms of allocation and how they usually relate to the heap, stack, and data segment below. I also will show some examples in both C/C++ and Python to help people understand. "Static" (AKA statically allocated) variables are not allocated on the stack. Do not assume so - many people do only because "static" sounds a lot like "stack". They actually exist in neither the stack nor the heap. The are part of what's called the data segment. However, it is generally better to consider "scope" and "lifetime" rather than "stack" and "heap". Scope refers to what parts of the code can access a variable. Generally we think of local scope (can only be accessed by the current function) versus global scope (can be accessed anywhere) although scope can get much more complex. Lifetime refers to when a variable is allocated and deallocated during program execution. Usually we think of static allocation (variable will persist through the entire duration of the program, making it useful for storing the same information across several function calls) versus automatic allocation (variable only persists during a single call to a function, making it useful for storing information that is only used during your function and can be discarded once you are done) versus dynamic allocation (variables whose duration is defined at runtime, instead of compile time like static or automatic). Although most compilers and interpreters implement this behavior similarly in terms of using stacks, heaps, etc, a compiler may sometimes break these conventions if it wants as long as behavior is correct. For instance, due to optimization a local variable may only exist in a register or be removed entirely, even though most local variables exist in the stack. As has been pointed out in a few comments, you are free to implement a compiler that doesn't even use a stack or a heap, but instead some other storage mechanisms (rarely done, since stacks and heaps are great for this). I will provide some simple annotated C code to illustrate all of this. The best way to learn is to run a program under a debugger and watch the behavior. If you prefer to read python, skip to the end of the answer :) // Statically allocated in the data segment when the program/DLL is first loaded // Deallocated when the program/DLL exits // scope - can be accessed from anywhere in the code int someGlobalVariable; // Statically allocated in the data segment when the program is first loaded // Deallocated when the program/DLL exits // scope - can be accessed from anywhere in this particular code file static int someStaticVariable; // "someArgument" is allocated on the stack each time MyFunction is called // "someArgument" is deallocated when MyFunction returns // scope - can be accessed only within MyFunction() void MyFunction(int someArgument) { // Statically allocated in the data segment when the program is first loaded // Deallocated when the program/DLL exits // scope - can be accessed only within MyFunction() static int someLocalStaticVariable; // Allocated on the stack each time MyFunction is called // Deallocated when MyFunction returns // scope - can be accessed only within MyFunction() int someLocalVariable; // A *pointer* is allocated on the stack each time MyFunction is called // This pointer is deallocated when MyFunction returns // scope - the pointer can be accessed only within MyFunction() int* someDynamicVariable; // This line causes space for an integer to be allocated in the heap // when this line is executed. Note this is not at the beginning of // the call to MyFunction(), like the automatic variables // scope - only code within MyFunction() can access this space // *through this particular variable*. // However, if you pass the address somewhere else, that code // can access it too someDynamicVariable = new int; // This line deallocates the space for the integer in the heap. // If we did not write it, the memory would be "leaked". // Note a fundamental difference between the stack and heap // the heap must be managed. The stack is managed for us. delete someDynamicVariable; // In other cases, instead of deallocating this heap space you // might store the address somewhere more permanent to use later. // Some languages even take care of deallocation for you... but // always it needs to be taken care of at runtime by some mechanism. // When the function returns, someArgument, someLocalVariable // and the pointer someDynamicVariable are deallocated. // The space pointed to by someDynamicVariable was already // deallocated prior to returning. return; } // Note that someGlobalVariable, someStaticVariable and // someLocalStaticVariable continue to exist, and are not // deallocated until the program exits. A particularly poignant example of why it's important to distinguish between lifetime and scope is that a variable can have local scope but static lifetime - for instance, "someLocalStaticVariable" in the code sample above. Such variables can make our common but informal naming habits very confusing. For instance when we say "local" we usually mean "locally scoped automatically allocated variable" and when we say global we usually mean "globally scoped statically allocated variable". Unfortunately when it comes to things like "file scoped statically allocated variables" many people just say... "huh???". Some of the syntax choices in C/C++ exacerbate this problem - for instance many people think global variables are not "static" because of the syntax shown below. int var1; // Has global scope and static allocation static int var2; // Has file scope and static allocation int main() {return 0;} Note that putting the keyword "static" in the declaration above prevents var2 from having global scope. Nevertheless, the global var1 has static allocation. This is not intuitive! For this reason, I try to never use the word "static" when describing scope, and instead say something like "file" or "file limited" scope. However many people use the phrase "static" or "static scope" to describe a variable that can only be accessed from one code file. In the context of lifetime, "static" always means the variable is allocated at program start and deallocated when program exits. Some people think of these concepts as C/C++ specific. They are not. For instance, the Python sample below illustrates all three types of allocation (there are some subtle differences possible in interpreted languages that I won't get into here). from datetime import datetime class Animal: _FavoriteFood = 'Undefined' # _FavoriteFood is statically allocated def PetAnimal(self): curTime = datetime.time(datetime.now()) # curTime is automatically allocatedion print("Thank you for petting me. But it's " + str(curTime) + ", you should feed me. My favorite food is " + self._FavoriteFood) class Cat(Animal): _FavoriteFood = 'tuna' # Note since we override, Cat class has its own statically allocated _FavoriteFood variable, different from Animal's class Dog(Animal): _FavoriteFood = 'steak' # Likewise, the Dog class gets its own static variable. Important to note - this one static variable is shared among all instances of Dog, hence it is not dynamic! if __name__ == "__main__": whiskers = Cat() # Dynamically allocated fido = Dog() # Dynamically allocated rinTinTin = Dog() # Dynamically allocated whiskers.PetAnimal() fido.PetAnimal() rinTinTin.PetAnimal() Dog._FavoriteFood = 'milkbones' whiskers.PetAnimal() fido.PetAnimal() rinTinTin.PetAnimal() # Output is: # Thank you for petting me. But it's 13:05:02.255000, you should feed me. My favorite food is tuna # Thank you for petting me. But it's 13:05:02.255000, you should feed me. My favorite food is steak # Thank you for petting me. But it's 13:05:02.255000, you should feed me. My favorite food is steak # Thank you for petting me. But it's 13:05:02.255000, you should feed me. My favorite food is tuna # Thank you for petting me. But it's 13:05:02.255000, you should feed me. My favorite food is milkbones # Thank you for petting me. But it's 13:05:02.256000, you should feed me. My favorite food is milkbones Others have answered the broad strokes pretty well, so I'll throw in a few details. Stack and heap need not be singular. A common situation in which you have more than one stack is if you have more than one thread in a process. In this case each thread has its own stack. You can also have more than one heap, for example some DLL configurations can result in different DLLs allocating from different heaps, which is why it's generally a bad idea to release memory allocated by a different library. In C you can get the benefit of variable length allocation through the use of alloca, which allocates on the stack, as opposed to alloc, which allocates on the heap. This memory won't survive your return statement, but it's useful for a scratch buffer. Making a huge temporary buffer on Windows that you don't use much of is not free. This is because the compiler will generate a stack probe loop that is called every time your function is entered to make sure the stack exists (because Windows uses a single guard page at the end of your stack to detect when it needs to grow the stack. If you access memory more than one page off the end of the stack you will crash). Example: void myfunction() { char big[10000000]; // Do something that only uses for first 1K of big 99% of the time. } Others have directly answered your question, but when trying to understand the stack and the heap, I think it is helpful to consider the memory layout of a traditional UNIX process (without threads and mmap()-based allocators). The Memory Management Glossary web page has a diagram of this memory layout. The stack and heap are traditionally located at opposite ends of the process's virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with setrlimit(RLIMIT_STACK, ...)). The heap grows when the memory allocator invokes the brk() or sbrk() system call, mapping more pages of physical memory into the process's virtual address space. In systems without virtual memory, such as some embedded systems, the same basic layout often applies, except the stack and heap are fixed in size. However, in other embedded systems (such as those based on Microchip PIC microcontrollers), the program stack is a separate block of memory that is not addressable by data movement instructions, and can only be modified or read indirectly through program flow instructions (call, return, etc.). Other architectures, such as Intel Itanium processors, have multiple stacks. In this sense, the stack is an element of the CPU architecture. I think many other people have given you mostly correct answers on this matter. One detail that has been missed, however, is that the "heap" should in fact probably be called the "free store". The reason for this distinction is that the original free store was implemented with a data structure known as a "binomial heap." For that reason, allocating from early implementations of malloc()/free() was allocation from a heap. However, in this modern day, most free stores are implemented with very elaborate data structures that are not binomial heaps. The stack is a portion of memory that can be manipulated via several key assembly language instructions, such as 'pop' (remove and return a value from the stack) and 'push' (push a value to the stack), but also call (call a subroutine - this pushes the address to return to the stack) and return (return from a subroutine - this pops the address off of the stack and jumps to it). It's the region of memory below the stack pointer register, which can be set as needed. The stack is also used for passing arguments to subroutines, and also for preserving the values in registers before calling subroutines. The heap is a portion of memory that is given to an application by the operating system, typically through a syscall like malloc. On modern OSes this memory is a set of pages that only the calling process has access to. The size of the stack is determined at runtime, and generally does not grow after the program launches. In a C program, the stack needs to be large enough to hold every variable declared within each function. The heap will grow dynamically as needed, but the OS is ultimately making the call (it will often grow the heap by more than the value requested by malloc, so that at least some future mallocs won't need to go back to the kernel to get more memory. This behavior is often customizable) Because you've allocated the stack before launching the program, you never need to malloc before you can use the stack, so that's a slight advantage there. In practice, it's very hard to predict what will be fast and what will be slow in modern operating systems that have virtual memory subsystems, because how the pages are implemented and where they are stored is an implementation detail. What is a stack? A stack is a pile of objects, typically one that is neatly arranged. Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out manner. In a multi-threaded application, each thread will have its own stack. What is a heap? A heap is an untidy collection of things piled up haphazardly. In computing architectures the heap is an area of dynamically-allocated memory that is managed automatically by the operating system or the memory manager library. Memory on the heap is allocated, deallocated, and resized regularly during program execution, and this can lead to a problem called fragmentation. Fragmentation occurs when memory objects are allocated with small spaces in between that are too small to hold additional memory objects. The net result is a percentage of the heap space that is not usable for further memory allocations. Both together In a multi-threaded application, each thread will have its own stack. But, all the different threads will share the heap. Because the different threads share the heap in a multi-threaded application, this also means that there has to be some coordination between the threads so that they don’t try to access and manipulate the same piece(s) of memory in the heap at the same time. Which is faster – the stack or the heap? And why? The stack is much faster than the heap. This is because of the way that memory is allocated on the stack. Allocating memory on the stack is as simple as moving the stack pointer up. For people new to programming, it’s probably a good idea to use the stack since it’s easier. Because the stack is small, you would want to use it when you know exactly how much memory you will need for your data, or if you know the size of your data is very small. It’s better to use the heap when you know that you will need a lot of memory for your data, or you just are not sure how much memory you will need (like with a dynamic array). Java Memory Model The stack is the area of memory where local variables (including method parameters) are stored. When it comes to object variables, these are merely references (pointers) to the actual objects on the heap. Every time an object is instantiated, a chunk of heap memory is set aside to hold the data (state) of that object. Since objects can contain other objects, some of this data can in fact hold references to those nested objects. You can do some interesting things with the stack. For instance, you have functions like alloca (assuming you can get past the copious warnings concerning its use), which is a form of malloc that specifically uses the stack, not the heap, for memory. That said, stack-based memory errors are some of the worst I've experienced. If you use heap memory, and you overstep the bounds of your allocated block, you have a decent chance of triggering a segment fault. (Not 100%: your block may be incidentally contiguous with another that you have previously allocated.) But since variables created on the stack are always contiguous with each other, writing out of bounds can change the value of another variable. I have learned that whenever I feel that my program has stopped obeying the laws of logic, it is probably buffer overflow. Simply, the stack is where local variables get created. Also, every time you call a subroutine the program counter (pointer to the next machine instruction) and any important registers, and sometimes the parameters get pushed on the stack. Then any local variables inside the subroutine are pushed onto the stack (and used from there). When the subroutine finishes, that stuff all gets popped back off the stack. The PC and register data gets and put back where it was as it is popped, so your program can go on its merry way. The heap is the area of memory dynamic memory allocations are made out of (explicit "new" or "allocate" calls). It is a special data structure that can keep track of blocks of memory of varying sizes and their allocation status. In "classic" systems RAM was laid out such that the stack pointer started out at the bottom of memory, the heap pointer started out at the top, and they grew towards each other. If they overlap, you are out of RAM. That doesn't work with modern multi-threaded OSes though. Every thread has to have its own stack, and those can get created dynamicly. From WikiAnwser. Stack When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. This chain of suspended function calls is the stack, because elements in the stack (function calls) depend on each other. The stack is important to consider in exception handling and thread executions. Heap The heap is simply the memory used by programs to store variables. Element of the heap (variables) have no dependencies with each other and can always be accessed randomly at any time. Stack Very fast access Don't have to explicitly de-allocate variables Space is managed efficiently by CPU, memory will not become fragmented Local variables only Limit on stack size (OS-dependent) Variables cannot be resized Heap Variables can be accessed globally No limit on memory size (Relatively) slower access No guaranteed efficient use of space, memory may become fragmented over time as blocks of memory are allocated, then freed You must manage memory (you're in charge of allocating and freeing variables) Variables can be resized using realloc() In the 1980s, UNIX propagated like bunnies with big companies rolling their own. Exxon had one as did dozens of brand names lost to history. How memory was laid out was at the discretion of the many implementors. A typical C program was laid out flat in memory with an opportunity to increase by changing the brk() value. Typically, the HEAP was just below this brk value and increasing brk increased the amount of available heap. The single STACK was typically an area below HEAP which was a tract of memory containing nothing of value until the top of the next fixed block of memory. This next block was often CODE which could be overwritten by stack data in one of the famous hacks of its era. One typical memory block was BSS (a block of zero values) which was accidentally not zeroed in one manufacturer's offering. Another was DATA containing initialized values, including strings and numbers. A third was CODE containing CRT (C runtime), main, functions, and libraries. The advent of virtual memory in UNIX changes many of the constraints. There is no objective reason why these blocks need be contiguous, or fixed in size, or ordered a particular way now. Of course, before UNIX was Multics which didn't suffer from these constraints. Here is a schematic showing one of the memory layouts of that era. Introduction Physical memory is the range of the physical addresses of the memory cells in which an application or system stores its data, code, and so on during execution. Memory management denotes the managing of these physical addresses by swapping the data from physical memory to a storage device and then back to physical memory when needed. The OS implements the memory management services using virtual memory. As a C# application developer you do not need to write any memory management services. The CLR uses the underlying OS memory management services to provide the memory model for C# or any other high-level language targeting the CLR. Figure 4-1 shows physical memory that has been abstracted and managed by the OS, using the virtual memory concept. Virtual memory is the abstract view of the physical memory, managed by the OS. Virtual memory is simply a series of virtual addresses, and these virtual addresses are translated by the CPU into the physical address when needed. Figure 4-1. CLR memory abstraction The CLR provides the memory management abstract layer for the virtual execution environment, using the operating memory services. The abstracted concepts the CLR uses are AppDomain, thread, stack, heapmemorymapped file, and so on. The concept of the application domain (AppDomain) gives your application an isolated execution environment. Memory Interaction between the CLR and OS By looking at the stack trace while debugging the following C# application, using WinDbg, you will see how the CLR uses the underlying OS memory management services (e.g., the HeapFree method from KERNEL32.dll, the RtlpFreeHeap method from ntdll.dll) to implement its own memory model: using System; namespace CH_04 { class Program { static void Main(string[] args) { Book book = new Book(); Console.ReadLine(); } } public class Book { public void Print() { Console.WriteLine(ToString()); } } } The compiled assembly of the program is loaded into WinDbg to start debugging. You use the following commands to initialize the debugging session: 0:000> sxe ld clrjit 0:000> g 0:000> .loadby sos clr 0:000> .load C:\Windows\Microsoft.NET\Framework\v4.0.30319\sos.dll Then, you set a breakpoint at the Main method of the Program class, using the !bpmd command: 0:000>!bpmd CH_04.exe CH_04.Program.Main To continue the execution and break at the breakpoint, execute the g command: 0:000> g When the execution breaks at the breakpoint, you use the !eestack command to view the stack trace details of all threads running for the current process. The following output shows the stack trace for all the threads running for the application CH_04.exe: 0:000> !eestack Thread 0 Current frame: (MethodDesc 00233800 +0 CH_04.Program.Main(System.String[])) ChildEBP RetAddr Caller, Callee 0022ed24 5faf21db clr!CallDescrWorker+0x33 /trace removed/ 0022f218 77712d68 ntdll!RtlFreeHeap+0x142, calling ntdll!RtlpFreeHeap 0022f238 771df1ac KERNEL32!HeapFree+0x14, calling ntdll!RtlFreeHeap 0022f24c 5fb4c036 clr!EEHeapFree+0x36, calling KERNEL32!HeapFree 0022f260 5fb4c09d clr!EEHeapFreeInProcessHeap+0x24, calling clr!EEHeapFree 0022f274 5fb4c06d clr!operator delete[]+0x30, calling clr!EEHeapFreeInProcessHeap /trace removed/ 0022f4d0 7771316f ntdll!RtlpFreeHeap+0xb7a, calling ntdll!_SEH_epilog4 0022f4d4 77712d68 ntdll!RtlFreeHeap+0x142, calling ntdll!RtlpFreeHeap 0022f4f4 771df1ac KERNEL32!HeapFree+0x14, calling ntdll!RtlFreeHeap /trace removed/ This stack trace indicates that the CLR uses OS memory management services to implement its own memory model. Any memory operation in.NET goes via the CLR memory layer to the OS memory management layer. Figure 4-2 illustrates a typical C# application memory model used by the CLR at runtime. Figure 4-2. A typical C# application memory model The CLR memory model is tightly coupled with the OS memory management services. To understand the CLR memory model, it is important to understand the underlying OS memory model. It is also crucial to know how the physical memory address space is abstracted into the virtual memory address space, the ways the virtual address space is being used by the user application and system application, how virtual-to-physical address mapping works, how memory-mapped file works, and so on. This background knowledge will improve your grasp of CLR memory model concepts, including AppDomain, stack, and heap. For more information, refer to this book: C# Deconstructed: Discover how C# works on the .NET Framework This book + ClrViaC# + Windows Internals are excellent resources to known .net framework in depth and relation with OS. In Sort A stack is used for static memory allocation and a heap for dynamic memory allocation, both stored in the computer's RAM. In Detail The Stack The stack is a "LIFO" (last in, first out) data structure, that is managed and optimized by the CPU quite closely. Every time a function declares a new variable, it is "pushed" onto the stack. Then every time a function exits, all of the variables pushed onto the stack by that function, are freed (that is to say, they are deleted). Once a stack variable is freed, that region of memory becomes available for other stack variables. The advantage of using the stack to store variables, is that memory is managed for you. You don't have to allocate memory by hand, or free it once you don't need it any more. What's more, because the CPU organizes stack memory so efficiently, reading from and writing to stack variables is very fast. More can be found here. The Heap The heap is a region of your computer's memory that is not managed automatically for you, and is not as tightly managed by the CPU. It is a more free-floating region of memory (and is larger). To allocate memory on the heap, you must use malloc() or calloc(), which are built-in C functions. Once you have allocated memory on the heap, you are responsible for using free() to deallocate that memory once you don't need it any more. If you fail to do this, your program will have what is known as a memory leak. That is, memory on the heap will still be set aside (and won't be available to other processes). As we will see in the debugging section, there is a tool called Valgrind that can help you detect memory leaks. Unlike the stack, the heap does not have size restrictions on variable size (apart from the obvious physical limitations of your computer). Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap. We will talk about pointers shortly. Unlike the stack, variables created on the heap are accessible by any function, anywhere in your program. Heap variables are essentially global in scope. More can be found here. Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and its allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function, etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer. Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Elements of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time. You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data. In a multi-threaded situation each thread will have its own completely independent stack, but they will share the heap. The stack is thread specific and the heap is application specific. The stack is important to consider in exception handling and thread executions. Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation). At run-time, if the application needs more heap, it can allocate memory from free memory and if the stack needs memory, it can allocate memory from free memory allocated memory for the application. Even, more detail is given here and here. Now come to your question's answers. To what extent are they controlled by the OS or language runtime? The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application. More can be found here. What is their scope? Already given in top. "You can use the stack if you know exactly how much data you need to allocate before compile time, and it is not too big. You can use the heap if you don't know exactly how much data you will need at runtime or if you need to allocate a lot of data." More can be found in here. What determines the size of each of them? The size of the stack is set by OS when a thread is created. The size of the heap is set on application startup, but it can grow as space is needed (the allocator requests more memory from the operating system). What makes one faster? Stack allocation is much faster since all it really does is move the stack pointer. Using memory pools, you can get comparable performance out of heap allocation, but that comes with a slight added complexity and its own headaches. Also, stack vs. heap is not only a performance consideration; it also tells you a lot about the expected lifetime of objects. Details can be found from here. A couple of cents: I think, it will be good to draw memory graphical and more simple: Arrows - show where grow stack and heap, process stack size have limit, defined in OS, thread stack size limits by parameters in thread create API usually. Heap usually limiting by process maximum virtual memory size, for 32 bit 2-4GB for example. So simple way: process heap is general for process and all threads inside, using for memory allocation in common case with something like malloc(). Stack is quick memory for store in common case function return pointers and variables, processed as parameters in function call, local function variables. Since some answers went nitpicking, I'm going to contribute my mite. Surprisingly, no one has mentioned that multiple (i.e. not related to the number of running OS-level threads) call stacks are to be found not only in exotic languages (PostScript) or platforms (Intel Itanium), but also in fibers, green threads and some implementations of coroutines. Fibers, green threads and coroutines are in many ways similar, which leads to much confusion. The difference between fibers and green threads is that the former use cooperative multitasking, while the latter may feature either cooperative or preemptive one (or even both). For the distinction between fibers and coroutines, see here. In any case, the purpose of both fibers, green threads and coroutines is having multiple functions executing concurrently, but not in parallel (see this SO question for the distinction) within a single OS-level thread, transferring control back and forth from one another in an organized fashion. When using fibers, green threads or coroutines, you usually have a separate stack per function. (Technically, not just a stack but a whole context of execution is per function. Most importantly, CPU registers.) For every thread there're as many stacks as there're concurrently running functions, and the thread is switching between executing each function according to the logic of your program. When a function runs to its end, its stack is destroyed. So, the number and lifetimes of stacks are dynamic and are not determined by the number of OS-level threads! Note that I said "usually have a separate stack per function". There're both stackful and stackless implementations of couroutines. Most notable stackful C++ implementations are Boost.Coroutine and Microsoft PPL's async/await. (However, C++'s resumable functions (a.k.a. "async and await"), which were proposed to C++17, are likely to use stackless coroutines.) Fibers proposal to the C++ standard library is forthcoming. Also, there're some third-party libraries. Green threads are extremely popular in languages like Python and Ruby. OK, simply and in short words, they mean ordered and not ordered! Stack: In stack items, things get on the top of each-other, means gonna be faster and more efficient to be processed!... So there is always an index to point the specific item, also processing gonna be faster, there is relationship between the items as well!... Heap: No order, processing gonna be slower and values are messed up together with no specific order or index... there are random and there is no relationship between them... so execution and usage time could be vary... I also create the image below to show how they may look like: stack, heap and data of each process in virtual memory: A lot of answers are correct as concepts, but we must note that a stack is needed by the hardware (i.e. microprocessor) to allow calling subroutines (CALL in assembly language..). (OOP guys will call it methods) On the stack you save return addresses and call → push / ret → pop is managed directly in hardware. You can use the stack to pass parameters.. even if it is slower than using registers (would a microprocessor guru say or a good 1980s BIOS book...) Without stack no microprocessor can work. (we can't imagine a program, even in assembly language, without subroutines/functions) Without the heap it can. (An assembly language program can work without, as the heap is a OS concept, as malloc, that is a OS/Lib call. Stack usage is faster as: Is hardware, and even push/pop are very efficient. malloc requires entering kernel mode, use lock/semaphore (or other synchronization primitives) executing some code and manage some structures needed to keep track of allocation. I have something to share with you, although major points are already penned. Stack Very fast access. Stored in RAM. Function calls are loaded here along with the local variables and function parameters passed. Space is freed automatically when program goes out of a scope. Stored in sequential memory. Heap Slow access comparatively to Stack. Stored in RAM. Dynamically created variables are stored here, which later requires freeing the allocated memory after use. Stored wherever memory allocation is done, accessed by pointer always. Interesting note: Should the function calls had been stored in heap, it would had resulted in 2 messy points: Due to sequential storage in stack, execution is faster. Storage in heap would have resulted in huge time consumption thus resulting whole program to execute slower. If functions were stored in heap (messy storage pointed by pointer), there would have been no way to return to the caller address back (which stack gives due to sequential storage in memory). Feedbacks are wellcomed. The stack is the memory set aside as scratch space for a thread of execution. When a function is called, a block is reserved on the top of the stack for local variables and some bookkeeping data. When that function returns, the block becomes unused and can be used the next time a function is called. The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack; freeing a block from the stack is nothing more than adjusting one pointer. The heap is memory set aside for dynamic allocation. Unlike the stack, there's no enforced pattern to the allocation and deallocation of blocks from the heap; you can allocate a block at any time and free it at any time. This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time; there are many custom heap allocators available to tune heap performance for different usage patterns. Each thread gets a stack, while there's typically only one heap for the application (although it isn't uncommon to have multiple heaps for different types of allocation). To answer your questions directly: To what extent are they controlled by the OS or language runtime? The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application. What is their scope? The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits. What determines the size of each of them? The size of the stack is set when a thread is created. The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system). What makes one faster? The stack is faster because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or deallocation. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor's cache, making it very fast. Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with "all" other heap accesses in the program. A clear demonstration: Image source: vikashazrati.wordpress.com
https://stackoverflow.com/questions/1335851/what-does-use-strict-do-in-javascript-and-what-is-the-reasoning-behind-it	syntax - What does "use strict" do in JavaScript, and what is the reasoning behind it? - Stack Overflow	[votes:6495][favorites:1359]	What does “use strict” do in JavaScript, and what is the reasoning behind it? Recently, I ran some of my JavaScript code through Crockford's JSLint, and it gave the following error: Problem at line 1 character 1: Missing "use strict" statement. Doing some searching, I realized that some people add "use strict"; into their JavaScript code. Once I added the statement, the error stopped appearing. Unfortunately, Google did not reveal much of the history behind this string statement. Certainly it must have something to do with how the JavaScript is interpreted by the browser, but I have no idea what the effect would be. So what is "use strict"; all about, what does it imply, and is it still relevant? Do any of the current browsers respond to the "use strict"; string or is it for future use? javascript syntax jslint use-strict It's a new feature of ECMAScript 5. John Resig wrote up a nice summary of it. It's just a string you put in your JavaScript files (either at the top of your file or inside of a function) that looks like this: "use strict"; Putting it in your code now shouldn't cause any problems with current browsers as it's just a string. It may cause problems with your code in the future if your code violates the pragma. For instance, if you currently have foo = "bar" without defining foo first, your code will start failing...which is a good thing in my opinion. The statement "use strict"; instructs the browser to use the Strict mode, which is a reduced and safer feature set of JavaScript. List of features (non-exhaustive) Disallows global variables. (Catches missing var declarations and typos in variable names) Silent failing assignments will throw error in strict mode (assigning NaN = 5;) Attempts to delete undeletable properties will throw (delete Object.prototype) Requires all property names in an object literal to be unique (var x = {x1: "1", x1: "2"}) Function parameter names must be unique (function sum (x, x) {...}) Forbids octal syntax (var x = 023; some devs assume wrongly that a preceding zero does nothing to change the number.) Forbids the with keyword eval in strict mode does not introduce new variables Forbids deleting plain names (delete x;) Forbids binding or assignment of the names eval and arguments in any form Strict mode does not alias properties of the arguments object with the formal parameters. (i.e. in function sum (a,b) { return arguments[0] + b;} This works because arguments[0] is bound to a and so on. ) arguments.callee is not supported [Ref: Strict mode, Mozilla Developer Network] If people are worried about using use strict it might be worth checking out this article: ECMAScript 5 'Strict mode' support in browsers. What does this mean? NovoGeek.com - Krishna's weblog It talks about browser support, but more importantly how to deal with it safely: function isStrictMode(){ return !this; } /* returns false, since 'this' refers to global object and '!this' becomes false */ function isStrictMode(){ "use strict"; return !this; } /* returns true, since in strict mode the keyword 'this' does not refer to global object, unlike traditional JS. So here, 'this' is 'undefined' and '!this' becomes true. */ A word of caution, all you hard-charging programmers: applying "use strict" to existing code can be hazardous! This thing is not some feel-good, happy-face sticker that you can slap on the code to make it 'better'. With the "use strict" pragma, the browser will suddenly THROW exceptions in random places that it never threw before just because at that spot you are doing something that default/loose JavaScript happily allows but strict JavaScript abhors! You may have strictness violations hiding in seldom used calls in your code that will only throw an exception when they do eventually get run - say, in the production environment that your paying customers use! If you are going to take the plunge, it is a good idea to apply "use strict" alongside comprehensive unit tests and a strictly configured JSHint build task that will give you some confidence that there is no dark corner of your module that will blow up horribly just because you've turned on Strict Mode. Or, hey, here's another option: just don't add "use strict" to any of your legacy code, it's probably safer that way, honestly. DEFINITELY DO NOT add "use strict" to any modules you do not own or maintain, like third party modules. I think even though it is a deadly caged animal, "use strict" can be good stuff, but you have to do it right. The best time to go strict is when your project is greenfield and you are starting from scratch. Configure JSHint/JSLint with all the warnings and options cranked up as tight as your team can stomach, get a good build/test/assert system du jour rigged like Grunt+Karma+Chai, and only THEN start marking all your new modules as "use strict". Be prepared to cure lots of niggly errors and warnings. Make sure everyone understands the gravity by configuring the build to FAIL if JSHint/JSLint produces any violations. My project was not a greenfield project when I adopted "use strict". As a result, my IDE is full of red marks because I don't have "use strict" on half my modules, and JSHint complains about that. It's a reminder to me about what refactoring I should do in the future. My goal is to be red mark free due to all of my missing "use strict" statements, but that is years away now. I strongly recommend every developer to start using strict mode now. There are enough browsers supporting it that strict mode will legitimately help save us from errors we didn’t even know were in your code. Apparently, at the initial stage there will be errors we have never encountered before. To get the full benefit, we need to do proper testing after switching to strict mode to make sure we have caught everything. Definitely we don’t just throw use strict in our code and assume there are no errors. So the churn is that it’s time to start using this incredibly useful language feature to write better code. For example, var person = { name : 'xyz', position : 'abc', fullname : function () { "use strict"; return this.name; } }; JSLint is a debugger written by Douglas Crockford. Simply paste in your script, and it’ll quickly scan for any noticeable issues and errors in your code. Using 'use strict'; does not suddenly make your code better. The JavaScript strict mode is a feature in ECMAScript 5. You can enable the strict mode by declaring this in the top of your script/function. 'use strict'; When a JavaScript engine sees this directive, it will start to interpret the code in a special mode. In this mode, errors are thrown up when certain coding practices that could end up being potential bugs are detected (which is the reasoning behind the strict mode). Consider this example: var a = 365; var b = 030; In their obsession to line up the numeric literals, the developer has inadvertently initialized variable b with an octal literal. Non-strict mode will interpret this as a numeric literal with value 24 (in base 10). However, strict mode will throw an error. For a non-exhaustive list of specialties in strict mode, see this answer. Where should I use 'use strict';? In my new JavaScript application: Absolutely! Strict mode can be used as a whistleblower when you are doing something stupid with your code. In my existing JavaScript code: Probably not! If your existing JavaScript code has statements that are prohibited in strict-mode, the application will simply break. If you want strict mode, you should be prepared to debug and correct your existing code. This is why using 'use strict'; does not suddenly make your code better. How do I use strict mode? Insert a 'use strict'; statement on top of your script: // File: myscript.js 'use strict'; var a = 2; .... Note that everything in the file myscript.js will be interpreted in strict mode. Or, insert a 'use strict'; statement on top of your function body: function doSomething() { 'use strict'; ... } Everything in the lexical scope of function doSomething will be interpreted in strict mode. The word lexical scope is important here. See this answer for a better explanation. What things are prohibited in strict mode? I found a nice article describing several things that are prohibited in strict mode (note that this is not an exclusive list): Scope Historically, JavaScript has been confused about how functions are scoped. Sometimes they seem to be statically scoped, but some features make them behave like they are dynamically scoped. This is confusing, making programs difficult to read and understand. Misunderstanding causes bugs. It also is a problem for performance. Static scoping would permit variable binding to happen at compile time, but the requirement for dynamic scope means the binding must be deferred to runtime, which comes with a significant performance penalty. Strict mode requires that all variable binding be done statically. That means that the features that previously required dynamic binding must be eliminated or modified. Specifically, the with statement is eliminated, and the eval function’s ability to tamper with the environment of its caller is severely restricted. One of the benefits of strict code is that tools like YUI Compressor can do a better job when processing it. Implied Global Variables JavaScript has implied global variables. If you do not explicitly declare a variable, a global variable is implicitly declared for you. This makes programming easier for beginners because they can neglect some of their basic housekeeping chores. But it makes the management of larger programs much more difficult and it significantly degrades reliability. So in strict mode, implied global variables are no longer created. You should explicitly declare all of your variables. Global Leakage There are a number of situations that could cause this to be bound to the global object. For example, if you forget to provide the new prefix when calling a constructor function, the constructor's this will be bound unexpectedly to the global object, so instead of initializing a new object, it will instead be silently tampering with global variables. In these situations, strict mode will instead bind this to undefined, which will cause the constructor to throw an exception instead, allowing the error to be detected much sooner. Noisy Failure JavaScript has always had read-only properties, but you could not create them yourself until ES5’s Object.createProperty function exposed that capability. If you attempted to assign a value to a read-only property, it would fail silently. The assignment would not change the property’s value, but your program would proceed as though it had. This is an integrity hazard that can cause programs to go into an inconsistent state. In strict mode, attempting to change a read-only property will throw an exception. Octal The octal (or base 8) representation of numbers was extremely useful when doing machine-level programming on machines whose word sizes were a multiple of 3. You needed octal when working with the CDC 6600 mainframe, which had a word size of 60 bits. If you could read octal, you could look at a word as 20 digits. Two digits represented the op code, and one digit identified one of 8 registers. During the slow transition from machine codes to high level languages, it was thought to be useful to provide octal forms in programming languages. In C, an extremely unfortunate representation of octalness was selected: Leading zero. So in C, 0100 means 64, not 100, and 08 is an error, not 8. Even more unfortunately, this anachronism has been copied into nearly all modern languages, including JavaScript, where it is only used to create errors. It has no other purpose. So in strict mode, octal forms are no longer allowed. Et cetera The arguments pseudo array becomes a little bit more array-like in ES5. In strict mode, it loses its callee and caller properties. This makes it possible to pass your arguments to untrusted code without giving up a lot of confidential context. Also, the arguments property of functions is eliminated. In strict mode, duplicate keys in a function literal will produce a syntax error. A function can’t have two parameters with the same name. A function can’t have a variable with the same name as one of its parameters. A function can’t delete its own variables. An attempt to delete a non-configurable property now throws an exception. Primitive values are not implicitly wrapped. Reserved words for future JavaScript versions ECMAScript 5 adds a list of reserved words. If you use them as variables or arguments, strict mode will throw an error. The reserved words are: implements, interface, let, package, private, protected, public, static, and yield Further Reading Strict Mode - JavaScript | MDN Browser support for strict mode Transitioning to strict mode I would like to offer a somewhat more founded answer complementing the other answers. I was hoping to edit the most popular answer, but failed. I tried to make it as comprehensive and complete as I could. You can refer to the MDN documentation for more information. "use strict" a directive introduced in ECMAScript 5. Directives are similar to statements, yet different. use strict does not contain key words: The directive is a simple expression statement, which consists of a special string literal (in single or double quotes). JavaScript engines, that do not implement ECMAScript 5, merely see an expression statement without side effects. It is expected that future versions of ECMAScript standards introduce use as a real key word; the quotes would thereby become obsolete. use strict can be used only at the beginning of a script or of a function, i.e. it must precede every other (real) statement. It does not have to be the first instruction in a script of function: it can be preceded by other statement expressions that consist of string literals ( and JavaScript implementations can treat them as implementation specific directives). String literals statements, which follow a first real statement (in a script or function) are simple expression statements. Interpreters must not interpret them as directives and they have no effect. The use strict directive indicates that the following code (in a script or a function) is strict code. The code in the highest level of a script (code that is not in a function) is considered strict code when the script contains a use strict directive. The content of a function is considered strict code when the function itself is defined in a strict code or when the function contains a use strict directive. Code that is passed to an eval() method is considered strict code when eval() was called from a strict code or contains the use strict directive itself. The strict mode of ECMAScript 5 is a restricted subset of the JavaScript language, which eliminates relevant deficits of the language and features more stringent error checking and higher security. The following lists the differences between strict mode and normal mode (of which the first three are particularly important): You cannot use the with-statement in strict mode. In strict mode all variables have to be declared: if you assign a value to an identifier that has not been declared as variable, function, function parameter, catch-clause parameter or property of the global Object, then you will get a ReferenceError. In normal mode the identifier is implicitly declared as a global variable (as a property of the global Object) In strict mode the keyword this has the value undefined in functions that were invoked as functions (not as methods). (In normal mode this always points to the global Object). This difference can be used to test if an implementation supports the strict mode: var hasStrictMode = (function() { "use strict"; return this===undefined }()); Also when a function is invoked with call() or apply in strict mode, then this is exactly the value of the first argument of the call()or apply() invocation. (In normal mode null and undefined are replaced by the global Object and values, which are not objects, are cast into objects.) In strict mode you will get a TypeError, when you try to assign to readonly properties or to define new properties for a non extensible object. (In normal mode both simply fail without error message.) In strict mode, when passing code to eval(), you cannot declare or define variables or functions in the scope of the caller (as you can do it in normal mode). Instead, a new scope is created for eval() and the variables and functions are within that scope. That scope is destroyed after eval() finishes execution. In strict mode the arguments-object of a function contains a static copy of the values, which are passed to that function. In normal mode the arguments-object has a somewhat "magical" behaviour: The elements of the array and the named function parameters reference both the same value. In strict mode you will get a SyntaxError when the delete operator is followed by a non qualified identifier (a variable, function or function parameter). In normal mode the delete expression would do nothing and is evaluated to false. In strict mode you will get a TypeError when you try to delete a non configurable property. (In normal mode the attempt simply fails and the delete expression is evaluated to false). In strict mode it is considered a syntactical error when you try to define several properties with the same name for an object literal. (In normal mode there is no error.) In strict mode it is considered a syntactical error when a function declaration has multiple parameters with the same name. (In normal mode there is no error.) In strict mode octal literals are not allowed (these are literals that start with 0x. (In normal mode some implementations do allow octal literals.) In strict mode the identifiers eval and arguments are treated like keywords. You cannot change their value, cannot assign a value to them, and you cannot use them as names for variables, functions, function parameters or identifiers of a catch block. In strict mode are more restrictions on the possibilities to examine the call stack. arguments.caller and arguments.callee cause a TypeError in a function in strict mode. Furthermore, some caller- and arguments properties of functions in strict mode cause a TypeError when you try to read them. My two cents: One of the goals of strict mode is to allow for faster debugging of issues. It helps the developers by throwing exception when certain wrong things occur that can cause silent & strange behaviour of your webpage. The moment we use use strict, the code will throw out errors which helps developer to fix it in advance. Few important things which I have learned after using use strict : Prevents Global Variable Declaration: var tree1Data = { name: 'Banana Tree',age: 100,leafCount: 100000}; function Tree(typeOfTree) { var age; var leafCount; age = typeOfTree.age; leafCount = typeOfTree.leafCount; nameoftree = typeOfTree.name; }; var tree1 = new Tree(tree1Data); console.log(window); Now,this code creates nameoftree in global scope which could be accessed using window.nameoftree. When we implement use strict the code would throw error. Uncaught ReferenceError: nameoftree is not defined Sample Eliminates with statement : with statements can't be minified using tools like uglify-js. They're also deprecated and removed from future JavaScript versions. Sample Prevents Duplicates : When we have duplicate property, it throws an exception Uncaught SyntaxError: Duplicate data property in object literal not allowed in strict mode "use strict"; var tree1Data = { name: 'Banana Tree', age: 100, leafCount: 100000, name:'Banana Tree' }; There are few more but I need to gain more knowledge on that. If you use a browser released in the last year or so then it most likely supports JavaScript Strict mode. Only older browsers around before ECMAScript 5 became the current standard don't support it. The quotes around the command make sure that the code will still work in older browsers as well (although the things that generate a syntax error in strict mode will generally just cause the script to malfunction in some hard to detect way in those older browsers). Strict mode makes several changes to normal JavaScript semantics: eliminates some JavaScript silent errors by changing them to throw errors. fixes mistakes that make it difficult for JavaScript engines to perform optimizations. prohibits some syntax likely to be defined in future versions of ECMAScript. for more information vistit Strict Mode- Javascript "Use Strict"; is an insurance that programmer will not use the loose or the bad properties of JavaScript. It is a guide, just like a ruler will help you make straight lines. "Use Strict" will help you do "Straight coding". Those that prefer not to use rulers to do their lines straight usually end up in those pages asking for others to debug their code. Believe me. The overhead is negligible compared to poorly designed code. Doug Crockford, who has been a senior JavaScript developer for several years, has a very interesting post here. Personally, I like to return to his site all the time to make sure I don't forget my good practice. Modern JavaScript practice should always evoke the "Use Strict"; pragma. The only reason that the ECMA Group has made the "Strict" mode optional is to permit less experienced coders access to JavaScript and give then time to adapt to the new and safer coding practices. Including use strict in the beginning of your all sensitive JavaScript files from this point is a small way to be a better JavaScript programmer and avoid random variables becoming global and things change silently. When adding "use strict";, the following cases will throw a SyntaxError before the script is executing: Paving the way for future ECMAScript versions, using one of the newly reserved keywords (in prevision for ECMAScript 6): implements, interface, let, package, private, protected, public, static, and yield. Declaring function in blocks if(a<b){ function f(){} } Octal syntax var n = 023; this point to the global object. function f() { "use strict"; this.a = 1; }; f(); Declaring twice the same name for a property name in an object literal {a: 1, b: 3, a: 7} This is no longer the case in ECMAScript 6 (bug 1041128). Declaring two function arguments with the same name function f(a, b, b){} Setting a value to an undeclared variable function f(x){ "use strict"; var a = 12; b = a + x*35; // error! } f(); Using delete on a variable name delete myVariable; Using eval or arguments as variable or function argument name "use strict"; arguments++; var obj = { set p(arguments) { } }; try { } catch (arguments) { } function arguments() { } Sources: Transitioning to strict mode on MDN Strict mode on MDN JavaScript’s Strict Mode and Why You Should Use It on Colin J. Ihrig's blog (archived version) The "use strict" Directive The "use strict" directive is new in JavaScript 1.8.5 (ECMAScript version 5). It is not a statement, but a literal expression, ignored by earlier versions of JavaScript. The purpose of "use strict" is to indicate that the code should be executed in "strict mode". With strict mode, you can not, for example, use undeclared variables. Why Strict Mode? Strict mode makes it easier to write "secure" JavaScript. Strict mode changes previously accepted "bad syntax" into real errors. As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable. In normal JavaScript, a developer will not receive any error feedback assigning values to non-writable properties. In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error. Please refer to... http://www.w3schools.com/js/js_strict.asp ...to know more There's a good talk by some people who were on the ECMAScript committee: Changes to JavaScript, Part 1: ECMAScript 5" about how incremental use of the "use strict" switch allows JavaScript implementers to clean up a lot of the dangerous features of JavaScript without suddenly breaking every website in the world. Of course it also talks about just what a lot of those misfeatures are (were) and how ECMAScript 5 fixes them. "use strict" makes JavaScript code to run in a strict mode, which basically means everything need to be defined before using them, the main reason for strict mode is avoiding accidental global usages of any undefined methods. Also in strict mode, things run faster, some warning or silents warnings, throw fatal errors, it's better always use it to make a neater code. "use strict" is widely need to be used in ECMA5, in ECMA6 it's part of javascript by default, so don't need to be added if you using ES6. Look at these statements and examples from MDN: The "use strict" Directive The "use strict" directive is new in JavaScript 1.8.5 (ECMAScript version 5). It is not a statement, but a literal expression, ignored by earlier versions of JavaScript. The purpose of "use strict" is to indicate that the code should be executed in "strict mode". With strict mode, you can not, for example, use undeclared variables. Examples of using "use strict": Strict mode for functions: Likewise, to invoke strict mode for a function, put the exact statement "use strict"; (or 'use strict';) in the function's body before any other statements. 1) strict mode in functions function strict() { // Function-level strict mode syntax 'use strict'; function nested() { return 'And so am I!'; } return "Hi! I'm a strict mode function! " + nested(); } function notStrict() { return "I'm not strict."; } console.log(strict(), notStrict()); 2) whole-script strict mode 'use strict'; var v = "Hi! I'm a strict mode script!"; console.log(v); 3) Assignment to a non-writable global 'use strict'; // Assignment to a non-writable global var undefined = 5; // throws a TypeError var Infinity = 5; // throws a TypeError // Assignment to a non-writable property var obj1 = {}; Object.defineProperty(obj1, 'x', { value: 42, writable: false }); obj1.x = 9; // throws a TypeError // Assignment to a getter-only property var obj2 = { get x() { return 17; } }; obj2.x = 5; // throws a TypeError // Assignment to a new property on a non-extensible object var fixed = {}; Object.preventExtensions(fixed); fixed.newProp = 'ohai'; // throws a TypeError For more info, visit this page here Note that use strict was introduced in EcmaScript 5 and was kept since then. Below are the conditions to trigger strict mode in ES6 and ES7: Global code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive (see 14.1.1). Module code is always strict mode code. All parts of a ClassDeclaration or a ClassExpression are strict mode code. Eval code is strict mode code if it begins with a Directive Prologue that contains a Use Strict Directive or if the call to eval is a direct eval (see 12.3.4.1) that is contained in strict mode code. Function code is strict mode code if the associated FunctionDeclaration, FunctionExpression, GeneratorDeclaration, GeneratorExpression, MethodDefinition, or ArrowFunction is contained in strict mode code or if the code that produces the value of the function’s [[ECMAScriptCode]] internal slot begins with a Directive Prologue that contains a Use Strict Directive. Function code that is supplied as the arguments to the built-in Function and Generator constructors is strict mode code if the last argument is a String that when processed is a FunctionBody that begins with a Directive Prologue that contains a Use Strict Directive. use strict is a way to make your code safer, cause you can't use dangerous features which can work not as you expect.And as was writed before it makes code more strict. "use strict"; is the ECMA effort to make JavaScript a little bit more robust. It brings in JS an attempt to make it at least a little "strict" (other languages implement strict rules since the 90s). It actually "forces" JavaScript developers to follow some sort of coding best practices. Still, JavaScript is very fragile. There is no such thing as typed variables, typed methods, etc. I strongly recommend JavaScript developers to learn a more robust language such as Java or ActionScript3, and implement the same best practices in your JavaScript code, it will work better and be easier to debug. Small example to compare: Non-strict mode: for (i of [1,2,3]) console.log(i) // output: // 1 // 2 // 3 Strict mode: 'use strict'; for (i of [1,2,3]) console.log(i) // output: // Uncaught ReferenceError: i is not defined The main reasons why developers should use "use strict" are: Prevents accidental declaration of global variables.Using "use strict()" will make sure that variables are declared with var before use. Eg: function useStrictDemo(){ 'use strict'; //works fine var a = 'No Problem'; //does not work fine and throws error k = "problem" //even this will throw error someObject = {'problem': 'lot of problem'}; } N.B: The "use strict" directive is only recognized at the beginning of a script or a function. The string "arguments" cannot be used as a variable: "use strict"; var arguments = 3.14; // This will cause an error Will restrict uses of keywords as variables. Trying to use them will throw errors. In short will make your code less error prone and in turn will make you write good code. To read more about it you can refer here. Use Strict is used to show common and repeated errors so that it is handled differently , and changes the way java script runs , such changes are : Prevents accidental globals No duplicates Eliminates with Eliminates this coercion Safer eval() Errors for immutables you can also read this article for the details Normally java script does not follow strict rules hence increasing chances of errors. After using "use strict", the java script code should follow strict set of rules as like in other programming languages such as use of terminators, declaration before initialization etc. If "use strict" is used then the code should be written by following a strict set of rules hence decreasing the chances of errors and ambiguities. JavaScript “strict” mode introduces in ECMAScript 5. (function() { "use strict"; your code... })(); writing "use strict"; at the very top of your JS file turns on strict syntax checking. It does the following tasks for us : (i) shows an error if you try to assign to an undeclared variable (ii) stops you from overwriting key JS system libraries (ii) forbids some unsafe or error-prone language features "use strict" also works inside of individual functions. It is always a better practice to include "use strict in your code. Browser Compatibility Issue: The "use" directives are meant to be backwards-compatible. Browsers that donot support them will just see a String literal that isn't referenced further. So, they will pass over it and move on. Just wanted to add some more points. The Reason to Use Strict Mode---> Strict mode makes it easier to write "secure" JavaScript. Strict mode changes previously accepted "bad syntax" into real errors. As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable. In strict mode, any assignment to a non-writable property, a getter-only property, a non-existing property, a non-existing variable, or a non-existing object, will throw an error. The things that will throw errors in Strict Mode Using a variable, without declaring it, is not allowed: "use strict"; x = 3.14; // This will cause an error Objects are variables too. Using an object, without declaring it, is not allowed: "use strict"; x = {p1:10, p2:20}; // This will cause an error Deleting a variable (or object) is not allowed. "use strict"; var x = 3.14; delete x; // This will cause an error For security reasons, eval() is not allowed to create variables in the scope from which it was called: "use strict"; eval ("var x = 2"); alert (x); // This will cause an error In function calls like f(), the this value was the global object. In strict mode, it is now undefined. "use strict" is only recognized at the beginning of a script. This article about Javascript Strict Mode might interest you: John Resig - ECMAScript 5 Strict Mode, JSON, and More To quote some interesting parts: Strict Mode is a new feature in ECMAScript 5 that allows you to place a program, or a function, in a "strict" operating context. This strict context prevents certain actions from being taken and throws more exceptions. And: Strict mode helps out in a couple ways: It catches some common coding bloopers, throwing exceptions. It prevents, or throws errors, when relatively "unsafe" actions are taken (such as gaining access to the global object). It disables features that are confusing or poorly thought out. Also note you can apply "strict mode" to the whole file... Or you can use it only for a specific function (still quoting from John Resig's article): // Non-strict code... (function(){ "use strict"; // Define your library strictly... })(); // Non-strict code... Which might be helpful if you have to mix old and new code ;-) So, I suppose it's a bit like the "use strict" you can use in Perl (hence the name?): it helps you make fewer errors, by detecting more things that could lead to breakages. Currently, it's supported by all major browsers (bar IE 9 and below).
https://github.com/microsoft/vscode	GitHub - Microsoft/vscode: Visual Studio Code	[stargazers:2187][watchers:47539][forks:6411]	README.md Visual Studio Code - Open Source VS Code is a new type of tool that combines the simplicity of a code editor with what developers need for their core edit-build-debug cycle. Code provides comprehensive editing and debugging support, an extensibility model, and lightweight integration with existing tools. VS Code is updated monthly with new features and bug fixes. You can download it for Windows, macOS, and Linux on VS Code's website. To get the latest releases every day, you can install the Insiders version of VS Code. This builds from the master branch and is updated at least daily. The vscode repository is where we do development and there are many ways you can participate in the project, for example: Submit bugs and feature requests and help us verify as they are checked in Review source code changes Review the documentation and make pull requests for anything from typos to new content Contributing If you are interested in fixing issues and contributing directly to the code base, please see the document How to Contribute, which covers the following: How to build and run from source The development workflow, including debugging and running tests Coding Guidelines Submitting pull requests Contributing to translations Please see also our Code of Conduct. Feedback Ask a question on Stack Overflow. Request a new feature on GitHub. Vote for popular feature requests. File a bug in GitHub Issues. Tweet us with other feedback. Related Projects Many of the core components and extensions to Code live in their own repositories on GitHub. For example, the node debug adapter and the mono debug adapter. For a complete list, please see the Related Projects page on our wiki. License Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License.
https://github.com/apple/swift	GitHub - apple/swift: The Swift Programming Language	[stargazers:2642][watchers:43309][forks:6796]	README.md Swift Programming Language Swift Package macOS Ubuntu 14.04 Ubuntu 16.04 Ubuntu 16.10 Welcome to Swift! Swift is a high-performance system programming language. It has a clean and modern syntax, offers seamless access to existing C and Objective-C code and frameworks, and is memory safe by default. Although inspired by Objective-C and many other languages, Swift is not itself a C-derived language. As a complete and independent language, Swift packages core features like flow control, data structures, and functions, with high-level constructs like objects, protocols, closures, and generics. Swift embraces modules, eliminating the need for headers and the code duplication they entail. To learn more about the programming language, visit swift.org. Contributing to Swift Contributions to Swift are welcomed and encouraged! Please see the Contributing to Swift guide. To be a truly great community, Swift.org needs to welcome developers from all walks of life, with different backgrounds, and with a wide range of experience. A diverse and friendly community will have more great ideas, more unique perspectives, and produce more great code. We will work diligently to make the Swift community welcoming to everyone. To give clarity of what is expected of our members, Swift has adopted the code of conduct defined by the Contributor Covenant. This document is used across many open source communities, and we think it articulates our values well. For more, see the Code of Conduct. Getting Started These instructions give the most direct path to a working Swift development environment. To build from source you will need 2 GB of disk space for the source code and over 20 GB of disk space for the build artifacts. A clean build can take multiple hours, but incremental builds will finish much faster. System Requirements macOS, Ubuntu Linux LTS, and the latest Ubuntu Linux release are the current supported host development operating systems. macOS To build for macOS, you need Xcode 9.3. The required version of Xcode changes frequently, and is often a beta release. Check this document or the host information on https://ci.swift.org for the current required version. You will also need CMake and Ninja, which can be installed via a package manager: Homebrew brew install cmake ninja MacPorts sudo port install cmake ninja Instructions for installing CMake and Ninja directly can be found below. Linux For Ubuntu, you'll need the following development dependencies: sudo apt-get install git cmake ninja-build clang python uuid-dev libicu-dev icu-devtools libbsd-dev libedit-dev libxml2-dev libsqlite3-dev swig libpython-dev libncurses5-dev pkg-config libblocksruntime-dev libcurl4-openssl-dev autoconf libtool systemtap-sdt-dev tzdata rsync Note: LLDB currently requires at least swig-1.3.40 but will successfully build with version 2 shipped with Ubuntu. Build instructions for Ubuntu 14.04 LTS can be found here. Getting Sources for Swift and Related Projects First create a directory for all of the Swift sources: mkdir swift-source cd swift-source Note: This is important since update-checkout (see below) checks out repositories next to the Swift source directory. This means that if one clones Swift and has other unrelated repositories, update-checkout may not clone those repositories and will update them instead. Via HTTPS For those checking out sources as read-only, HTTPS works best: git clone https://github.com/apple/swift.git ./swift/utils/update-checkout --clone Via SSH For those who plan on regularly making direct commits, cloning over SSH may provide a better experience (which requires uploading SSH keys to GitHub): git clone git@github.com:apple/swift.git ./swift/utils/update-checkout --clone-with-ssh Building Swift The build-script is a high-level build automation script that supports basic options such as building a Swift-compatible LLDB, building the Swift Package Manager, building for various platforms, running tests after builds, and more. There are two primary build systems to use: Xcode and Ninja. The Xcode build system allows you to work in Xcode, but Ninja is a bit faster and supports more environments. To build using Ninja, run: utils/build-script --release-debuginfo When developing Swift, it helps to build what you're working on in a debug configuration while building the rest of the project with optimizations. Below are some examples of using debug variants: utils/build-script --release-debuginfo --debug-swift # Swift frontend built in debug utils/build-script --release-debuginfo --debug-swift-stdlib # Standard library built in debug utils/build-script --release-debuginfo --debug-swift --force-optimized-typechecker # Swift frontend sans type checker built in debug Limiting the amount of debug code in the compiler has a very large impact on Swift compile times, and in turn the test execution time. If you want to build the entire project in debug, you can run: utils/build-script --debug For documentation of all available arguments, as well as additional usage information, see the inline help: utils/build-script -h Xcode To build using Xcode, specify the --xcode argument on any of the above commands. Xcode can be used to edit the Swift source code, but it is not currently fully supported as a build environment for SDKs other than macOS. The generated Xcode project does not integrate with the test runner, but the tests can be run with the 'check-swift' target. Build Products All of the build products are placed in swift-source/build/${TOOL}-${MODE}/${PRODUCT}-${PLATFORM}/. If macOS Swift with Ninja in DebugAssert mode was built, all of the products would be in swift-source/build/Ninja-DebugAssert/swift-macosx-x86_64/. It helps to save this directory as an environment variable for future use. export SWIFT_BUILD_DIR="~/swift-source/build/Ninja-DebugAssert/swift-macosx-x86_64" Ninja Once the first build has completed, Ninja can perform fast incremental builds of various products. These incremental builds are a big timesaver when developing and debugging. cd ${SWIFT_BUILD_DIR} ninja swift This will build the Swift compiler, but will not rebuild the standard library or any other target. Building the swift-stdlib target as an additional layer of testing from time to time is also a good idea. To build just the standard library, run: ninja swift-stdlib It is always a good idea to do a full build after using update-checkout. Using Xcode To open the Swift project in Xcode, open ${SWIFT_BUILD_DIR}/Swift.xcodeproj. It will auto-create a lot of schemes for all of the available targets. A common debug flow would involve: Select the 'swift' scheme. Pull up the scheme editor (⌘⇧<). Select the 'Arguments' tab and click the '+'. Add the command line options. Close the scheme editor. Build and run. Another option is to change the scheme to "Wait for executable to be launched", then run the build product in Terminal. Build Failures Make sure you are using the correct release of Xcode. If you have changed Xcode versions but still encounter errors that appear to be related to the Xcode version, try passing --rebuild to build-script. When a new version of Xcode is released, you can update your build without recompiling the entire project by passing the --reconfigure option. Make sure all repositories are up to date with the update-checkout command described above. Testing Swift See docs/Testing.md, in particular the section on lit.py. Learning More Be sure to look through the docs directory for more information about the compiler. In particular, the documents titled Debugging the Swift Compiler and Continuous Integration for Swift are very helpful to understand before submitting your first PR. Building Documentation To read the compiler documentation, start by installing the Sphinx documentation generator tool by running the command: easy_install -U Sphinx Once complete, you can build the Swift documentation by changing directory into docs and typing make. This compiles the .rst files in the docs directory into HTML in the docs/_build/html directory. Many of the docs are out of date, but you can see some historical design documents in the docs directory. Another source of documentation is the standard library itself, located in stdlib. Much of the language is actually implemented in the library (including Int), and the standard library gives some examples of what can be expressed today. Build Dependencies CMake CMake is the core infrastructure used to configure builds of Swift and its companion projects; at least version 3.4.3 is required. On macOS, you can download the CMake Binary Distribution, bundled as an application, copy it to /Applications, and add the embedded command line tools to your PATH: export PATH=/Applications/CMake.app/Contents/bin:$PATH On Linux, if you have not already installed Swift's development dependencies, you can download and install the CMake package separately using the following command: sudo apt-get install cmake Ninja Ninja is the current recommended build system for building Swift and is the default configuration generated by CMake. Pre-built packages are available for macOS and Linux distributions. You can also clone Ninja next to the other projects and it will be bootstrapped automatically: Via HTTPS git clone https://github.com/ninja-build/ninja.git && cd ninja git checkout release cat README Via SSH git clone git@github.com:ninja-build/ninja.git && cd ninja git checkout release cat README
https://github.com/Microsoft/vscode	GitHub - Microsoft/vscode: Visual Studio Code	[stargazers:2187][watchers:47539][forks:6411]	README.md Visual Studio Code - Open Source VS Code is a new type of tool that combines the simplicity of a code editor with what developers need for their core edit-build-debug cycle. Code provides comprehensive editing and debugging support, an extensibility model, and lightweight integration with existing tools. VS Code is updated monthly with new features and bug fixes. You can download it for Windows, macOS, and Linux on VS Code's website. To get the latest releases every day, you can install the Insiders version of VS Code. This builds from the master branch and is updated at least daily. The vscode repository is where we do development and there are many ways you can participate in the project, for example: Submit bugs and feature requests and help us verify as they are checked in Review source code changes Review the documentation and make pull requests for anything from typos to new content Contributing If you are interested in fixing issues and contributing directly to the code base, please see the document How to Contribute, which covers the following: How to build and run from source The development workflow, including debugging and running tests Coding Guidelines Submitting pull requests Contributing to translations Please see also our Code of Conduct. Feedback Ask a question on Stack Overflow. Request a new feature on GitHub. Vote for popular feature requests. File a bug in GitHub Issues. Tweet us with other feedback. Related Projects Many of the core components and extensions to Code live in their own repositories on GitHub. For example, the node debug adapter and the mono debug adapter. For a complete list, please see the Related Projects page on our wiki. License Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License.
https://github.com/Microsoft/vscode/blob/master/LICENSE.txt	vscode/LICENSE.txt at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	3 contributors
https://github.com/microsoft/vscode/tree/master	GitHub - Microsoft/vscode: Visual Studio Code	[stargazers:2187][watchers:47539][forks:6411]	README.md Visual Studio Code - Open Source VS Code is a new type of tool that combines the simplicity of a code editor with what developers need for their core edit-build-debug cycle. Code provides comprehensive editing and debugging support, an extensibility model, and lightweight integration with existing tools. VS Code is updated monthly with new features and bug fixes. You can download it for Windows, macOS, and Linux on VS Code's website. To get the latest releases every day, you can install the Insiders version of VS Code. This builds from the master branch and is updated at least daily. The vscode repository is where we do development and there are many ways you can participate in the project, for example: Submit bugs and feature requests and help us verify as they are checked in Review source code changes Review the documentation and make pull requests for anything from typos to new content Contributing If you are interested in fixing issues and contributing directly to the code base, please see the document How to Contribute, which covers the following: How to build and run from source The development workflow, including debugging and running tests Coding Guidelines Submitting pull requests Contributing to translations Please see also our Code of Conduct. Feedback Ask a question on Stack Overflow. Request a new feature on GitHub. Vote for popular feature requests. File a bug in GitHub Issues. Tweet us with other feedback. Related Projects Many of the core components and extensions to Code live in their own repositories on GitHub. For example, the node debug adapter and the mono debug adapter. For a complete list, please see the Related Projects page on our wiki. License Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License.
https://github.com/Microsoft/vscode/tree/master/test	vscode/test at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	README.md Tests Run The best way to run the Code tests is from the terminal. To make development changes to unit tests you need to be running yarn run watch. See Development Workflow for more details. From the vscode folder run: OS X and Linux ./scripts/test.sh Windows scripts\test Debug To debug tests use --debug when running the test script. Also, the set of tests can be reduced with the --run and --runGlob flags. Both require a file path/pattern. Like so: ./scripts/test.sh --debug --runGrep **/extHost*.test.js Coverage The following command will create a coverage folder at the root of the workspace: OS X and Linux ./scripts/test.sh --coverage Windows scripts\test --coverage
https://github.com/Microsoft/vscode/blob/master/CODE_OF_CONDUCT.md	vscode/CODE_OF_CONDUCT.md at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	This project has adopted the Microsoft Open Source Code of Conduct. For more information see the Code of Conduct FAQ or contact opencode@microsoft.com with any additional questions or comments.
https://github.com/Microsoft/vscode/blob/master/CONTRIBUTING.md	vscode/CONTRIBUTING.md at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	Contributing to VS Code Welcome, and thank you for your interest in contributing to VS Code! There are many ways that you can contribute, beyond writing code. The goal of this document is to provide a high-level overview of how you can get involved. Asking Questions Have a question? Rather than opening an issue, please ask away on Stack Overflow using the tag vscode. The active community will be eager to assist you. Your well-worded question will serve as a resource to others searching for help. Providing Feedback Your comments and feedback are welcome, and the development team is available via handful of different channels. See the Feedback Channels wiki page for details about how to share your thoughts. Reporting Issues Have you identified a reproducible problem in VS Code? Have a feature request? We want to hear about it! Here's how you can make reporting your issue as effective as possible. Identify Where to Report The VS Code project is distributed across multiple repositories. Try to file the issue against the correct repository. Check the list of Related Projects if you aren't sure which repo is correct. Can you recreate the issue even after disabling all extensions? If you find the issue is caused by an extension you have installed, please file an issue on the extension's repo directly. Look For an Existing Issue Before you create a new issue, please do a search in open issues to see if the issue or feature request has already been filed. Be sure to scan through the most popular feature requests. If you find your issue already exists, make relevant comments and add your reaction. Use a reaction in place of a "+1" comment: 👍 - upvote 👎 - downvote If you cannot find an existing issue that describes your bug or feature, create a new issue using the guidelines below. Writing Good Bug Reports and Feature Requests File a single issue per problem and feature request. Do not enumerate multiple bugs or feature requests in the same issue. Do not add your issue as a comment to an existing issue unless it's for the identical input. Many issues look similar, but have different causes. The more information you can provide, the more likely someone will be successful reproducing the issue and finding a fix. Please include the following with each issue: Version of VS Code List of extensions that you have installed. Tip: You can easily add the list of extensions by creating the issue using Report Issues from VS Code's Help menu Reproducible steps (1... 2... 3...) that cause the issue What you expected to see, versus what you actually saw Images, animations, or a link to a video showing the issue occuring A code snippet that demonstrates the issue or a link to a code repository the developers can easily pull down to recreate the issue locally Note: Because the developers need to copy and paste the code snippet, including a code snippet as a media file (i.e. .gif) is not sufficient. Errors from the Dev Tools Console (open from the menu: Help > Toggle Developer Tools) Final Checklist Please remember to do the following: Search the issue repository to ensure your report is a new issue Recreate the issue after disabling all extensions Simplify your code around the issue to better isolate the problem Don't feel bad if the developers can't reproduce the issue right away. They will simply ask for more information! Follow Your Issue Once submitted, your report will go into the issue tracking work flow. Be sure to understand what will happen next, so you know what to expect, and how to continue to assist throughout the process. Automated Issue Management We use a bot to help us manage issues. This bot currently: Automatically closes any issue marked needs-more-info if there has been no response in past 7 days. Automatically locks 45 days after they are closed. If you believe the bot got something wrong, please open a new issue and let us know. Contributing Fixes If you are interested in writing code to fix issues, please see How to Contribute in the wiki. Thank You! Your contributions to open source, large or small, make great projects like this possible. Thank you for taking the time to contribute.
https://github.com/Microsoft/vscode/blob/master/README.md	vscode/README.md at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	Visual Studio Code - Open Source VS Code is a new type of tool that combines the simplicity of a code editor with what developers need for their core edit-build-debug cycle. Code provides comprehensive editing and debugging support, an extensibility model, and lightweight integration with existing tools. VS Code is updated monthly with new features and bug fixes. You can download it for Windows, macOS, and Linux on VS Code's website. To get the latest releases every day, you can install the Insiders version of VS Code. This builds from the master branch and is updated at least daily. The vscode repository is where we do development and there are many ways you can participate in the project, for example: Submit bugs and feature requests and help us verify as they are checked in Review source code changes Review the documentation and make pull requests for anything from typos to new content Contributing If you are interested in fixing issues and contributing directly to the code base, please see the document How to Contribute, which covers the following: How to build and run from source The development workflow, including debugging and running tests Coding Guidelines Submitting pull requests Contributing to translations Please see also our Code of Conduct. Feedback Ask a question on Stack Overflow. Request a new feature on GitHub. Vote for popular feature requests. File a bug in GitHub Issues. Tweet us with other feedback. Related Projects Many of the core components and extensions to Code live in their own repositories on GitHub. For example, the node debug adapter and the mono debug adapter. For a complete list, please see the Related Projects page on our wiki. License Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT License.
https://github.com/Microsoft/vscode/blob/master/product.json	vscode/product.json at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	{ "nameShort": "Code - OSS", "nameLong": "Code - OSS", "applicationName": "code-oss", "dataFolderName": ".vscode-oss", "win32MutexName": "vscodeoss", "licenseName": "MIT", "licenseUrl": "https://github.com/Microsoft/vscode/blob/master/LICENSE.txt", "win32DirName": "Microsoft Code OSS", "win32NameVersion": "Microsoft Code OSS", "win32RegValueName": "CodeOSS", "win32AppId": "{{E34003BB-9E10-4501-8C11-BE3FAA83F23F}", "win32x64AppId": "{{D77B7E06-80BA-4137-BCF4-654B95CCEBC5}", "win32AppUserModelId": "Microsoft.CodeOSS", "win32ShellNameShort": "C&ode - OSS", "darwinBundleIdentifier": "com.visualstudio.code.oss", "reportIssueUrl": "https://github.com/Microsoft/vscode/issues/new", "urlProtocol": "code-oss", "extensionAllowedProposedApi": [ "ms-vscode.node-debug", "ms-vscode.node-debug2" ] } Copy lines Copy permalink View git blame Open new issue
https://github.com/Microsoft/vscode/blob/master/tslint.json	vscode/tslint.json at master · Microsoft/vscode · GitHub	[stargazers:2187][watchers:47539][forks:6411]	{ "rulesDirectory": [ "build/lib/tslint" ], "rules": { "no-string-throw": true, "no-unused-expression": true, "no-duplicate-variable": true, "curly": true, "class-name": true, "semicolon": [ true, "always" ], "triple-equals": true, "no-unexternalized-strings": [ true, { "signatures": [ "localize", "nls.localize" ], "keyIndex": 0, "messageIndex": 1 } ], "layering": [ true, { "common": [], "node": [ "common" ], "browser": [ "common" ], "electron-main": [ "common", "node" ], "electron-browser": [ "common", "browser", "node" ] } ], "import-patterns": [ true, // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // !!! Do not relax these rules !!! // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! { // vs/base/common cannot depend on anything else "target": "**/vs/base/common/**", "restrictions": [ "vs/nls", "**/vs/base/common/**" ] }, { // vs/base/test/common contains tests for vs/base/common "target": "**/vs/base/test/common/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/common/**", "**/vs/base/test/common/**" ] }, { // vs/base/browser can only depend on vs/base/common "target": "**/vs/base/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**" ] }, { // vs/base/test/browser contains tests for vs/base/browser "target": "**/vs/base/test/browser/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/{common,browser}/**", "**/vs/base/test/{common,browser}/**" ] }, { "target": "**/vs/base/parts/*/common/**", "restrictions": [ "vs/nls", "**/vs/base/common/**", "**/vs/base/parts/*/common/**" ] }, { "target": "**/vs/base/parts/*/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**" ] }, { "target": "**/vs/platform/*/common/**", "restrictions": [ "vs/nls", "**/vs/base/common/**", "**/vs/base/parts/*/common/**", "**/vs/platform/*/common/**" ] }, { "target": "**/vs/platform/*/test/common/**", "restrictions": [ "assert", "sinon", "vs/nls", "**/vs/base/common/**", "**/vs/platform/*/common/**", "**/vs/platform/*/test/common/**" ] }, { "target": "**/vs/platform/*/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**", "**/vs/platform/*/{common,browser}/**" ] }, { "target": "**/vs/platform/*/test/browser/**", "restrictions": [ "assert", "sinon", "vs/nls", "**/vs/base/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/platform/*/test/{common,browser}/**" ] }, { "target": "**/vs/editor/common/**", "restrictions": [ "vs/nls", "**/vs/base/common/**", "**/vs/base/worker/**", "**/vs/platform/*/common/**", "**/vs/editor/common/**" ] }, { "target": "**/vs/editor/test/common/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/common/**", "**/vs/platform/*/common/**", "**/vs/platform/*/test/common/**", "**/vs/editor/common/**", "**/vs/editor/test/common/**" ] }, { "target": "**/vs/editor/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/editor/{common,browser}/**" ] }, { "target": "**/vs/editor/test/browser/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/platform/*/test/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/test/{common,browser}/**" ] }, { "target": "**/vs/editor/standalone/common/**", "restrictions": [ "vs/nls", "**/vs/base/common/**", "**/vs/platform/*/common/**", "**/vs/editor/common/**", "**/vs/editor/standalone/common/**" ] }, { "target": "**/vs/editor/standalone/test/common/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/common/**", "**/vs/platform/*/common/**", "**/vs/platform/*/test/common/**", "**/vs/editor/common/**", "**/vs/editor/test/common/**" ] }, { "target": "**/vs/editor/standalone/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/contrib/**", "**/vs/editor/standalone/{common,browser}/**" ] }, { "target": "**/vs/editor/standalone/test/browser/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/platform/*/test/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/standalone/{common,browser}/**", "**/vs/editor/test/{common,browser}/**" ] }, { "target": "**/vs/editor/contrib/*/test/**", "restrictions": [ "assert", "vs/nls", "**/vs/base/{common,browser}/**", "**/vs/base/test/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/platform/*/test/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/test/{common,browser}/**", "**/vs/editor/contrib/**" ] }, { "target": "**/vs/editor/contrib/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/contrib/**" ] }, { "target": "**/vs/workbench/common/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/common/**", "**/vs/base/parts/*/common/**", "**/vs/platform/*/common/**", "**/vs/editor/common/**", "**/vs/editor/contrib/*/common/**", "**/vs/workbench/common/**", "**/vs/workbench/services/*/common/**", "assert" ] }, { "target": "**/vs/workbench/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser}/**", "**/vs/base/parts/*/{common,browser}/**", "**/vs/platform/*/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/editor/contrib/**", // editor/contrib is equivalent to /browser/ by convention "**/vs/workbench/{common,browser}/**", "**/vs/workbench/services/*/{common,browser}/**", "assert" ] }, { "target": "**/vs/workbench/workbench.main.ts", "restrictions": [ "**" ] }, { "target": "**/vs/workbench/electron-browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,browser,node,electron-browser}/**", "**/vs/base/parts/*/{common,browser,node,electron-browser}/**", "**/vs/platform/node/**", "**/vs/platform/*/{common,browser,node,electron-browser}/**", "**/vs/editor/{common,browser,node,electron-browser}/**", "**/vs/editor/contrib/**", // editor/contrib is equivalent to /browser/ by convention "**/vs/workbench/{common,browser,node,electron-browser,api}/**", "**/vs/workbench/services/*/{common,browser,node,electron-browser}/**", "*" // node modules ] }, { "target": "**/vs/workbench/node/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/{common,node}/**", "**/vs/base/parts/*/{common,node}/**", "**/vs/platform/node/**", "**/vs/platform/*/{common,node}/**", "**/vs/editor/{common,node}/**", "**/vs/editor/contrib/*/{common,node}/**", "**/vs/workbench/{common,node,api}/**", "**/vs/workbench/services/*/{common,node}/**", "*" // node modules ] }, { "target": "**/vs/workbench/services/**/test/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/**", "**/vs/platform/**", "**/vs/editor/**", "**/vs/workbench/{common,browser,node,electron-browser}/**", "vs/workbench/parts/files/common/editors/fileEditorInput", "**/vs/workbench/services/**", "**/vs/workbench/test/**", "*" // node modules ] }, { "target": "**/vs/workbench/services/**/common/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/**/common/**", "**/vs/platform/**/common/**", "**/vs/editor/common/**", "**/vs/workbench/common/**", "**/vs/workbench/services/**/common/**" ] }, { "target": "**/vs/workbench/services/**/browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/**/{common,browser}/**", "**/vs/platform/**/{common,browser}/**", "**/vs/editor/{common,browser}/**", "**/vs/workbench/{common,browser}/**", "**/vs/workbench/services/**/{common,browser}/**" ] }, { "target": "**/vs/workbench/services/**/node/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/**/{common,node}/**", "**/vs/platform/**/{common,node}/**", "**/vs/editor/{common,node}/**", "**/vs/workbench/{common,node}/**", "**/vs/workbench/services/**/{common,node}/**", "*" // node modules ] }, { "target": "**/vs/workbench/services/**/electron-browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "**/vs/base/**/{common,browser,node,electron-browser}/**", "**/vs/platform/**/{common,browser,node,electron-browser}/**", "**/vs/editor/**", "**/vs/workbench/{common,browser,node,electron-browser,api}/**", "**/vs/workbench/services/**/{common,browser,node,electron-browser}/**", "*" // node modules ] }, { "target": "**/vs/code/electron-browser/**", "restrictions": [ "vs/nls", "vs/css!./**/*", "vs/nls", "**/vs/base/**", "**/vs/platform/**", "**/vs/code/**", "*" // node modules ] }, { "target": "**/vs/code/**", "restrictions": [ "vs/nls", "**/vs/base/**", "**/vs/platform/**", "**/vs/code/**", "*" // node modules ] }, { "target": "**/{node,electron-browser,electron-main,extensions}/**", "restrictions": "**/*" }, { "target": "**/test/smoke/**", "restrictions": [ "**/test/smoke/**", "*" ] }, { "target": "{**/**.test.ts,**/test/**}", "restrictions": "{**/vs/**,assert,sinon,crypto}" }, { "target": "**/{common,browser,workbench}/**", "restrictions": "**/vs/**" } ], "duplicate-imports": true, "translation-remind": true }, "defaultSeverity": "warning" } Copy lines Copy permalink View git blame Open new issue
https://www.tutorialspoint.com/ansible/index.htm	Ansible Tutorial		Previous Page Next Page Ansible Tutorial PDF Version Quick Guide Resources Job Search Discussion Ansible is simple open source IT engine which automates application deployment, intra service orchestration, cloud provisioning and many other IT tools. Audience This tutorial is prepared for the beginners to help them understand the basics of Ansible. It can also help as a guide to engineers. Prerequisites Before you start doing practice with various types of examples given in this tutorial, it is being assumed that you have hands-on experience with running commands into a Linux shell. This will help you the Ansible tasks in a better way. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/angular4/index.htm	Angular 4 Tutorial		Previous Page Next Page Angular 4 Tutorial PDF Version Quick Guide Resources Job Search Discussion Angular 4 is a JavaScript framework for building web applications and apps in JavaScript, html, and TypeScript, which is a superset of JavaScript. Angular provides built-in features for animation, http service, and materials which in turn has features such as auto-complete, navigation, toolbar, menus, etc. The code is written in TypeScript, which compiles to JavaScript and displays the same in the browser. Audience This tutorial is designed for software programmers who want to learn the basics of Angular 4 and its programming concepts in a simple and easy manner. This tutorial will give you enough understanding on the various functionalities of Angular 4 with suitable examples. Prerequisites Before proceeding with this tutorial, you should have a basic understanding of HTML, CSS, JavaScript, TypeScript, and Document Object Model (DOM). Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/d3js/index.htm	D3.js Tutorial		Previous Page Next Page D3.js Tutorial PDF Version Quick Guide Resources Job Search Discussion D3 stands for Data-Driven Documents. D3.js is a JavaScript library for manipulating documents based on data. D3.js is a dynamic, interactive, online data visualizations framework used in a large number of websites. D3.js is written by Mike Bostock, created as a successor to an earlier visualization toolkit called Protovis. This tutorial will give you a complete knowledge on D3.jsframework. This is an introductory tutorial, which covers the basics of Data-Driven Documents and explains how to deal with its various components and sub-components. Audience This tutorial is prepared for professionals who are aspiring to make a career in online data visualization. This tutorial is intended to make you comfortable in getting started with the Data-Driven Documents and its various functions. Prerequisites Before proceeding with the various types of concepts given in this tutorial, it is being assumed that the readers are already aware about what a Framework is. In addition to this, it will be very helpful, if the readers have a sound knowledge on HTML, CSS and JavaScript. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/dcjs/index.htm	DC.js Tutorial		Previous Page Next Page DC.js Tutorial PDF Version Quick Guide Resources Job Search Discussion DC.js is a charting library built on top of D3.js and works natively with crossfilter, which is another popular JavaScript library used to explore millions of records in a short period on the client side. DC.js is a JavaScript library used to make interactive dashboards in JavaScript. This tutorial will give you a complete knowledge on the DC.js framework. This is an introductory tutorial, which covers the basics of DC.js and explains how to deal with its various modules and sub-modules. Audience This tutorial is prepared for professionals who are aspiring to make a career in online data visualization. This tutorial is intended to make you comfortable in getting started with the DC.js framework and its various components. Prerequisites Before proceeding with the various types of concepts given in this tutorial, it is being assumed that the readers are already aware about what a Framework is. In addition to this, it will be very helpful, if the readers have a sound knowledge on HTML, CSS, JavaScript and D3.js. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/logo/index.htm	Logo Tutorial		Previous Page Next Page Logo Tutorial PDF Version Quick Guide Resources Job Search Discussion Logo is a programming language that is easy to learn. It is used for teaching students and children how to program a computer. It was developed to process a list of words. A command is an instruction, which the computer can understand and execute. In principle, the computer only understands very basic commands, which can then be combined to form more complicated instructions. Such a sequence of commands is called a computer program. Writing computer programs is not easy. There are programs which has millions of commands. To keep track of such a complicated program, it is very important to approach the task of writing a program in a structured and well-thought-out manner. This is what we will learn in this Logo programming course. Audience This tutorial is designed for those readers, who seek to understand the basic concepts of writing programs in Logo programming language and how its different commands function. Prerequisites There are no prerequisites for this tutorial, except for a wish to learn how a computer program works. Having basic computer operating knowledge will be an added advantage in understanding this tutorial. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/gson/index.htm	Gson Tutorial		Previous Page Next Page Google Gson Tutorial PDF Version Quick Guide Resources Job Search Discussion Google Gson is an open source, Java-based library developed by Google. It facilitates serialization of Java objects to JSON and vice versa. This tutorial adopts a simple and intuitive way to describe the basic-to-advanced concepts of Google Gson and how to use its APIs. Audience This tutorial will be useful for most Java developers, starting form beginners to experts. After completing this tutorial, we are confident that you will find it easy to use Google Gson in your programs. Prerequisites It is a simple tutorial that any developer with a little exposure to Java programming can easily understand. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/inter_process_communication/index.htm	Inter Process Communication Tutorial		Previous Page Next Page Inter Process Communication Tutorial PDF Version Quick Guide Resources Job Search Discussion Inter Process Communication (IPC) refers to a mechanism, where the operating systems allow various processes to communicate with each other. This involves synchronizing their actions and managing shared data. This tutorial covers a foundational understanding of IPC. Each of the chapters contain related topics with simple and useful examples. Audience This tutorial is designed for beginners who seek to understand the basic concepts of inter process communication and how its different components function. Prerequisites There are no particular prerequisites for this tutorial, however, a sound knowledge of operating systems and its various concepts will be an added advantage in understanding this tutorial. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/openshift/index.htm	OpenShift Tutorial		Previous Page Next Page OpenShift Tutorial PDF Version Quick Guide Resources Job Search Discussion OpenShift is a cloud development Platform as a Service (PaaS) developed by Red Hat. It is an open source development platform, which enables the developers to develop and deploy their applications on cloud infrastructure. It is very helpful in developing cloud-enabled services. This tutorial will help you understand OpenShift and how it can be used in the existing infrastructure. All the examples and code snippets used in this tutorial are tested and working code, which can be simply used in any OpenShift setup by changing the current defined names and variables. Audience This tutorial has been prepared for those who want to understand the features and functionalities of OpenShift and learn how it can help in building cloud-enabled services and applications. After completing this tutorial, readers will be at a moderate level of understanding of OpenShift and its key building block. It will also give a fair idea on how to configure OpenShift in a preconfigured infrastructure and use it. Prerequisites Readers who want to understand and learn OpenShift should have a basic knowledge of Docker and Kubernetes. Readers also need to have some understanding of system administration, infrastructure, and network protocol communication. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/pyspark/index.htm	PySpark Tutorial		Previous Page Next Page PySpark Tutorial PDF Version Quick Guide Resources Job Search Discussion Apache Spark is written in Scala programming language. To support Python with Spark, Apache Spark community released a tool, PySpark. Using PySpark, you can work with RDDs in Python programming language also. It is because of a library called Py4j that they are able to achieve this. This is an introductory tutorial, which covers the basics of Data-Driven Documents and explains how to deal with its various components and sub-components. Audience This tutorial is prepared for those professionals who are aspiring to make a career in programming language and real-time processing framework. This tutorial is intended to make the readers comfortable in getting started with PySpark along with its various modules and submodules. Prerequisites Before proceeding with the various concepts given in this tutorial, it is being assumed that the readers are already aware about what a programming language and a framework is. In addition to this, it will be very helpful, if the readers have a sound knowledge of Apache Spark, Apache Hadoop, Scala Programming Language, Hadoop Distributed File System (HDFS) and Python. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/richfaces/index.htm	RichFaces Tutorial		Previous Page Next Page RichFaces Tutorial PDF Version Quick Guide Resources Job Search Discussion RichFaces is a component library developed by JBoss, which provides in-built AJAX support to JSF application. It reduces all the redundant codes that the developer has to write to create different markup in the browsers. Audience This tutorial has been prepared for the beginners to help them understand the basics of RichFaces Technology. After completing this tutorial, you will find yourself at a moderate level of expertise, from where you can take yourself to the next levels. Prerequisites Before proceeding with this tutorial, you should have a basic understanding of Java programming language, text editor, execution of programs, etc. Since we are going to develop web-based applications using RichFaces, it will be a plus if you have an understanding of other web technologies such as HTML, CSS, AJAX, JavaScript, and JSF. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.tutorialspoint.com/springbootcli/index.htm	Spring Boot CLI Tutorial		Previous Page Next Page Spring Boot CLI Tutorial PDF Version Quick Guide Resources Job Search Discussion The Spring Boot CLI is a command line tool which is used to quickly develop with Spring. It allows to run Groovy scripts. Groovy scripts are similar to java code without any boilerplate code. Spring CLI helps to bootstrap a new project or write custom command for it. Audience This tutorial will be useful for most Java developers, starting from beginners to experts. After completing this tutorial, you will find yourself at a moderate level of expertise in Spring Boot CLI, from where you can take yourself to next levels. Prerequisites Knowledge of basic Java programming language and Spring Spring Tutorial is the only prerequisite for learning the concepts explained in this tutorial. Previous Page Print Next Page Advertisements googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
https://www.geeksforgeeks.org	GeeksforGeeks | A computer science portal for geeks		Featured Article AA trees are the variation of the red-black trees, a form of binary search tree. AA trees use the concept of levels to aid in… Read More Featured Article In mathematics, Bertrand’s Postulate states that there is a prime number in the range to where n is a natural number and n >= 4.… Read More Featured Article An array is given of n length, and we need to calculate the next greater element for each element in given array. If next greater… Read More I applied for Tracxn online. After few days got a call from the HR asking about my CTC and notice period. HR told me that… Read More Given two positive integers a and b, task is to find the number of digits in a^b (a raised to the power b). Example: Input:… Read More Differences between MongoDb and MySQL on various parameters are discussed below: What are MongoDB and MySQL? MongoDB MySQL MongoDB is an open-source database developed by… Read More Python’s UUID class defines four functions and each generates different version of UUIDs. Let’s see how to generate UUID based on MD5 and SHA-1 hash… Read More Prerequisite – File Systems Hierarchical Directory Systems – Directory is maintained in the form of a tree.Each user can have as many directories as are… Read More Requirements elicitation is perhaps the most difficult, most error-prone and most communication intensive software development. It can be successful only through an effective customer-developer partnership.… Read More The basic computer has 16 bit instruction register (IR) which can denote either memory reference or register reference or input-output instruction. Memory Reference – These… Read More New date-time API is introduced in Java 8 to overcome the following drawbacks of old date-time API : Not thread safe : Unlike old java.util.Date… Read More Given an array of n elements, the task is to find the fibonacci sum of a subset of the array where every element of the… Read More Given a number ‘n’, check whether it is an emirpimes or not. An emirpimes(“semiprime” when spelled backwards) derives its definition from the way it is… Read More In earlier post Restoring Division learned about restoring division. Now, here perform Non-Restoring division, it is less complex than the restoring one because simpler operation… Read More The word Steganography is derived from two Greek words- ‘stegos’ meaning ‘to cover’ and ‘grayfia’, meaning ‘writing’, thus translating to ‘covered writing’, or ‘hidden writing’.… Read More Prerequisite – Prototyping Model The Prototyping model is also a popular software development life cycle model. The prototyping model can be considered to be an… Read More Given an array of N integers, the task is to perform the following two queries: query(start, end) : Print the number of prime numbers in… Read More Given a string that contains only the following => ‘{‘, ‘}’, ‘(‘, ‘)’, ‘[’, ‘]’. At some places there is ‘X’ in place of any… Read More
https://www.geeksforgeeks.org/c-programming-language/	C Programming Language - GeeksforGeeks		C Programming Language Recent Articles on C ! Basics, Variable Declaration, Definition and Scope, Data Types, Storage Classes, Input/Output, Operators, Preprocessor, Array & Strings, Control Statements, Functions, Pointers, Enum, Struct and Union, Memory Management, File Handling, Puzzles, Misc, C Language Interview Questions, Multiple Choice Questions Basics: C Language Introduction C Programming Language Standard Is it fine to write “void main()” or “main()” in C/C++? Difference between “int main()” and “int main(void)” in C/C++? Macros and Preprocessors in C Compiling a C program:- Behind the Scenes Benefits of C over other languages Escape sequences in C Line Slicing in C C/ C++ Tokens Variable Declaration, Definition and Scope: Variables and Keywords in C How are variables scoped in C – Static or Dynamic? Scope rules in C How Linkers Resolve Multiply Defined Global Symbols? Quiz on Variable Declaration and Scope Complicated declarations in C Redeclaration of global variable in C Internal and External Linkage Declare variable as constant Why variables doesn’t start with numbers Redeclaration of global variables Initialization of global and static variables Data Types: (adsbygoogle = window.adsbygoogle || []).push({}); Data Types in C Use of bool in C Integer Promotions in C Quiz on Data Types in C Comparison of a float with a value in C Need of long data type in C size_t data type in C Interesting facts about data-types and modifiers Float and Double in C Character arithmetic in C Typecasting in C Storage Classes: Storage Classes in C Static Variables in C Understanding “extern” keyword in C What are the default values of static variables in C? Understanding “volatile” qualifier in C Const Qualifier in C Initialization of static variables in C Understanding “register” keyword in C Quiz on Storage Classes in C Understanding volatile qualifier in C- Set 1 Input/Output: Returned values of printf() and scanf() What is return type of getchar(), fgetc() and getc() ? Scansets in C puts() vs printf() for printing a string What is use of %n in printf() ? How to print % using printf()? Quiz on Input Output in C Difference between printf, sprintf and fprintf? Difference between getc(), getchar(), getch() and getche() Difference between %d and %i format specifier Use of fflush(stdin) in C Clearing input buffer in C/C++ scanf() and fscanf() in C getchar_unlocked() in C Problem with scanf() Differentiate printable and control character rand() and srand() in C/C++ Operators: Introduction to operators in C and Arithmetic Operators Relational and Logical Operators in C Bitwise Operators in C Operator Precedence and Associativity in C Evaluation order of operands Comma in C and C++ sizeof operator in C Operands for sizeof operator A comma operator question Result of comma operator as l-value in C and C++ Order of operands for logical operators Increment (Decrement) operators require L-value Expression Precedence of postfix ++ and prefix ++ in C/C++ Modulus on Negative Numbers C/C++ Ternary Operator – Some Interesting Observations Pre-increment (or pre-decrement) in C++ Difference between ++*p, *p++ and *++p Results of comparison operations in C and C++ To find sum of two numbers without using any operator Sequence Points in C Execution of printf with ++ operators Anything written in sizeof() is never executed Difference between strlen() and sizeof() Stringizing and Token-pasting operator Preprocessor: Write a C macro PRINT(x) which prints x Variable length arguments for Macros Multiline macros in C CRASH() macro – interpretation The OFFSETOF() macro, Branch prediction macros in GCC Diffference between #define and const in C? A C Programming Language Puzzle What’s difference between header files “stdio.h” and “stdlib.h” ? How to print a variable name in C? Constants in C How a Preprocessor works Preprocessor Directives : Behind the scene-1 Preprocessor Directives : Behind the scene-2 isgraph() library function write your own header file in C difftime() library function tmpnam() library function _Generic keyword in C math.h library functions typedef versus #define in C strftime() library function exec family of functions Arrays & Strings: Introduction to Arrays in C Language Strings in C Language Properties of array in C Language Do not use sizeof for array parameters Initialization of variables sized arrays in C Are array members deeply copied? What is the difference between single quoted and double quoted declaration of char array? Initialization of a multidimensional arrays in C/C++ Write one line functions for strcat() and strcmp() What’s difference between char s[] and char *s in C gets() is risky to use! C function to Swap strings, Storage for Strings in C Difference between array and pointer How to dynamically allocate a 2D array in C? How to pass a 2D array as a parameter in C? How to write long strings in Multi-lines C/C++? What are the data types for which it is not possible to create an array? Variable Length Arrays in C and C++ Short hand array notation Accessing array out of bounds strcpy() in C/C++ strcmp() in C/C++ strdup() and strdndup() in C/C++ Pass an array by value Reverse a string in C/C++ strpbrk() in C strcoll() in C/C++ ispunct() in C strspn() in C isalpha() and isdigit() in C/C++ Control Statements: What should be data type of case labels of switch statement in C? For Versus While A nested loop puzzle switch statement in C Difference between while(1) and while(0) goto statement Continue Statement Break Statement Using range in switch case Functions: Functions in C Importance of function prototype in C Functions that are executed before and after main() in C return statement vs exit() in main() How to Count Variable Numbers of Arguments in C?, What is evaluation order of function parameters in C? Does C support function overloading? How can we return multiple values from a function? What is the purpose of a function prototype? Static functions in C exit(), abort() and assert() Implicit return type int in C What happens when a function is called before its declaration in C? _Noreturn function specifier in C exit() vs _Exit() __func__ identifier in C Callback function in C Nested functions in C Parameter Passing Techniques pow() function in C Pointers: Introduction to pointers in C and C++ Double Pointer (Pointer to Pointer) in C Why C treats array parameters as pointers? Output of the program | Dereference, Reference, Dereference, Reference Dangling, Void , Null and Wild Pointers An Uncommon representation of array elements How to declare a pointer to a function? Pointer vs Array in C void pointer in C NULL pointer in C ! Function Pointer in C near, far and huge pointers Generic Linked List in C restrict keyword in C const char *p, char * const p and const char * const p Pointer to an Array Enum, Struct and Union: Enum in C Structures in C Union in C Struct Hack Structure Member Alignment, Padding and Data Packing Operations on struct variables in C Bit Fields in C Structure Sorting (By Multiple Rules) in C++ Flexible array members in structure Difference between Structure and Union Difference between C structures and C++ structures Anonymous Union and Structure in C Compound Literals in C Memory Management: Memory Layout of C Programs, How to deallocate memory without using free() in C? calloc() versus malloc() How does free() know the size of memory to be deallocated? Use of realloc() What is Memory Leak? How can we avoid? File Handling: fseek() vs rewind() in C EOF, getc() and feof() in C fopen() for an existing file in write mode Read/Write structure to a file fgets() and gets() in C Basics of File Handling fsetpos() in C rename function in C/C++ tmpfile() function in C fgetc() and fputc() in C fseek() in C/C++ ftell() in C lseek() in C/C++ remove function in C/C++ Merge contents of two files into a third file Print contents of file in C Puzzles: C Program to print numbers from 1 to N without using semicolon? How to find sum of two numbers without using any operator How will you show memory representation of C variables? Condition To Print “HelloWord” Change/add only one character and print ‘*’ exactly 20 times How can we sum the digits of a given number in single statement? What is the best way in C to convert a number to a string? Calculate Logn in one line Print “Even” or “Odd” without using Conditional statement How will you print numbers from 1 to 100 without using loop? How can we sum the digits of a given number in single statement? How will you print “Geeks for Geeks” without using a semicolon Write a one line C function to round floating point numbers How will implement Your Own sizeof How to count set bits in a floating point number in C? How to change the output of printf() in main() ? How to find length of a string without string.h and loop in C? Implement your own itoa() Write a C program that does not terminate when Ctrl+C is pressed How to measure time taken by a function in C? Print a long int in C using putchar() only Convert a floating point number to string in C How to write a running C code without main()? Write your own memcpy() C program to print characters without using format specifiers C program to print a string without any quote (singe or double) in the program Execute both if and else statements simultaneously Print “Hello World” without using any header file Misc: Quine – A self-reproducing program Complicated declarations in C Use of bool in C Sequence Points in C | Set 1 Optimization Techniques | Set 2 (swapping), ASCII NUL, ASCII 0 (’0?) and Numeric literal 0 Little and Big Endian Mystery, Comparator function of qsort() in C Program to validate an IP address Multithreading in C Assertions in C/C++ fork() in C Interesting Facts in C Programming Precision of floating point numbers in C++ (floor(), ceil(), trunc(), round() and setprecision()) setjump() and longjump() in C nextafter() and nexttoward() in C/C++ pthread_cancel() in C pthread_equal() in C pthread_self() in C Local Labels in C lvalue and rvalue in C Get and set the stack size of thread attribute Difference between fork() and exec() Errors in C/C++ Why is C considered faster than other languages Incompatibilities between C and C++ Convert C/C++ code to assembly language Error Handling in C Executing main() in C/C++ : Behind the scene Hygienic Macros in C Command line arguments in C/C++ scanf(), fscanf(), sscanf(), scanf_s(), fscanf_s(), sscanf_s() Some Interesting Facts in C Programming Database Connectivity using C/C++ Function Interposition in C Macros vs Functions Write your own memcpy() and memmove() C Language Interview Questions Commonly Asked C Programming Interview Questions | Set 1 Commonly Asked C Programming Interview Questions | Set 2 C/C++ Programs Coding Practice Platform (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice
https://www.geeksforgeeks.org/c-plus-plus/	C++ Programming Language - GeeksforGeeks		C++ Programming Language C++ Recent Articles! C++ Multiple Choice Questions Basics, C vs C++, C++ vs Java, Input and Output, Operators, Arrays and Strings, Functions, References and Pointers, Dynamic memory allocation, Object Oriented Programming(OOP),Constructor and Destructor, Function Overloading, Operator Overloading, Virtual Functions, Exception Handling, Namespaces, Standard Template Library (STL), Inheritance, C++ Library, C++ Advanced, C++ in Competitive Programming, Puzzles, Interview Questions, Multiple Choice Questions Basics Setting up C++ Development Environment Writing first C++ program(Practice) void main or main() C++ Data Types(Practice) Basic Input/Output Response on exceeding valid range of data types C++ Preprocessors Operators in C++(Practice) Loops (Practice) Decision Making in C++(Practice) Execute both if and else simultaneously How to compile 32-bit program on 64-bit gcc in C and C++ Switch statement in C++(Practice) Functions in C++(Practice) Arrays in C/C++(Practice) Strings in C++(Practice) Pointers in C++(Practice) References in C++ Introduction to OOP in C++ C vs C++ C program that won’t compile in C++ Undefined Behaviour in C and C++ Name Mangling and extern “C” in C++ void * in C vs C++ Program that produces different results in C and C++ Type difference of character literals in C vs C++ Difference between Structures in C and C++ C++ vs Java (adsbygoogle = window.adsbygoogle || []).push({}); Inheritance in C++ vs Java static keyword in C++ vs Java default virtual behavior in C++ vs Java Exception Handling in C++ vs Java Foreach in C++ vs Java Templates in C++ vs Generics in Java Foreach in C++ vs Java Floating Point Operations & Associativity in C, C++ and Java Input and output I/O Redirection in C++ Clearing The Input Buffer Basic Input/Output(Practice) cout << endl vs cout << “\n” in C++ Problem with scanf() when there is fgets()/gets()/scanf() after it How to use getline() in C++ when there are blank lines in input? scanf() and fscanf() in C – Simple Yet Poweful Using return value of cin to take unknown number of inputs in C++ How to change the output of printf() in main() ? Implementation of a Falling Matrix What does buffer flush means in C++ ? kbhit in C language Code to generate the map of India Operators Operators in C++ Unary operators in C/C++ Conditionally assign a value without using conditional and arithmetic operators Execution of printf with ++ operators Set a variable without using Arithmetic, Relational or Conditional Operator Scope Resolution Operator vs this pointer Pre-increment (or pre-decrement) new and delete operator in C++ CHAR_BIT in C Casting operators| Set 1 (const_cast) Arrays and Strings Arrays in C/C++ Array of Strings Multidimensional arrays in C/C++ Raw string literal Counts of distinct consecutive sub-string of length two Converting string to number and vice-versa Find size of array in C/C++ without using sizeof How to quickly reverse a string in C++? Tokenizing a string in C++ Getline() function and character array Convert string to char array in C++ C++ string class and its applications , Set 2 How to create a dynamic 2D array inside a class in C++ ? Lexicographically next permutation Print size of array parameter Split a string in C/C++, Python and Java Stringstream in C++ and its applications Strchr() function in C/C++ Isspace() in C/C++ and its application to count whitespace characters Char* vs std:string vs char[] in C++ Std::lexicographical_compare() in C++STL Std::string::at in C++ Extract all integers from string in C++ Strchr() function in C++ and its applications Strcat() vs strncat() in C++ Strncat() function in C/C++ Strpbrk() in C strcoll() in C/C++ Std::substr() in C/C++ Functions Functions in C++ Default Arguments C function argument and return values Inline Functions Return from void functions Returning multiple values from a function using Tuple and Pair Function Call Puzzle Functors Ciel and floor functions in C++ Const member functions Pointers and References Pointers in C and C++ What is Array Decay in C++? How can it be prevented? Opaque Pointer References Can references refer to invalid location? Pass arguments by reference or pointer Smart Pointers ‘this’ pointer Type of ‘this’ pointer “delete this” auto_ptr, unique_ptr, shared_ptr and weak_ptr Dangling, Void , Null and Wild Pointers Passing by pointer Vs Passing by Reference NaN in C++ – What is it and how to check for it? nullptr Pointers vs References in C++ Dynamic memory allocation new and delete operator in C++ malloc() vs new delete() and free() Std::get_temporary_buffer in C++ Object Oriented Programming(OOP) Introduction to OOP in C++ Classes and Objects Access Modifiers Inheritance Polymorphism Encapsulation Data Abstraction Structure vs class Can a C++ class have an object of self type? Why is the size of an empty class not zero? Static data members in C++ Some interesting facts about static member functions Friend class and function Local Class Nested Classes Simulating final class Constructor and Destructor Constructors Copy Constructor Destructors Does compiler create default constructor when we write our own? When should we write our own copy constructor? When is copy constructor called? Initialization of data members Use of explicit keyword When do we use Initializer List in? Default Constructors Private Destructor Playing with Destructors Copy elision C++ default constructor | Built-in types When does compiler create a default constructor and copy constructor? Why copy constructor argument should be const in C++? Advanced C++ | Virtual Constructor Advanced C++ | Virtual Copy Constructor Default Constructors When are static objects destroyed? Is it possible to call constructor and destructor explicitly? Function Overloading Function Overloading Functions that can’t be overloaded Function overloading and const keyword Function overloading and return type Does overloading work with Inheritance? Can main() be overloaded Function Overloading and float Operator Overloading Operator Overloading Copy constructor vs assignment operator When should we write our own assignment operator? Operators that cannot be overloaded Conversion Operators Is assignment operator inherited? Default Assignment Operator and References Overloading stream insertion (<<) and extraction (>>) operators Overloading array index operator [] Virtual Functions Virtual Functions and Runtime Polymorphism Default arguments and virtual function Virtual functions in derived classes Can static functions be virtual? Virtual Destructor Virtual Constructor Virtual Copy Constructor RTTI (Run-time type information) Can virtual functions be private? Inline virtual function Pure Virtual Functions and Abstract Classes Pure virtual destructor Exception Handling Exception Handling Basics Stack Unwinding Catching base and derived classes as exceptions Catch block and type conversion Exception handling and object destruction Namespace Namespace in C++ | Set 1 (Introduction) Set 2 (Extending namespace and Unnamed namespace) Namespace in C++ | Set 3 (Accessing, creating header, nesting and aliasing) Inline namespaces and usage of the “using” directive inside namespaces Can namespaces be nested? Standard Template Library (STL) Algorithms Introduction to STL Sorting Searching Containers: Pair (Practice) Vector (Practice) Ways to copy a vector in C++ Sorting 2D Vector in C++ | Set 3 (By number of columns),(Sort in descending order by first and second) Sorting 2D Vector in C++ | Set 2 (In descending order by row and column) 2D vector in C++ with user defined size Vector::clear() and vector::erase() in C++ STL Passing vector to a function in C++ Vector::push_back() and vector::pop_back() in C++ STL Vector::empty() and vector::size() in C++ STL vector::front() and vector::back() in C++ STL vector::front() and vector::back() in C++ STL Sorting 2D Vector in C++ | Set 1 (By row and column), (Sort by first and second) Computing index using pointers returned by STL functions in C++ List List in C++ | Set 2 (Some Useful Functions) Forward List in C++ | Set 1 (Introduction and Important Functions) Forward List in C++ | Set 2 (Manipulating Functions) list::remove() and list::remove_if() in C++ STL list::empty() and list::size() in C++ STL list::front() and list::back() in C++ STL list::pop_front() and list::pop_back() in C++ STL list::push_front() and list::push_back() in C++ STL Dequeue Deque::empty() and deque::size() in C++ STL Deque::pop_front() and deque::pop_back() in C++ STL Deque::clear() and deque::erase() in C++ STL Queue (Practice) Forward_list::front() and forward_list::empty() in C++ STL Queue::front() and queue::back() in C++ STL Forward_list :: remove() and forward_list :: remove_if() in C++ STL Queue::push() and queue::pop() in C++ STL queue::empty() and queue::size() in C++ STL Priority Queue Priority Queue Stack (Practice) Stack::push() and stack::pop() in C++ STL Forward_list :: push_front() and forward_list :: pop_front() in C++ STL Stack::top() in C++ STL Stack::empty() and stack::size() in C++ STL Set (Practice) Count number of unique Triangles using STL | Set 1 (Using set) std::istream_iterator and std::ostream_iterator in C++ STL Std::next_permutation and prev_permutation in C++ Std::stoul and std::stoull in C++ Shuffle vs random_shuffle in C++ Difference between set, multiset, unordered_set, unordered_multiset Check if a key is present in a C++ map or unordered_map Std::stable_partition in C++ Valarray slice selector Std::memchr in C++ Std::strncmp() in C++ Stable_sort() in C++ STL Std::memcmp() in C++ Std::memset in C++ Std::bucket_count and std::bucket_size in unordered_map in C++ Map of pairs in STL Range-based for loop in C++ Std::includes() in C++ STL Std::set_symmetric_difference in C++ Std::sort_heap in C++ Map vs unordered_map in C++ Round() in C++ Modulus of two float or double numbers Multiset Map (Practice) Multimap Heap using STL C++ More: sort() in C++ STL Strand sort Type Inference in C++ (auto and decltype) transform() in C++ STL Variadic function templates in C++ Template Specialization Implementing iterator pattern of a singly linked list Binary Search functions in C++ STL Descending order in Map and Multimap of C++ STL Insertion and Deletion in STL Set C++ Inheritance What all is inherited from parent class in C++? Virtual Functions and Runtime Polymorphism in C++ Multiple Inheritance in C++ What happens when more restrictive access is given to a derived class method in C++? Object Slicing in C++ Hiding of all overloaded methods in base class Inheritance and friendship Simulating final class C++ Library <random> file – generators and distributions Array type manipulation C++ programming and STL facts Sqrt, sqrtl and sqrtf in C++ std::stod, std::stof, std::stold in C++ C program to demonstrate fork() and pipe() Complex numbers in C++ | Set 1 Set 2 Inbuilt library functions for user Input Rename function in C/C++ Chrono valarray class Floating Point Manipulation (fmod(), remainder(), remquo() … in cmath)(Practice) Character Classification: cctype Snprintf() in C library Boost::split in C++ library Modulus of two float or double numbers Is_trivial function in C++ Array sum in C++ STL Div() function in C++ Exit() vs _Exit() in C and C++ Std::none_of in C++ Isprint() in C++ Iscntrl() in C++ and its application to find control characters Std::partition_point in C++ Iterator Invalidation in C++ Fesetround() and fegetround() in C++ and their application Rint(), rintf(), rintl() in C++ Hypot(), hypotf(), hypotl() in C++ Std::gslice | Valarray generalized slice selector std::setbase, std::setw , std::setfill in C++ Strxfrm() in C/C++ Set position with seekg() in C++ language file handling Strstr() in C/C++ Difftime() C library function Socket Programming Precision of floating point numbers in C++ (floor(), ceil(), trunc(), round() and setprecision()) <bit/stdc++.h> header file std::string class in C++ Merge operations using STL in C++ (merge, includes, set_union, set_intersection, set_difference, ..) std::partition in C++ STL Ratio Manipulations in C++ | Set 1 (Arithmetic) , Set 2 (Comparison) numeric header in C++ STL | Set 1 (accumulate() and partial_sum()), Set 2 (adjacent_difference(), inner_product() and iota()) Bind function and placeholders Array class Tuples Regex (Regular Expression) Common Subtleties in Vector STLs Understanding constexpr specifier unordered_multiset and its uses unordered_multimap and its application Populating a vector in C++ using fill() and fill_n() Writing OS Independent Code in C/C++ C Program to display hostname and IP address Database Connectivity using C/C++ C++ bitset and its application unordered_map in STL and its applications unorderd_set in STL and its applications nextafter() and nexttoward() C++ Advanced User Defined Literal Placement new operator Advanced C++ with boost library Copy-and-Swap Idiom Zombie and Orphan Processes Lambda expression C++ | Signal Handling Preventing Object Copy in C++ Command line arguments in C++ C++ in Competitive Programming Writing C/C++ code efficiently in Competitive programming Useful Array algorithms in C++ STL searching in fork() Data Type Ranges and their macros Cin-Cout vs Scanf-Printf getchar_unlocked() – faster input in C/C++ for Competitive Programming C qsort() vs C++ sort() Middle of three using minimum comparisons Check for integer overflow on multiplication Generating Test Cases (generate() and generate_n() Puzzles Can we call an undeclared function in? Can we access global variable if there is a local variable with same name? Can we use function on left side of an expression in C and C++? Can we access private data members of a class without using a member or a friend function? How to make a C++ class whose objects can only be dynamically allocated? How to print “GeeksforGeeks” with empty main() Print 1 to 100, without loop and recursion C/C++ Tricky Programs Print a number 100 times without using loop, recursion and macro expansion in C++ How to restrict dynamic allocation of objects Sum of digits of a number in single statement Write a URL in a C++ program Zoom digits of an integer Composite Design Pattern in C++ Assign value without any control statement Printing pyramid pattern How to swap two variables in one line in C/C++, Python and Java? Program to shut down a computer Interview Questions Commonly Asked C++ Interview Questions | Set 1 Commonly Asked OOP Interview Questions | Set 1 C/C++ Programs (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice
https://www.geeksforgeeks.org/java/	Java Programming Language - GeeksforGeeks		Java Programming Language Recent articles Java Output Questions and MCQ Overview, Basics, OOP concepts, Operators, Strings, Input and Output, Arrays , Arrays Class, Important Keywords in Java ,Java vs C++, Methods in Java, Constructors, Exception Handling, Regular Expressions, Inheritance, Interfaces and Abstract Classes, Java Packages, Multithreading, Garbage Collection,Wrapper Classes, Reflection in Java, File Handling, Collection in Java, Collection Interview FAQ’s ,Collections Class (Contains utility functions on Collections), Useful and/or Advanced Features, Image Processing, Networking in Java, Interview Questions, Misc, Multiple Choice Questions, Java 8 Stream Methods Overview Setting up the environment The Hello World Example(Practice) Java Naming Conventions JVM JVM Stack Area Java Class File Differences between JDK, JRE and JVM Does JVM create object of Main class? Is main method compulsory in Java? File names and class names How to run java class file which is in different directory? Using predefined class name as Class or Variable name in Java Basics Java Identifiers Data types How to define our own data type in java(enum) Variables Scope of Variables Loops in Java(Practice) For-each loop in Java For Loop in Java | Important points Decision Making(if, if-else, switch, break, continue, jump)(Practice) Switch Statement in Java(Practice) String in Switch Case in Java Forward declarations Widening Primitive Conversion Type conversion in Java Comments in Java Does Java support goto? Interesting facts about null in Java Using underscore in Numeric Literals OOP concepts (adsbygoogle = window.adsbygoogle || []).push({}); Classes and Objects Java object storage Different ways to create objects in Java How to swap or exchange objects Inheritance in Java Encapsulation in Java Abstraction in Java Run-time Polymorphism in Java Association,Composition and Aggregation Access and Non Access Modifiers in Java Access Modifiers this reference Method Overloading Output of Java program | Set 22 (Overloading) Method Overriding Output of Java program | Set 18 (Overriding) Shadowing of static methods(Also called Method Hiding) Covariant return types Object class Flexible nature of java.lang.Object Overriding equals method of Object class Overriding toString() method of Object class Instance Variable Hiding initializer block in java(static block) instance initializer block in java(non-static block) Static vs Dynamic Binding Why Java is not a purely Object-Oriented Language? Operators All Operators(Practice) Bitwise right shift operators Java instanceof operator and its applications Autoboxed Integer objects Addition and Concatenation Numeric Promotion in Conditional Expression Strings in Java String Class(Practice) StringBuffer Class Initialize and Compare Strings StringTokenizer class String vs StringBuilder vs StringBuffer StringJoiner in Java8 When to use StringJoiner over StringBuilder? Integer to String Conversions String to Integer– parseInt() Split() String method Swap two Strings without using third variable Searching characters and substring in a String Java String toLowerCase() Reverse a string in Java (5 Different Ways) Remove Trailing Zeros From String in Java Counting number of lines, words, characters and paragraphs in a text file using Java Input and Output Command Line arguments Scanner Class Ways to read input from console in Java Scanner and nextChar() Scanner vs BufferReader Class Formatted output Fast I/O forCompetitive Programming Reading input from console Arrays in Java Arrays in Java(Practice) Default Array values Compare two arrays Final arrays Jagged Array Array IndexOutofbounds Exception Array vs ArrayList in Java ArrayList to Array Conversion Custom ArrayList in Java Arrays Class (Contains utility functions for Arrays) Array class Arrays.toString() List to array in Java Arrays.deepToString() Arrays.equals() Arrays.fill() Arrays.sort() Arrays.copyof() Arrays.binarySearch() –Set 1Set 2 Important Keywords Important Keywords in Java this keyword super Keyword static keyword final keyword abstract Keyword transient keyword in Java volatile keyword in Java strictfp keyword C++ vs Java C++ vs Java Static keyword in C++ vsJava Exception Handling in C++ vsJava Inheritance in C++ vsJava Virtual behavior differ in C++ vsJava Foreach in C++ and Java C/C++ Pointers vs Java References Comparison of boolean data type in C++ and Java Methods in Java Parameters passing Returning Multiple values Method Overloading Different ways of Method Overloading in Java Overriding equals method Overriding toString() method Private and final methods Java is Strictly Pass by Value Overloading main() Valid variants of main() Variable Arguments (Varargs) method Clone() method Remote Method Invocation Default Methods Method overloading and null error Method Overloading with Autoboxing and Widening Passing and Returning Objects in Java System.exit() method Constructors Constructors in Java Default constructor Assigning values to static final variables Copy Constructor Constructor Chaining Private Constructors and Singleton Classes Java Interview Questions on Constructors Singleton Class Constructor Overloading Output of Java Programs | Set 14 (Constructors) Exception Handling Exceptions 3 Different ways to print Exception messages in Java flow control in try-catch-finally Types of Exceptions Catching base and derived classes as exceptions Checked vs Unchecked Exceptions Throw and Throws User-defined Custom Exception Infinity or Exception? Multicatch Chained Exceptions Null Pointer Exception Output of Java program | Set 12(Exception Handling) Regular Expressions How to write Regular Expressions? Regular Expression(java.util.regex) Quantifiers Inheritance Inheritance in Java Multiple Inheritance Why Java does’nt support Multiple Inheritance – The Diamond Problem Java Object Creation of Inherited Class Inheritance and constructors Interfaces and Inheritance Using final with Inheritance Accessing Grandparent’s member Override private methods More restrictive access to a derived class method in Java Parent and Child classes having same data member Object Serialization with Inheritance Referencing Subclass objects with Subclass vs Superclass reference Does overloading work with inheritance Output of Java Program | Set 20 (Inheritance) Interfaces and Abstract Classes Interfaces Access specifier for methods in interfaces Access specifiers for classes or interfaces Abstract Classes Difference between Abstract Class and Interface in Java Comparator Interface Java Interface methods Nested Interface Nested Classes in Java Local Inner Class in Java Anonymous Inner Class in Java Functional Interfaces What is a Marker interface Questions on Abstract Classes and Interfaces Output of Java program | Set 15 (Inner Classes) Java Packages Packages Introduction java.io package java.lang package java.util package Multithreading Multithreading Lifecycle and states of a thread Main thread Methods to prevent thread execution inter thread communication Java.lang.Thread class Start() function in multithreading Java Thread Priority Joining Threads in Java Naming a thread and fetching name of current thread in Java Synchronization Method and Block Synchronization Producer-Consumer solution Thread Pools in Java Semaphore in Java Java.util.concurrent.Semaphore class in Java CountDownLatch Deadlock in java Daemon thread Cyclic Barrier in Java Callable and Future in Java Shutdown Hook in Java Runtime Class Output of Java program | Set 16 (Threads) Garbage Collection Garbage Collection How to make object eligible for garbage collection in Java? Mark-and-Sweep Island of Isolation Automatic Resource Management Output of Java programs | Set 10 (Garbage Collection) Wrapper Classes Wrapper Classes in Java Primitive Wrapper Classes are Immutable in Java Number Class Integer class Byte class Short class Long class Float class Double class Boolean Class Character Class Autoboxing and Unboxing in Java Reflection in Java Reflection in Java new operator vs newInstance() instanceof operator vs isInstance() File Handling File class Ways of Reading a text file in Java file permissions in java Moving a file from one directory to another using Java Copying file using FileStreams Delete a file using Java Java program to delete duplicate lines in text file Java program to merge two files alternatively into third file Java program to List all files in a directory and nested sub-directories | Recursive approach Java program to delete certain text from a file Check if a File is hidden in Java Redirecting System.out.println() output to a file Collection in Java Collection Overview Iterators Using Iterators Iterator vs Foreach Types of iterator List Interface List implemented classes : ArrayList(Practice) LinkedList class Vector class Stack Class Set Interface(Practice) Set implemented classes : HashSet LinkedHashSet class(Practice) TreeSet class EnumSet class Map interface Map implemented classes : HashMap Class(Practice) HashMap Methods-Set 1Set 2 LinkedHashMap class TreeMap EnumMap class IdentityHashMap class SortedSet Interface NavigableSet Interface Queue Interface Queue implemented classes : PriorityQueue Deque interface SortedMap Interface NavigableMap Interface Dictionary Class in Java Disjoint Set Data Structures (Java Implementation) Output of Java Program | Set 13(Collections) Collection Interview FAQ’s Vector vs ArrayList ArrayList vs LinkedList Comparable vs Comparator Differences between TreeMap, HashMap and LinkedHashMap HashMap vsHashTable Hashmap vs WeakHashMap in Java How to Synchronize ArrayList in Java ArrayList and LinkedList remove() methods How to Remove an element from ArrayList Collections Class (Contains utility functions on Collections) Collections.shuffle() Collections.swap() Collections.reverse() Collections.binarySearch() Collections.sort() Collections.rotate() Collections.frequency() –Set 1Set 2(Use with arrays) Collections.disjoint() Collections.reverseOrder() Double Brace Initialization Useful and/or Advanced Features Generics Wildcards in Java Assertions Annotations Serialization and Deserialization Lambda Expressions – Java 8 Stream BigInteger Class Image Processing Set 1 (Read and Write) Set 2 (Get and Set Pixels) Set 3 (Colored image to greyscale image conversion) Set 4 (Colored image to Negative image conversion) Set 5 (Colored to Red Green Blue Image Conversion) Set 6 (Colored image to Sepia image conversion) Set 7 (Creating a random pixel image) Set 9 ( Face Detection ) Set 10 ( Watermarking an image ) Set 11 (Changing orientation of image) Set 12 ( Contrast Enhancement ) Networking in Java Socket Programming Introducing Threads in Socket Programming in Java URL class in Java Reading from a URL using URLConnection Class Inet Address Class Java.net.DatagramSocket class in Java Java.net.InetSocketAddress class Java.net.URI class Java.net.Inet4Address class in Java Java.net.Inet6Address class in Java Java.net.InterfaceAddress class Java.net.MulticastSocket class in Java Java.net.DatagramPacket class in Java Java.net.URLEncoder class in Java Java.net.URLDecoder class in Java A group chat Application Java program to find IP address of your computer Multi-threaded chat Application | Set 1 (Server Side Programming) Multi-threaded Chat Application | Set 2 (Client Side Programming) Interview Questions Commonly Asked Programming Interview Questions –Set 1Set 2 10 Most asked Questions from Java Programmers Google Interview Experience | Set 5 (for Java Position) Misc Java tricks for competitive programming (for Java 8) Fast I/O in Java in Competitive Programming Performing Database Operations in Java | SQL CREATE, INSERT, UPDATE, DELETE and SELECT Establishing JDBC Connection Few Tricky Programs How to swap two variables in one line? Implementing our Own Hash Table with Separate Chaining Quick ways to check for Prime and find next Prime in Java How to create Immutable class Pair Class in Java Date class(With Examples) Generating random numbers Trigonometric Functions in Java with Examples BitSet class in Java –Set 1Set 2 Jar files in Java Working with JAR and Manifest files In Java NaN (Not a Number) in Java Generating Password and OTP Use char[] array over a string for store passwords Find free disk space using Java Programs for printing pyramid patterns in Java Creating Frames using Swings in Java Calling an External Program in Java using Process and Runtime Multiples of 3 and 5 without using % operator Serial vs Parallel Sort How to play an Audio file using Java Send email using Java Program All articles in Java Category Coding Practice Platform You can create a new Java topic and discuss it with other geeks using our portal PRACTICE. See recently added problems on Java on PRACTICE. (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice
https://www.geeksforgeeks.org/python-programming-language/	Python Programming Language - GeeksforGeeks		Python Programming Language Recent Articles on Python ! Basics, Variables, Operators, Control Flow, Functions, Modules in Python, Object Oriented Concepts, Exception Handling, Libraries and Functions, Machine Learning with Python, Data Types, Misc, Applications and Projects, Multiple Choice Questions Basics Introduction and Writing first code An Informal Introduction – Python Blog Python 2.x vs Python 3.x Keywords in Python – Introduction, Set 1, Set 2 Variables Variables, Expressions & Functions Maximum possible value of an integer Transpose a matrix in Single line Global and Local Variables Partial Functions Packing and Unpacking Arguments end parameter Type Conversion Byte objects vs Strings Operators (adsbygoogle = window.adsbygoogle || []).push({}); Logical and Bitwise Not Operators on Boolean Ternary Operator Increment and Decrement Operators Division Any & All Inplace vs Standard Operators Operator Functions in Python – Set 1, Set 2 Chaining comparison operators Control Flow Loops and Control Statements (continue, break and pass) Iterations Initialization and Updation of Counters Accessing Counters Iterators Iterator Functins – Set 1, Set 2 Generators Looping using Data Structures Printing Pyramid shapes range() vs xrange() Functions Function Decorators Write an empty function in Python – pass statement Yield instead of Return Return Multiple Values Precision Handling *args and **kwargs Python closures Coroutine Modules in Python Introduction of Modules Numeric Functions Logarithmic and Power Functions Trigonometric and Angular Functions Special Functions and Constants Inplace Operators – Set 1 Set 2 Calendar Functions – Set 1 Set 2 Complex Numbers – Introduction Complex Numbers -Important Functions and Constants Trigonometric and Hyperbolic Functions Time Functions in Python – Set 1, Set-2 Random Numbers reduce() function struct() module pprint eval() fraction() Pyautogui – Mouse Keyboard Automation Object Oriented Concepts Object Oriented Programming – Set 1 Set 2 – Data Hiding and Object Printing Set 3 – Inheritance,object,issubclass and super Class or Static Variable class vs static method Changing Class Members First Class functions Exception Handling Exception Handling in Python User Defined Exceptions Built-in Exceptions Libraries and Functions Timit function Numpy- Set 1 , Set 2 Get and Post Regular Expressions – Set 1, Set 2 OS module Copy module – Deep vs Shallow copy Import module Reload module Collection module DeQue NamedTuple Heap Enum module Statistical Functions – Set 1, Set 2 Bisect module Decimal Functions – Set 1, Set 2 NetworkX getpass() and getuser() Reading and Generating QR codes fnmatch Unicodedata – Unicode Database Textwrap – Text wrapping and filling Generating Secure random numbers pickle — Python object serialization Understanding Python Pickling with example copyreg — Register pickle support functions Python GUI – tkinter Machine Learning with Python Classifying data using Support Vector Machines(SVMs) in Python Linear Regression Understanding Logistic Regression K means Clustering Learning Model Building in Scikit-learn Tokenize text using NLTK in python Removing stop words with NLTK in Python How to get synonyms/antonyms from NLTK WordNet in Python? Implementing Artificial Neural Network training process Convert Text to Speech Data Types Introduction – Data Types – List, Tuples and Iterations Strings Strings – Set 1, Set 2 String Methods – Set 1 , Set 2 , Set 3 Logical Operators on String Split a string String Formatting using % String Template Class Regular Expressions | Set 1 (Search, Match and Find All) Python Docstrings List Comprehension and slicing List Methods in Python – Set 1 Set 2 Set 3 Tuples Tuples Set Sets Arrays Array in Python – Set 1, Set 2 Dictionary Dictionary Methods – Set 1, Set 2 Get() method for dictionaries Handling missing keys of dictionary Chainmap orderDict() Misc 10 Essential Python Tips And Tricks For Programmers Input multiple values from user in one line Command Line and Variable Arguments Truncate() Print single and multiple variables 10 interesting facts about Python Generate all permutations of a list Swap two variables in one line str() vs repr() Command Line Interface Programming Check if a valid keyword of Python sep parameter in print json format Quine First non-repeating character from a stream of characters Permutation and Combination end parameter in print() Python Input Methods for Competitive Programming Amazing hacks of Python Implementing web scraping using lxml in Python Short Circuiting Techniques Formatted text in Linux Terminal Optimization Tips for Python Code Understanding Code Reuse and Modularity Difference between various Implementations of Python NZEC error Program to calculate the Round Trip Time (RTT) Quickly convert Decimal to other bases Reading and Writing to text files Using else conditional statement with for loop SQL using Python MongoDB and Python Defining Clean Up Actions Metaprogramming with Metaclasses Python Virtual Environment Program to check if a string is palindrome or not Vulnerability in input() function – Python 2.x File objects Applications and Projects Creating a Proxy Webserver in Python – Set1, Set 2 Send message to FB friend Creating a C/C++ Code Formatting tool with help of Clang tools Handling Ajax request in Django Twitter Sentiment Analysis using Python Working with Images Graph Plotting – Set 1, Set 2, Set 3 Generate a graph using Dictionary XML Parsing Working with PDF Files Packaging and Publishing Python Code Data analysis and Visualization Working with zip files Working with CSV files Downloading files from Web Whatsapp using Python OpenCV python program for Face Detection Implementing Web Scraping in Python with BeautifulSoup Implemeting Artificial Neural Network Training Simple Multithreaded download manager Create a website Alarm A Game of Anagrams Building a terminal based online dictionary with Python and bash Desktop Notifier Junk File Organizer Send mail from your Gmail account using Python Detection of a specific color(blue here) using OpenCV Determine the type of an image in Python using imghdr Tracking bird migration Bloom Filters – Introduction and Python Implementation OpenCV Python Program to analyze an image using Histogram Simple Chat Room Speech Recognition in Python using Google Speech API Birthday Reminder Application Hangman Performing Google Search using Python code Python Desktop News Notifier in 20 lines Send mail with attachment from your Gmail account All articles in Python Category Coding Practice Platform (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice
https://www.geeksforgeeks.org/php/	PHP Tutorials - GeeksforGeeks		PHP Tutorials ‘Recent Articles’ on PHP Basics Array Strings Mathematics Functions Input-Output Output Misc Basics: Introduction Setting up development environment Coding Standards Basic Syntax Echo and Print Variables and Data-Types Superglobals Constants Defining Constants Operators Bitwise-operators Decision Making Loops Functions Arrays Strings Check if a number is Perfect number Check if a number is prime Check if a number is Even or Odd Fibonacci Series Factorial of a Number Sum of digits of a number Fibonacci Series PHP program to print an arithmetic progression series using inbuilt functions Separate odd and even elements from array without using loop Array: php|end() php|prev() php|current() php|reset() php|key() php|range() php|max() php|count() php|array_chunk() php|usort() php|pos() php|min() php|array_slice() php|sizeof() php|array_values() php|uasort() php|array_replace() php|array_fill_keys() php|shuffle() php|array_unique() php|compact() php|extract() php|array_flip() php|array_product() php|array_intersect_assoc() php|array_filter() php|array_intersect() php|array_keys() php|array_pad() php|array_count_values() php|array_combine() php|array_diff() php|array_fill() php|array_diff_keys() php|array_diff_assoc() php|array_sum() php|array_splice() php|array_intersect_key() php|array_unshift() php|array_push() php|array_rand() php|array_pop() php|array_reduce() php|array_reverse() php|array_shift() php|array_search() php|array_key_exists() Sorting Arrays in PHP 5 php|array_search() Merging two or more arrays using array_merge() Change strings in an array to uppercase Sort an array of dates Strings: String Functions php|natcasesort() php|natsort() php|strtoupper() php|str_split() php|str_repeat() php|str_replace() PHP | str_shuffle() php|strcmp() php|strrpos() and strripos() php|str_word_count() php|strpos() and stripos() php|substr() Palindrome Check Reverse a String Change strings in an array to uppercase Concatenation of two strings in PHP Mathematics: php|Math Functions (abs, pi, deg2rad, rad2deg, fmod, floor, ceil, round, is_finite, is_infinite) php|Math Functions (is_nan, pow, sqrt, exp, log, log10, log1p, max, min, getrandmax, rand, mt_rand) php|round() php|octdec() php|deoct() php|decbin() php|bindec() php|dechex() php|pow() php|base_convert() php|ceil() php|abs() php|sine() php|cos() php|tan() php|pi() php|sqrt() php|log() and log10() php|pi() php|hypot() php|asin() php|acos() php|atan() php|deg2rad() php|rad2deg() php|cosh() php|sinh() php|acosh() php|atanh() php|atan2() php|fmod() php|asinh() php|exp() php|intdiv() php|is_finite(), is_infinite(), is_nan() Functions: php|mt_rand() php|hexdec() PHP | parse_str() php|include_once() and require_once() php|filter_var() php|srand() php|hexdec() php|md5(), sha1(), hash() php|crypt()& password_hash() php|date() and time() php|date_create(),date_format()and add_date() php|include() and require() php|implode() and explode() php|var_dump() php|mail() php|rand() Input-Output: php|ob_start() Output Buffering Output: php|ob_end_flush() and ob_end_clean() Output of PHP programs|Set 1 Output of PHP programs|Set 2 Output of PHP programs|Set 3 Output of PHP programs| Set 4 Misc: MySQL Database Introduction MySQL ( Creating Database ) MySQL ( Creating Table ) MySQL Select Query MySQL UPDATE Query MySQL Delete Query Inserting into MySQL database MySQL LIMIT Clause MySQL WHERE Clause MySQL ORDER BY Clause PHP 5 VS PHP 7 Determining Client IP Address HTTP GET and POST Methods in PHP Program to count Page Views Cookies Basics of File Handling LDAP and LDAP Injection/Prevention PHP program to fetch data from localhost server database using XAMPP (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here. Load Comments Share this post !
https://www.geeksforgeeks.org/javascript-tutorial/	JavaScript Tutorials - GeeksforGeeks		JavaScript Tutorials @media(min-width: 768px){ .column-2{ columns: 2; -webkit-columns: 2; -moz-columns: 2; } .column-2 li{ list-style-position: inside; -webkit-column-break-inside: avoid; page-break-inside: avoid; break-inside: avoid; } } ‘Recent Articles’ on Javascript Basics Array Strings Mathematics Javascript | Atomics Form Implementation of Data Structures ES2015 Misc Basics: JavaScript | The Awesome Script Variables and Datatypes Understanding variable scopes in Javascript Understanding basic JavaScript codes If-else Statement Switch-Case Loops Functions JavaScript Backend basics Advanced JavaScript Backend Basics Date.UTC() Array: Arrays JavaScript|Basic Array Methods JavaScript|Array.prototype.map() JavaScript|Array.findIndex() JavaScript|array.entries() JavaScript|Array every() JavaScript|Array copyWithin() JavaScript|array.values() JavaScript|array.toLocaleString() JavaScript|Array.of() JavaScript|Array some() JavaScript|Array join() JavaScript|Array fill() JavaScript|Array find() JavaScript|Array concat() JavaScript|Array filter() JavaScript|Array shift() JavaScript| Array.isArray() JavaScript|Array toString() JavaScript|Array reverse() JavaScript|Array sort() JavaScript|length of string and array objects JavaScript|Array pop() JavaScript|Array push() JavaScript|Array forEach() JavaScript|Array lastIndexOf() JavaScript| Array slice() JavaScript|Array unshift() JavaScript| Array indexOf() Must use JavaScript Array Functions – Part 1 Must use JavaScript Array Functions – Part 2 Must use JavaScript Array Functions – Part 3 Strings: JavaScript|String substr() JavaScript|String trim() JavaScript|String.prototype.charCodeAt() JavaScript|String.fromCharCode() JavaScript|String startsWith() JavaScript|String lastIndexOf() JavaScript|String toUpperCase() JavaScript|String toLowerCase() JavaScript|String split() JavaScript|String includes() JavaScript|String indexOf() JavaScript|String endsWith() JavaScript|String concat() JavaScript|String charAt() Mathematics: (adsbygoogle = window.adsbygoogle || []).push({}); JavaScript|Math.log2() JavaScript|Math.sinh() JavaScript|Math.LOG10E property JavaScript|Math.log10() JavaScript|Math.tanh() JavaScript|Math.expm1() JavaScript|Math.clz32() JavaScript|Math.cbrt() JavaScript|Math.cosh() JavaScript|Math.acosh() JavaScript|Math.asinh() JavaScript| Math.E() JavaScript|Math.atanh() JavaScript|Math.atan() JavaScript|Math.exp() JavaScript|toExponential() JavaScript|Math.round() JavaScript|Math.ceil() JavaScript|Math.floor() JavaScript|Math.abs() JavaScript|Math.atan2() JavaScript|Math.imul() JavaScript|Number valueOf() JavaScript|Math.asin() JavaScript|Math.acos() JavaScript|Math.cos() JavaScript|Math.tan() JavaScript|Math.sin() JavaScript|Math.min() JavaScript|Math.max() JavaScript|Math.pow() JavaScript|Math.fround() JavaScript|Math.trunc() JavaScript|Math.hypot() JavaScript|Math.log() JavaScript|toPrecision() Javascript|toFixed() Javascript|Number.isInteger( ) Javascript|toString() Javascript|Number.isFinite() Javascript|Math.random() Javascript|Number.isSafeInteger() Javascript|Number.isNaN() Javascript | Atomics: JavaScript|Atomics.add() JavaScript|Atomics.xor() JavaScript|Atomics.and() JavaScript|Atomics.or() Form: Form validation using HTML and JavaScript JavaScript|Auto-filling one field same as other How to create a responsive Modal Sign-Up form for a Website? JavaScript|Dialogue Boxes Implementation of Data Structures: Implementation of Binary Search Tree in Javascript Implementation of Priority Queue in Javascript Implementation of LinkedList in Javascript Implementation of Queue in Javascript Implementation of Stack in JavaScript Implementation of Graph in JavaScript ES2015: ES2015: Latest version of JavaScript New features of JavaScript Arrays with ES2015 Closure Map Sets JavaScript ES2015: Block Scoping Misc: jQuery | Introduction Introduction to React Native Run Python script from Node.js using child process spawn() method Nodejs – Connect MongoDB with Node app using MongooseJS Creating Progress Bar using JavaScript Calculator App How To Add Google Translate Button On Your Webpage? OpenUI5 – Javascript UI Library from SAP Cookie Tracking and Stealing using Cross-Site Scripting (adsbygoogle = window.adsbygoogle || []).push({}); Company Wise Coding Practice Topic Wise Coding Practice
https://www.geeksforgeeks.org/tracxn-interview-experience-set-2/	Tracxn Interview Experience | Set 2 - GeeksforGeeks		Tracxn Interview Experience | Set 2 I applied for Tracxn online. After few days got a call from the HR asking about my CTC and notice period. HR told me that the first round is going to be an online test comprising of 1 coding question to be answered in the duration of 1 hour. I got the test link and cleared the first round. The question in the online round was a string manipulation question. The question was like given a string composed of numbers starting from the left side keep on adding the numbers until the sum reaches the threshold value. Once the sum crosses the threshold value add that sum to a new string and change the threshold to the new sum. Keep on doing this until you have reached the end of the input string. Once the input string is exhausted take the newly formed string and apply the same operation on the string until you have only 1 digit left in the string. When switching to the new string you have to reset the threshold value back to the original value. Example: Input String: 1234567879 Threshold: 10 Sum of digits starting from left: 1+2+3+4+5 = 15 New String: 15 New Threshold: 15 Sum of digits starting from left: 6+7+8 = 21 New String: 1521 New Threshold: 21 Sum of digits starting from left: 7+9 = 16 New String: 152116 New Threshold: 10 —> Since we have exhausted the string before reaching the threshold we reset it to the old value. New String: 152116 Sum of digits starting from left: 1+5+2+1+1+6 = 16 New String: 16 New Threshold: 10 New String: 16 Sum of digits starting from left: 1+6 = 7 New String: 7 New Threshold: 10 Output 7 since now only 1 digit is left in the string. After this I was called for F2F interview in their office in Bangalore. The interviewer was polite and even helped me when I got stuck in between. It was a 45 minute round comprising of two questions: 1. Implement String.indexOf() function. Basically given two strings return the index of the first occurrence of string2 in string1, -1 otherwise. Example: Input: String1 = “fffg” String2 = “ffg” Output: 1 2. Find the missing number in Arithmetic Progression Example: Input: 1 5 9 13 21 25 29 Output: 17 He expected me to solve this in O(log n) time. After the first round the interviewer told me to wait and somebody else will come for the second round, but after few minutes he told me that we are done for today and you can leave. After few days I mailed the HR to ask about the status and she told that we don’t have anything suitable position according to your skills. (adsbygoogle = window.adsbygoogle || []).push({}); If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. Interview Experiences Tracxn Please write to us at contribute@geeksforgeeks.org to report any issue with the above content. Recommended Posts:Android Developer Summer Internship Interview Experience in a StartupMakeMyTrip Interview Experience | Set 17 (Senior Software Engineer)Microsoft Office India Interview experience | Set 170 (2 Years Exp)Bloomberg Interview Experience | Set 7 (For SDE)HSBC Interview Experience | Set 7Microsoft Interview Experience | Set 169Microsoft IDC Interview Experience | Set 168 (Off-Campus for Internship)Aphonso Interview ExperiencePaytm interview experience | Set 24 (1.5 years experienced)Amazon Interview Experience | Set 426 (For SDE-1) Post navigation << Previous Post (Login to Rate) 0 Average Difficulty : 0/5.0No votes yet. Add to TODO List Mark as DONE #share-buttons img { width: 35px; padding: 5px; border: 0; box-shadow: 0; display: inline; } #share-buttons a:hover { text-decoration: none; } Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here. Load Comments Share this post!
https://www.geeksforgeeks.org/generating-hash-ids-using-uuid3-and-uuid5-in-python/	Generating hash id's using uuid3() and uuid5() in Python - GeeksforGeeks		Generating hash id’s using uuid3() and uuid5() in Python Python’s UUID class defines four functions and each generates different version of UUIDs. Let’s see how to generate UUID based on MD5 and SHA-1 hash using uuid3() and uuid5() . Cryptographic hashes can be used to generate different ID’s taking NAMESPACE identifier and a string as input. The functions that support cryptographic hash generation are : uuid3(namespace, string) : This function uses MD5 hash value of namespaces mentioned with a string to generate a random id of that particular string. uuid5(namespace, string) : This function uses SHA-1 hash value of namespaces mentioned with a string to generate a random id of that particular string. uuid module defines the following namespace identifiers for use with uuid3() or uuid5() : NAMESPACE_DNS : Used when name string is fully qualified domain name. NAMESPACE_URL : Uused when name string is a URL. NAMESPACE_OID : Used when name string is an ISO OID. NAMESPACE_X500 : Used when name string is an X.500 DN in DER or a text output format. Code #1 : (adsbygoogle = window.adsbygoogle || []).push({}); # Python3 code to demonstrate working # of uuid3() and uuid5() import uuid # initializing a string url = "https://www.geeksforgeeks.org/fibonacci-sum-subset-elements/" # using NAMESPACE_URL as namespace # to generate MD5 hash uuid print ("The SHA1 hash value generated ID is : ", uuid.uuid3(uuid.NAMESPACE_URL, url)) # using NAMESPACE_URL as namespace # to generate SHA-1 hash uuid print ("The MD5 hash value generated ID is : ", uuid.uuid5(uuid.NAMESPACE_URL, url)) Output: The SHA1 hash value generated ID is : e13a319e-16d9-3ff5-a83c-96564007998e The MD5 hash value generated ID is : dbe3178d-4b83-5024-9b26-9b8e1b280514 Code #2 : # Python3 code to demonstrate working # of uuid3() and uuid5() import uuid # initializing a string qualified_dns = "www.geeksforgeeks.org" # using NAMESPACE_DNS as namespace # to find MD5 hash id print ("The SHA1 hash value generated ID is : ", uuid.uuid3(uuid.NAMESPACE_DNS, qualified_dns)) # using NAMESPACE_DNS as namespace # to generate SHA-1 hash id print ("The MD5 hash value generated ID is : ", uuid.uuid5(uuid.NAMESPACE_DNS, qualified_dns)) Output: The SHA1 hash value generated ID is : adbed9f7-bbe3-376f-b88d-2018b8f6db07 The MD5 hash value generated ID is : f72cdf8a-b361-50b2-9451-37a997f8675d Note : The ID generation is 2 step process. First, the concatenation of string and namespaces takes place, then given as input to the respective function to return a 128 UUID generated. If the same NAMESPACE value with a similar string is chosen again, ID generated will be same as well. Reference : https://docs.python.org/2/library/uuid.html (adsbygoogle = window.adsbygoogle || []).push({}); suman_709Check out this Author's contributed articles.If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. PythonTechnical Scripter Python-Library Please write to us at contribute@geeksforgeeks.org to report any issue with the above content. Recommended Posts:numpy.floor() in Pythonnumpy.ceil() in Pythonnumpy.fix() in Pythonnumpy.rint() in Pythonnumpy.log() in Pythonnumpy.trunc() in Pythonnumpy.round_() in Pythondegrees() and radians() in PythonPython program to convert float decimal to Octal numberPython Number | cmp(list) method Post navigation << Previous Post Next Post >> (Login to Rate) 0 Average Difficulty : 0/5.0No votes yet. Add to TODO List Mark as DONE #share-buttons img { width: 35px; padding: 5px; border: 0; box-shadow: 0; display: inline; } #share-buttons a:hover { text-decoration: none; } Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here. Load Comments Share this post!
https://www.geeksforgeeks.org/new-date-time-api-java8/	New Date-Time API in Java 8 - GeeksforGeeks		New Date-Time API in Java 8 New date-time API is introduced in Java 8 to overcome the following drawbacks of old date-time API : Not thread safe : Unlike old java.util.Date which is not thread safe the new date-time API is immutable and doesn’t have setter methods. Less operations : In old API there are only few date operations but the new API provides us with many date operations. Java 8 under the package java.time introduced a new date-time API, most important classes among them are : Local : Simplified date-time API with no complexity of timezone handling. Zoned : Specialized date-time API to deal with various timezones. LocalDate/LocatTime and LocalDateTime API : Use it when time zones are NOT required. // Java code for LocalDate // / LocalTime Function import java.time.*; import java.time.format.DateTimeFormatter; public class Date { public static void LocalDateTimeApi() { // the current date LocalDate date = LocalDate.now(); System.out.println("the current date is "+ date); // the current time LocalTime time = LocalTime.now(); System.out.println("the current time is "+ time); // will give us the current time and date LocalDateTime current = LocalDateTime.now(); System.out.println("current date and time : "+ current); // to print in a particular format DateTimeFormatter format = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"); String formatedDateTime = current.format(format); System.out.println("in foramatted manner "+ formatedDateTime); // printing months days and seconds Month month = current.getMonth(); int day = current.getDayOfMonth(); int seconds = current.getSecond(); System.out.println("Month : "+month+" day : "+ day+" seconds : "+seconds); // printing some specified date LocalDate date2 = LocalDate.of(1950,1,26); System.out.println("the repulic day :"+date2); // printing date with current time. LocalDateTime specificDate = current.withDayOfMonth(24).withYear(2016); System.out.println("specfic date with "+ "current time : "+specificDate); } // Driver code public static void main(String[] args) { LocalDateTimeApi(); } } Output: the current date is 2018-04-09 the current time is 06:21:10.409 current date and time : 2018-04-09T06:21:10.410 in foramatted manner 09-04-2018 06:21:10 Month : APRIL day : 9 seconds : 10 the repulic day :1950-01-26 specfic date with current time : 2016-04-24T06:21:10.410 Zoned date-time API : Use it when time zones are to be considered // Java code for Zoned date-time API import java.time.LocalDateTime; import java.time.ZoneId; import java.time.ZonedDateTime; import java.time.format.DateTimeFormatter; public class Zone { // Function to get Zoned Date and Time public static void ZonedTimeAndDate() { LocalDateTime date = LocalDateTime.now(); DateTimeFormatter format1 = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"); String formattedCurrentDate = date.format(format1); System.out.println("formatted current Date and"+ " Time : "+formattedCurrentDate); // to get the current zone ZonedDateTime currentZone = ZonedDateTime.now(); System.out.println("the current zone is "+ currentZone.getZone()); // getting time zone of specific place // we use withZoneSameInstant(): it is // used to return a copy of this date-time // with a different time-zone, // retaining the instant. ZoneId tokyo = ZoneId.of("Asia/Tokyo"); ZonedDateTime tokyoZone = currentZone.withZoneSameInstant(tokyo); System.out.println("tokyo time zone is " + tokyoZone); DateTimeFormatter format = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss"); String formatedDateTime = tokyoZone.format(format); System.out.println("formatted tokyo time zone "+ formatedDateTime); } // Driver code public static void main(String[] args) { ZonedTimeAndDate(); } } Output: formatted current Date and Time : 09-04-2018 06:21:13 the current zone is Etc/UTC tokyo time zone is 2018-04-09T15:21:13.220+09:00[Asia/Tokyo] formatted tokyo time zone 09-04-2018 15:21:13 Period and Duration classes : Period : It deals with date based amount of time. Duration : It deals with time based amount of time. (adsbygoogle = window.adsbygoogle || []).push({}); // Java code for period and duration import java.time.LocalDate; import java.time.LocalTime; import java.time.Month; import java.time.Duration; import java.time.Period; public class Geekforgeeks { public static void checkingPeriod() { LocalDate date1 = LocalDate.now(); LocalDate date2 = LocalDate.of(2014, Month.DECEMBER, 12); Period gap = Period.between(date2, date1); System.out.println("gap between dates "+ "is a period of "+gap); } // Function to check duration public static void checkingDuraion() { LocalTime time1 = LocalTime.now(); System.out.println("the current time is " + time1); Duration fiveHours = Duration.ofHours(5); // adding five hours to the current // time and storing it in time2 LocalTime time2 = time1.plus(fiveHours); System.out.println("after adding five hours " + "of duration " + time2); Duration gap = Duration.between(time2, time1); System.out.println("duraion gap between time1" + " & time2 is " + gap); } // Driver code public static void main(String[] args) { checkingPeriod(); checkingDuraion(); } } Output: gap between dates is a period of P3Y3M28D the current time is 06:21:18.248 after adding five hours of duration 11:21:18.248 duraion gap between time1 & time2 is PT-5H ChronoUnits Enum : java.time.temporal.ChronoUnit enum is added in Java 8 to replace integer values used in old API to represent day, month etc. // Java code for ChronoUnits Enum import java.time.LocalDate; import java.time.temporal.ChronoUnit; public class Geeksforgeeks { // Function to check ChronoUnit public static void checkingChronoEnum() { LocalDate date = LocalDate.now(); System.out.println("current date is :" + date); // adding 2 years to the current date LocalDate year = date.plus(2, ChronoUnit.YEARS); System.out.println("next to next year is " + year); // adding 1 month to the current data LocalDate nextMonth = date.plus(1, ChronoUnit.MONTHS); System.out.println("the next month is " + nextMonth); // adding 1 week to the current date LocalDate nextWeek = date.plus(1, ChronoUnit.WEEKS); System.out.println("next week is " + nextWeek); // adding 2 decades to the current date LocalDate Decade = date.plus(2, ChronoUnit.DECADES); System.out.println("20 years after today " + Decade); } // Driver code public static void main(String[] args) { checkingChronoEnum(); } } Output: current date is :2018-04-09 next to next year is 2020-04-09 the next month is 2018-05-09 next week is 2018-04-16 20 years after today 2038-04-09 TemporalAdjuster : It is used to perform various date related operations. // Java code Temporal Adjuster import java.time.LocalDate; import java.time.temporal.TemporalAdjusters; import java.time.DayOfWeek; public class Geek { // Function to check date and time // according to our requirement public static void checkingAdjusters() { LocalDate date = LocalDate.now(); System.out.println("the current date is "+ date); // to get the first day of next month LocalDate dayOfNextMonth = date.with(TemporalAdjusters. firstDayOfNextMonth()); System.out.println("firstDayOfNextMonth : " + dayOfNextMonth ); // get the next saturday LocalDate nextSaturday = date.with(TemporalAdjusters. next(DayOfWeek.SATURDAY)); System.out.println("next satuday from now is "+ nextSaturday); // first day of current month LocalDate firstDay = date.with(TemporalAdjusters. firstDayOfMonth()); System.out.println("firstDayOfMonth : " + firstDay); // last day of current month LocalDate lastDay = date.with(TemporalAdjusters. lastDayOfMonth()); System.out.println("lastDayOfMonth : " + lastDay); } // Driver code public static void main(String[] args) { checkingAdjusters(); } } Output: the current date is 2018-04-09 firstDayOfNextMonth : 2018-05-01 next satuday from now is 2018-04-14 firstDayOfMonth : 2018-04-01 lastDayOfMonth : 2018-04-30 (adsbygoogle = window.adsbygoogle || []).push({}); SrjSunnyCheck out this Author's contributed articles.If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. JavaTechnical Scripter Please write to us at contribute@geeksforgeeks.org to report any issue with the above content. Recommended Posts:Java sqrt() method with ExamplesJava Math getExponent() method with ExampleJava Math getExponent() method with ExampleJava signum() method with ExamplesJava | Date format validation using RegexJava floor() method with ExamplesJava ceil() method with ExamplesJava cbrt() method with ExamplesJava atan() method with ExamplesJava Math sinh() method with Examples Post navigation << Previous Post Next Post >> (Login to Rate) 0 Average Difficulty : 0/5.0No votes yet. Add to TODO List Mark as DONE #share-buttons img { width: 35px; padding: 5px; border: 0; box-shadow: 0; display: inline; } #share-buttons a:hover { text-decoration: none; } Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here. Load Comments Share this post!
https://www.geeksforgeeks.org/python-list/	Python List - GeeksforGeeks		Python List Lists are one of the most powerful tools in Python. They are just like the arrays declared in other languages. But the most powerful thing is that list need not be always homogeneous. A single list can contain strings, integers, as well as objects. Lists can also be used for implementing stacks and queues. Lists are mutable, i.e., they can be altered once declared. # Declaring and printing list L = [1, "a" , "string" , 1+2] print(L) # Adding more items L.append(6) print(L) # Removing an item L.pop() print(L) # Printing a particular item print(L[1]) The output is : [1, 'a', 'string', 3] [1, 'a', 'string', 3, 6] [1, 'a', 'string', 3] a Recent Articles on Python List Built-in Functions, Programs of List Built-in Functions Append(): Add an element to the end of the list Extend(): Add all elements of a list to the another list Insert(): Insert an item at the defined index Remove(): Removes an item from the list Pop(): Removes and returns an element at the given index Clear(): Removes all items from the list Index(): Returns the index of the first matched item Count(): Returns the count of number of items passed as an argument Sort(): Sort items in a list in ascending order Reverse(): Reverse the order of items in the list Copy(): Returns a shallow copy of the list Programs of List Comprehension and slicing List Methods in Python – Set 1 Set 2 Python map function to find row with maximum number of 1’s Numbers in a list within a given range Print list after removing element at given index Extending a list in Python Check if all the values in a list that are greater than a given value Comprehension to find pair with given sum from two arrays Get unique values from a list Lambda expression and filter function Prefix sum array in Python using accumulate function Check whether two lists are circularly identical Check whether a list is empty or not Check if two lists have at-least one element common List Slicing Difference between two lists Maximum and minimum element’s position in a list Print first m multiples of n without using any loop in Python Print first m multiples of n without using any loop in Python Program to check if two given matrices are identical Sort the values of first list using second list Print all the common elements of two lists Print all sublists of a list Iterate over multiple lists simultaneously Segregate 0’s and 1’s in an array list Count occurrences of an element in a list Reversing a List Count set bits using Python List comprehension Creating a 3D List Creating a sorted merged list of two unsorted lists in Python Remove Duplicates from a List Largest, Smallest, Second Largest, Second Smallest in a List Find average of a list in python Sort a List according to the Length of the Elements Intersection of two lists Multiply all numbers in the list Generate random numbers within a given range and store in a list Union of two or more Lists Remove and print every third from list until it becomes empty Python Slicing Print anagrams together in Python using List and Dictionary List comprehension and ord() in Python Move all zeroes to end of array using List Comprehension in Python Sort a list according to the second element in sublist Convert an array to an ordinary list with the same items Python program to find Cumulative sum of a list Find missing and additional values in two lists Split the Even and Odd elements into two different lists Cloning or Copying a list More Useful Links Recent Articles on Python List Output of Python Programs in List : Set 6, Set 11, Set 12, Set 13 Recent Articles on Python Coding Practice Platform Multiple Choice Questions All articles in Python Category Python Tutorials (adsbygoogle = window.adsbygoogle || []).push({}); ayushmaan bansalCheck out this Author's contributed articles.If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. Program OutputPythonPython Programs python-list Please write to us at contribute@geeksforgeeks.org to report any issue with the above content. Recommended Posts:Output of C programs | Set 65 (If-Else)Output of C programs | Set 64 (Pointers)Output of Python Programs | Set 24 (Sets)Output of Java Programs | Set 53 (String Comparison)Output of Java Programs | Set 52 (Strings Class)Output of Python Programs | Set 23 (String in loops)Output of Python Programs | Set 22 (Loops)Output of Python Programs | Set 21 (Bool)Output of Python Programs | Set 20 (Tuples)Output of C programs | Set 63 Post navigation << Previous Post Next Post >> (Login to Rate) 0 Average Difficulty : 0/5.0No votes yet. Add to TODO List Mark as DONE #share-buttons img { width: 35px; padding: 5px; border: 0; box-shadow: 0; display: inline; } #share-buttons a:hover { text-decoration: none; } Writing code in comment? Please use ide.geeksforgeeks.org, generate link and share the link here. Load Comments Share this post!
